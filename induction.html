<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CS 70 综合学习指南 - 归纳法</title>
  <link rel="stylesheet" href="css/styles.css">
  <script src="js/mathjax-config.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>
  <script src="js/main.js" defer></script>
</head>
<body>
  <div class="header">
    <h1>📚 CS 70 综合学习指南</h1>
    <div class="header-controls">
      <input type="text" class="search-box" placeholder="搜索知识点或题目..." id="searchBox">
      <button class="theme-toggle" id="themeToggle">🌙 深色模式</button>
      <div class="lang-toggle" id="langToggle">
        <button type="button" class="theme-toggle" data-lang="zh-CN">中文</button>
        <button type="button" class="theme-toggle" data-lang="en">English</button>
      </div>
    </div>
  </div>

  <button class="sidebar-toggle" id="sidebarToggle">☰</button>

  <nav class="sidebar" id="sidebar">
    <a class="nav-item" href="logic.html#logic">1. Propositional Logic</a>
    <a class="nav-subitem" href="logic.html#logic-operators">1.1 基本逻辑运算符</a>
    <a class="nav-subitem" href="logic.html#logic-equivalence">1.2 逻辑等价</a>
    <a class="nav-subitem" href="logic.html#logic-quantifiers">1.3 量词</a>

    <a class="nav-item" href="proofs.html#proofs">2. Proof Techniques</a>
    <a class="nav-subitem" href="proofs.html#proof-direct">2.1 直接证明</a>
    <a class="nav-subitem" href="proofs.html#proof-contradiction">2.2 反证法</a>
    <a class="nav-subitem" href="proofs.html#proof-contrapositive">2.3 逆否命题</a>
    <a class="nav-subitem" href="proofs.html#proof-pigeonhole">2.4 鸽笼原理</a>

    <a class="nav-item" href="induction.html#induction">3. Induction</a>
    <a class="nav-subitem" href="#induction-weak">3.1 弱归纳法</a>
    <a class="nav-subitem" href="#induction-strong">3.2 强归纳法</a>
    <a class="nav-subitem" href="#induction-formulas">3.3 常用求和公式</a>

    <a class="nav-item" href="matching.html#matching">4. Stable Matching</a>
    <a class="nav-item" href="graphs.html#graphs">5. Graph Theory</a>

    <a class="nav-item" href="modular.html#section6">6. Modular Arithmetic</a>
    <a class="nav-item" href="polynomials.html#section7">7. Polynomials</a>
    <a class="nav-item" href="counting.html#counting">8. Counting</a>
  </nav>

  <main class="main-content">
    <section class="section" id="induction">
      <h2 class="section-title">3. Induction（数学归纳法）</h2>

      <!-- 3.1 Weak Induction -->
      <div class="subsection" id="induction-weak">
        <h3 class="subsection-title">
          <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
          3.1 弱归纳法（Weak/Simple Induction）
        </h3>
        <div class="collapsible-content">
          <div class="concept-box">
            <h4>📚 核心概念</h4>
            <p>数学归纳法用于证明关于自然数的命题。弱归纳法假设命题对 \(n\) 成立，然后证明对 \(n+1\) 也成立。</p>
            <ul>
              <li><strong>适用范围</strong>：证明对所有 \(n \geq n_0\) 的命题 \(P(n)\)</li>
              <li><strong>递推性质</strong>：\(P(n+1)\) 只依赖于 \(P(n)\)</li>
            </ul>
          </div>

          <div class="formula-box">
            <h4>📐 弱归纳法三步骤</h4>
            <div class="formula-item">
              <strong>Step 1 - 基础步骤（Base Case）：</strong>
              <br>证明 \(P(n_0)\) 成立（通常 \(n_0 = 0\) 或 \(1\)）
            </div>
            <div class="formula-item">
              <strong>Step 2 - 归纳假设（Inductive Hypothesis）：</strong>
              <br>假设 \(P(n)\) 对某个 \(n \geq n_0\) 成立
            </div>
            <div class="formula-item">
              <strong>Step 3 - 归纳步骤（Inductive Step）：</strong>
              <br>在假设 \(P(n)\) 成立的前提下，证明 \(P(n+1)\) 也成立
            </div>
            <div class="formula-item">
              <strong>结论：</strong>
              \[[\,P(n_0) \land (\forall n \geq n_0)(P(n) \Rightarrow P(n+1))\,] \Rightarrow (\forall n \geq n_0)P(n)\]
            </div>
          </div>

          <div class="tips-box">
            <h4>💡 解题技巧</h4>
            <ul>
              <li><strong>明确标注三个步骤</strong>：Base Case, IH, Inductive Step</li>
              <li><strong>归纳步骤关键</strong>：必须<em>使用</em>归纳假设 \(P(n)\) 来证明 \(P(n+1)\)</li>
              <li><strong>代数技巧</strong>：将 \(P(n+1)\) 的式子改写，使其包含 \(P(n)\) 的形式</li>
              <li><strong>避免循环论证</strong>：不能在证明中直接使用要证明的结论</li>
            </ul>
          </div>

          <!-- Problem 1: Divisibility -->
          <div class="problem-card">
            <div class="problem-header">
              <div class="problem-meta">
                <span class="source-tag">midterm_fa24.pdf - Q5</span>
                <span class="difficulty">⭐⭐⭐</span>
              </div>
            </div>
            <div class="problem-content">
              <strong>题目：</strong>用归纳法证明对于所有 \(n \geq 1\)：
              \[7 \mid \left(3^{(2n+1)} + 2^{(n-1)}\right)\]
              要求清楚标明 base case, induction hypothesis, 和 induction step。
            </div>
            <div class="problem-actions">
              <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
            </div>
            <div class="answer-box">
              <h4>✅ 证明：</h4>

              <p><strong>Base Case（\(n = 1\)）：</strong></p>
              <ul>
                <li>当 \(n = 1\) 时：\(3^{2(1)+1} + 2^{1-1} = 3^3 + 2^0 = 27 + 1 = 28\)</li>
                <li>\(28 = 7 \times 4\)，所以 \(7 \mid 28\) ✓</li>
                <li>Base case 成立</li>
              </ul>

              <p><strong>Inductive Hypothesis（归纳假设）：</strong></p>
              <ul>
                <li>假设对某个 \(n \geq 1\)，命题成立，即：</li>
                <li>\(7 \mid \left(3^{(2n+1)} + 2^{(n-1)}\right)\)</li>
                <li>这意味着存在整数 \(k\) 使得：\(3^{(2n+1)} + 2^{(n-1)} = 7k\)</li>
              </ul>

              <p><strong>Inductive Step（证明 \(n+1\) 的情况）：</strong></p>
              <ul>
                <li>需要证明：\(7 \mid \left(3^{(2(n+1)+1)} + 2^{((n+1)-1)}\right)\)</li>
                <li>即证明：\(7 \mid \left(3^{(2n+3)} + 2^{n}\right)\)</li>
                <li>展开：
                  \begin{align}
                  3^{(2n+3)} + 2^{n} &= 3^{(2n+1)+2} + 2^{n} \\
                  &= 3^{(2n+1)} \cdot 3^2 + 2^{n} \\
                  &= 9 \cdot 3^{(2n+1)} + 2 \cdot 2^{(n-1)}
                  \end{align}
                </li>
                <li>从归纳假设知：\(3^{(2n+1)} + 2^{(n-1)} = 7k\)</li>
                <li>所以：\(3^{(2n+1)} = 7k - 2^{(n-1)}\)</li>
                <li>代入：
                  \begin{align}
                  9 \cdot 3^{(2n+1)} + 2 \cdot 2^{(n-1)} &= 9(7k - 2^{(n-1)}) + 2 \cdot 2^{(n-1)} \\
                  &= 63k - 9 \cdot 2^{(n-1)} + 2 \cdot 2^{(n-1)} \\
                  &= 63k - 7 \cdot 2^{(n-1)} \\
                  &= 7(9k - 2^{(n-1)})
                  \end{align}
                </li>
                <li>因此 \(7 \mid \left(3^{(2n+3)} + 2^{n}\right)\) ✓</li>
              </ul>

              <p><strong>结论：</strong>由数学归纳法，命题对所有 \(n \geq 1\) 成立。</p>
            </div>
          </div>

          <!-- Problem 2: Fibonacci -->
          <div class="problem-card">
            <div class="problem-header">
              <div class="problem-meta">
                <span class="source-tag">midterm_sp24.pdf - Q6(a)</span>
                <span class="difficulty">⭐⭐⭐</span>
              </div>
            </div>
            <div class="problem-content">
              <strong>题目：</strong>斐波那契数列定义为 \(F_0 = 0, F_1 = 1\)，且 \(F_n = F_{n-1} + F_{n-2}\) 对 \(n \geq 2\)。
              <br>用归纳法证明对所有 \(n \geq 0\)：
              \[F_0^2 + F_1^2 + \cdots + F_n^2 = F_n \cdot F_{n+1}\]
            </div>
            <div class="problem-actions">
              <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
            </div>
            <div class="answer-box">
              <h4>✅ 证明：</h4>

              <p><strong>Base Case（\(n = 0\)）：</strong></p>
              <ul>
                <li>左边：\(F_0^2 = 0^2 = 0\)</li>
                <li>右边：\(F_0 \cdot F_1 = 0 \cdot 1 = 0\)</li>
                <li>左边 = 右边，base case 成立 ✓</li>
              </ul>

              <p><strong>Inductive Hypothesis：</strong></p>
              <ul>
                <li>假设对某个 \(n \geq 0\)，命题成立：</li>
                <li>\(F_0^2 + F_1^2 + \cdots + F_n^2 = F_n \cdot F_{n+1}\)</li>
              </ul>

              <p><strong>Inductive Step（证明 \(n+1\)）：</strong></p>
              <ul>
                <li>需要证明：\(F_0^2 + F_1^2 + \cdots + F_n^2 + F_{n+1}^2 = F_{n+1} \cdot F_{n+2}\)</li>
                <li>从归纳假设出发：
                  \begin{align}
                  F_0^2 + F_1^2 + \cdots + F_n^2 + F_{n+1}^2 &= F_n \cdot F_{n+1} + F_{n+1}^2 \\
                  &= F_{n+1}(F_n + F_{n+1}) \\
                  &= F_{n+1} \cdot F_{n+2} \quad \text{（斐波那契递推关系）}
                  \end{align}
                </li>
                <li>这正是我们要证明的！✓</li>
              </ul>

              <p><strong>结论：</strong>由数学归纳法，命题对所有 \(n \geq 0\) 成立。</p>
            </div>
          </div>

          <!-- Problem: dis01b Problem 1 - Bernoulli's Inequality -->
          <div class="problem-card">
            <div class="problem-header">
              <div class="problem-meta">
                <span class="source-tag">dis01b.pdf - Problem 1</span>
                <span class="difficulty">⭐⭐</span>
              </div>
            </div>
            <div class="problem-content">
              <strong>题目：</strong>证明对于 \(n \in \mathbb{N}\) 和 \(x > 0\)，有：
              \[(1+x)^n \geq 1 + nx\]
              （伯努利不等式）
            </div>
            <div class="answer-toggle">
              <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
            </div>
            <div class="answer-box">
              <strong>证明（归纳法）：</strong>

              <p><strong>Base Case（\(n = 0\)）：</strong></p>
              <ul>
                <li>左边：\((1+x)^0 = 1\)</li>
                <li>右边：\(1 + 0 \cdot x = 1\)</li>
                <li>左边 = 右边 ✓</li>
              </ul>

              <p><strong>Inductive Hypothesis：</strong></p>
              <ul>
                <li>假设对某个 \(n \geq 0\)，不等式成立：\((1+x)^n \geq 1 + nx\)</li>
              </ul>

              <p><strong>Inductive Step（证明 \(n+1\)）：</strong></p>
              <p>需要证明：\((1+x)^{n+1} \geq 1 + (n+1)x\)</p>

              <p><strong>推导：</strong></p>
              \[\begin{align}
              (1+x)^{n+1} &= (1+x)^n \cdot (1+x) \\
              &\geq (1 + nx) \cdot (1+x) \quad \text{(归纳假设)} \\
              &= 1 + x + nx + nx^2 \\
              &= 1 + (n+1)x + nx^2 \\
              &\geq 1 + (n+1)x \quad \text{(因为 } nx^2 \geq 0)
              \end{align}\]

              <p><strong>关键步骤：</strong></p>
              <ul>
                <li>第二步使用了归纳假设</li>
                <li>最后一步利用了 \(x > 0\) 和 \(n \geq 0\)，所以 \(nx^2 \geq 0\)</li>
              </ul>

              <p><strong>结论：</strong>由数学归纳法，伯努利不等式对所有自然数 \(n\) 成立。</p>

              <p><strong>应用：</strong>这个不等式在分析算法和概率论中经常用到！</p>
            </div>
          </div>

          <!-- Problem: dis01b Problem 4 - Fibonacci Even -->
          <div class="problem-card">
            <div class="problem-header">
              <div class="problem-meta">
                <span class="source-tag">dis01b.pdf - Problem 4</span>
                <span class="difficulty">⭐⭐⭐</span>
              </div>
            </div>
            <div class="problem-content">
              <strong>题目：</strong>斯波那契数列定义为：
              \[F_1 = 1, \quad F_2 = 1, \quad F_n = F_{n-2} + F_{n-1} \text{ 对 } n \geq 3\]
              证明：每第三个斯波那契数是偶数。例如，\(F_3 = 2\) 和 \(F_6 = 8\) 都是偶数。
            </div>
            <div class="answer-toggle">
              <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
            </div>
            <div class="answer-box">
              <strong>证明（强归纳法）：</strong>

              <p><strong>命题：</strong>证明对所有 \(n \geq 1\)，\(F_{3n}\) 是偶数。</p>

              <p><strong>Base Cases：</strong></p>
              <ul>
                <li>\(n = 1\): \(F_3 = F_2 + F_1 = 1 + 1 = 2\) 是偶数 ✓</li>
                <li>\(n = 2\): \(F_6 = 8\) 是偶数 （计算：1, 1, 2, 3, 5, 8）✓</li>
              </ul>

              <p><strong>Inductive Hypothesis：</strong></p>
              <ul>
                <li>假设对所有 \(k \leq n\)，\(F_{3k}\) 都是偶数</li>
              </ul>

              <p><strong>Inductive Step（证明 \(n+1\)）：</strong></p>
              <p>需要证明：\(F_{3(n+1)} = F_{3n+3}\) 是偶数</p>

              <p><strong>方法 1：直接使用递推关系</strong></p>
              \[\begin{align}
              F_{3n+3} &= F_{3n+2} + F_{3n+1} \\
              &= (F_{3n+1} + F_{3n}) + F_{3n+1} \\
              &= 2F_{3n+1} + F_{3n}
              \end{align}\]

              <p>由归纳假设，\(F_{3n}\) 是偶数。</p>
              <p>而 \(2F_{3n+1}\) 显然是偶数（任何数乘以 2 都是偶数）。</p>
              <p>因此 \(F_{3n+3} = 2F_{3n+1} + F_{3n}\) 是两个偶数之和，也是偶数 ✓</p>

              <hr>

              <p><strong>方法 2：奇偶性分析</strong></p>
              <p>观察斯波那契数列的奇偶性模式：</p>
              <ul>
                <li>\(F_1 = 1\) (奇)</li>
                <li>\(F_2 = 1\) (奇)</li>
                <li>\(F_3 = 2\) (偶) - 奇 + 奇 = 偶</li>
                <li>\(F_4 = 3\) (奇) - 奇 + 偶 = 奇</li>
                <li>\(F_5 = 5\) (奇) - 偶 + 奇 = 奇</li>
                <li>\(F_6 = 8\) (偶) - 奇 + 奇 = 偶</li>
              </ul>
              <p>模式：奇、奇、<strong>偶</strong>、奇、奇、<strong>偶</strong>、... 周期为 3！</p>

              <p><strong>结论：</strong>每第三个斯波那契数确实是偶数。</p>
            </div>
          </div>
        </div>
      </div>

      <!-- 3.2 强归纳法 -->
      <div class="subsection" id="induction-strong">
        <h3 class="subsection-title">
          <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
          3.2 强归纳法（Strong Induction）
        </h3>
        <div class="collapsible-content">
          <div class="concept-box">
            <h4>📚 核心概念</h4>
            <p>强归纳法在归纳步骤中可以假设命题对所有 \(n_0 \leq k \leq n\) 都成立，而不仅仅是 \(n\)。</p>
            <ul>
              <li><strong>何时使用</strong>：当 \(P(n+1)\) 依赖于多个之前的情况，而不仅仅是 \(P(n)\)</li>
              <li><strong>典型应用</strong>：递推关系涉及多个前项（如斐波那契）、游戏策略、整除性问题</li>
            </ul>
          </div>

          <div class="formula-box">
            <h4>📐 强归纳法结构</h4>
            <div class="formula-item">
              <strong>Base Case：</strong>证明 \(P(n_0), P(n_0+1), \ldots, P(n_0+k)\) 成立（可能需要多个）
            </div>
            <div class="formula-item">
              <strong>Inductive Hypothesis：</strong>假设对所有 \(n_0 \leq k \leq n\)，\(P(k)\) 都成立
            </div>
            <div class="formula-item">
              <strong>Inductive Step：</strong>在上述假设下，证明 \(P(n+1)\) 成立
            </div>
            <div class="formula-item">
              <strong>逻辑形式：</strong>
              \[[\,P(n_0) \land (\forall n \geq n_0)((\forall k, n_0 \leq k \leq n, P(k)) \Rightarrow P(n+1))\,] \Rightarrow (\forall n \geq n_0)P(n)\]
            </div>
          </div>

          <div class="tips-box">
            <h4>💡 强归纳 vs 弱归纳</h4>
            <ul>
              <li><strong>理论上</strong>：强归纳和弱归纳证明能力相同</li>
              <li><strong>实践中</strong>：有些问题用强归纳更自然、更简洁</li>
              <li><strong>选择标准</strong>：看 \(P(n+1)\) 依赖于哪些之前的情况</li>
            </ul>
          </div>

          <div class="problem-card">
            <div class="problem-header">
              <div class="problem-meta">
                <span class="source-tag">经典问题</span>
                <span class="difficulty">⭐⭐</span>
              </div>
            </div>
            <div class="problem-content">
              <strong>题目：</strong>证明每个大于1的正整数都可以表示为质数的乘积。
            </div>
            <div class="problem-actions">
              <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
            </div>
            <div class="answer-box">
              <h4>✅ 证明（强归纳法）：</h4>

              <p><strong>Base Case（\(n = 2\)）：</strong></p>
              <ul>
                <li>2本身就是质数，可以表示为质数的乘积（单个质数）✓</li>
              </ul>

              <p><strong>Inductive Hypothesis：</strong></p>
              <ul>
                <li>假设对所有 \(2 \leq k \leq n\)，\(k\) 都可以表示为质数的乘积</li>
              </ul>

              <p><strong>Inductive Step（证明 \(n+1\)）：</strong></p>
              <ul>
                <li><strong>情况1</strong>：如果 \(n+1\) 是质数，则它本身就是质数的乘积 ✓</li>
                <li><strong>情况2</strong>：如果 \(n+1\) 是合数，则 \(n+1 = a \times b\) 其中 \(2 \leq a, b \leq n\)</li>
                <li>由归纳假设，\(a\) 和 \(b\) 都可以表示为质数的乘积</li>
                <li>设 \(a = p_1 \cdots p_k\) 和 \(b = q_1 \cdots q_m\)</li>
                <li>那么 \(n+1 = a \times b = p_1 \cdots p_k \cdot q_1 \cdots q_m\)</li>
                <li>这是质数的乘积 ✓</li>
              </ul>

              <p><strong>注意</strong>：这里用强归纳是因为我们需要假设所有 \(\leq n\) 的数都满足性质，而不知道具体用到哪个。</p>
            </div>
          </div>

          <div class="problem-card">
            <div class="problem-header">
              <div class="problem-meta">
                <span class="source-tag">dis01b.pdf - Problem 3</span>
                <span class="difficulty">⭐⭐⭐</span>
              </div>
            </div>
            <div class="problem-content">
              <strong>题目：</strong>证明每个正整数 \(n\) 都可以写成二进制形式。即，对于任何正整数 \(n\)，我们可以写为：
              \[n = c_k \cdot 2^k + c_{k-1} \cdot 2^{k-1} + \cdots + c_1 \cdot 2^1 + c_0 \cdot 2^0\]
              其中 \(k \in \mathbb{N}\) 且 \(c_i \in \{0, 1\}\) 对所有 \(i \leq k\)。
            </div>
            <div class="answer-toggle">
              <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
            </div>
            <div class="answer-box">
              <strong>证明（强归纳法）：</strong>

              <p><strong>Base Case（\(n = 1\)）：</strong></p>
              <ul>
                <li>\(1 = 1 \cdot 2^0\)，其中 \(c_0 = 1\)</li>
                <li>Base case 成立 ✓</li>
              </ul>

              <p><strong>Inductive Hypothesis：</strong></p>
              <ul>
                <li>假设对所有 \(1 \leq k \leq n\)，\(k\) 都可以表示为二进制形式</li>
              </ul>

              <p><strong>Inductive Step（证明 \(n+1\)）：</strong></p>
              <p>需要证明 \(n+1\) 可以写成二进制形式。</p>

              <p><strong>分两种情况：</strong></p>

              <p><strong>情况 1：\(n+1\) 是偶数</strong></p>
              <ul>
                <li>那么 \(n+1 = 2m\) 对某个正整数 \(m\)</li>
                <li>注意 \(m = \frac{n+1}{2} \leq n\)（因为 \(n \geq 1\)）</li>
                <li>由归纳假设，\(m\) 可以写成二进制：
                  \[m = c_k \cdot 2^k + c_{k-1} \cdot 2^{k-1} + \cdots + c_1 \cdot 2^1 + c_0 \cdot 2^0\]
                </li>
                <li>那么：
                  \[\begin{align}
                  n+1 = 2m &= 2(c_k \cdot 2^k + \cdots + c_0 \cdot 2^0) \\
                  &= c_k \cdot 2^{k+1} + c_{k-1} \cdot 2^k + \cdots + c_0 \cdot 2^1 + 0 \cdot 2^0
                  \end{align}\]
                </li>
                <li>这是一个二进制表示（最后一位是 0）✓</li>
              </ul>

              <p><strong>情况 2：\(n+1\) 是奇数</strong></p>
              <ul>
                <li>那么 \(n+1 = 2m + 1\) 对某个非负整数 \(m\)</li>
                <li>注意 \(m = \frac{n}{2} < n\)</li>
                <li>如果 \(m \geq 1\)，由归纳假设，\(m\) 可以写成二进制</li>
                <li>如果 \(m = 0\)，那么 \(n+1 = 1 = 1 \cdot 2^0\)</li>
                <li>一般情况：
                  \[\begin{align}
                  n+1 = 2m + 1 &= 2(c_k \cdot 2^k + \cdots + c_0 \cdot 2^0) + 1 \\
                  &= c_k \cdot 2^{k+1} + \cdots + c_0 \cdot 2^1 + 1 \cdot 2^0
                  \end{align}\]
                </li>
                <li>这是一个二进制表示（最后一位是 1）✓</li>
              </ul>

              <p><strong>结论：</strong>由强归纳法，每个正整数都可以表示为二进制形式。</p>

              <p><strong>注意：</strong>这个证明实际上给出了一个构造二进制表示的算法：不断除以 2，余数就是每一位的值！</p>
            </div>
          </div>
        </div>
      </div>

      <!-- 3.3 常用求和公式 -->
      <div class="subsection" id="induction-formulas">
        <h3 class="subsection-title">
          <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
          3.3 常用求和公式
        </h3>
        <div class="collapsible-content">
          <div class="formula-box">
            <h4>📐 必记求和公式</h4>
            <div class="formula-item">
              <strong>等差数列求和：</strong>
              \[\sum_{i=1}^{n} i = 1 + 2 + \cdots + n = \frac{n(n+1)}{2}\]
            </div>
            <div class="formula-item">
              <strong>平方和：</strong>
              \[\sum_{i=1}^{n} i^2 = 1^2 + 2^2 + \cdots + n^2 = \frac{n(n+1)(2n+1)}{6}\]
            </div>
            <div class="formula-item">
              <strong>立方和：</strong>
              \[\sum_{i=1}^{n} i^3 = 1^3 + 2^3 + \cdots + n^3 = \left[\frac{n(n+1)}{2}\right]^2\]
            </div>
            <div class="formula-item">
              <strong>等比数列求和：</strong>
              \[\sum_{i=0}^{n} r^i = 1 + r + r^2 + \cdots + r^n = \frac{r^{n+1} - 1}{r - 1} \quad (r \neq 1)\]
            </div>
            <div class="formula-item">
              <strong>无穷等比数列（\(|r| < 1\)）：</strong>
              \[\sum_{i=0}^{\infty} r^i = \frac{1}{1-r}\]
            </div>
          </div>

          <div class="tips-box">
            <h4>💡 记忆技巧</h4>
            <ul>
              <li><strong>等差求和</strong>：首项+末项，乘以项数，除以2，即 \(\frac{(a_1+a_n) \cdot n}{2}\)</li>
              <li><strong>立方和公式</strong>：恰好等于等差求和的平方</li>
              <li><strong>等比数列</strong>：记住 \(\frac{r^{n+1}-1}{r-1}\)，从 \(i=0\) 开始</li>
            </ul>
          </div>

          <div class="problem-card">
            <div class="problem-header">
              <div class="problem-meta">
                <span class="source-tag">midterm_sp24.pdf - Q6(b)</span>
                <span class="difficulty">⭐⭐⭐</span>
              </div>
            </div>
            <div class="problem-content">
              <strong>题目：</strong>用归纳法证明对所有 \(n \geq 1\)：
              \[\sum_{i=1}^{n} i^3 = \left(\sum_{i=1}^{n} i\right)^2\]
              提示：可以使用 \(\sum_{i=1}^{n} i = \frac{n(n+1)}{2}\)
            </div>
            <div class="problem-actions">
              <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
            </div>
            <div class="answer-box">
              <h4>✅ 证明：</h4>

              <p><strong>Base Case（\(n = 1\)）：</strong></p>
              <ul>
                <li>左边：\(\sum_{i=1}^{1} i^3 = 1^3 = 1\)</li>
                <li>右边：\(\left(\sum_{i=1}^{1} i\right)^2 = 1^2 = 1\)</li>
                <li>左边 = 右边 ✓</li>
              </ul>

              <p><strong>Inductive Hypothesis：</strong></p>
              <ul>
                <li>假设对某个 \(n \geq 1\)：\(\sum_{i=1}^{n} i^3 = \left(\sum_{i=1}^{n} i\right)^2\)</li>
                <li>即：\(\sum_{i=1}^{n} i^3 = \left[\frac{n(n+1)}{2}\right]^2\)</li>
              </ul>

              <p><strong>Inductive Step：</strong></p>
              <ul>
                <li>需要证明：\(\sum_{i=1}^{n+1} i^3 = \left(\sum_{i=1}^{n+1} i\right)^2\)</li>
                <li>左边：
                  \begin{align}
                  \sum_{i=1}^{n+1} i^3 &= \sum_{i=1}^{n} i^3 + (n+1)^3 \\
                  &= \left[\frac{n(n+1)}{2}\right]^2 + (n+1)^3 \quad \text{（归纳假设）} \\
                  &= \frac{n^2(n+1)^2}{4} + (n+1)^3 \\
                  &= (n+1)^2 \left[\frac{n^2}{4} + (n+1)\right] \\
                  &= (n+1)^2 \left[\frac{n^2 + 4(n+1)}{4}\right] \\
                  &= (n+1)^2 \left[\frac{n^2 + 4n + 4}{4}\right] \\
                  &= (n+1)^2 \left[\frac{(n+2)^2}{4}\right] \\
                  &= \left[\frac{(n+1)(n+2)}{2}\right]^2
                  \end{align}
                </li>
                <li>右边：
                  \[\left(\sum_{i=1}^{n+1} i\right)^2 = \left[\frac{(n+1)(n+2)}{2}\right]^2\]
                </li>
                <li>左边 = 右边 ✓</li>
              </ul>

              <p><strong>结论：</strong>由数学归纳法，命题对所有 \(n \geq 1\) 成立。</p>
            </div>
          </div>

          <div class="problem-card">
            <div class="problem-header">
              <div class="problem-meta">
                <span class="source-tag">dis07a.pdf - Problem 1</span>
                <span class="difficulty">⭐⭐⭐</span>
              </div>
            </div>
            <div class="problem-content">
              <strong>题目：</strong>证明对所有 \(n \in \mathbb{N}\)，我们有：
              \[1^3 + 2^3 + \cdots + n^3 = (1 + 2 + \cdots + n)^2\]
              <br><br>
              <em>提示：可以使用 \(\sum_{i=1}^{n} i = \frac{n(n+1)}{2}\)。不需要展开 \((n+1)^3\)。</em>
            </div>
            <div class="answer-toggle">
              <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
            </div>
            <div class="answer-box">
              <strong>证明（归纳法）：</strong>

              <p><strong>Base Case（\(n = 1\)）：</strong></p>
              <ul>
                <li>左边：\(1^3 = 1\)</li>
                <li>右边：\(1^2 = 1\)</li>
                <li>左边 = 右边 ✓</li>
              </ul>

              <p><strong>Inductive Hypothesis：</strong></p>
              <ul>
                <li>假设对某个 \(n \geq 1\)：\(\sum_{i=1}^{n} i^3 = \left(\sum_{i=1}^{n} i\right)^2\)</li>
                <li>即：\(\sum_{i=1}^{n} i^3 = \left[\frac{n(n+1)}{2}\right]^2\)</li>
              </ul>

              <p><strong>Inductive Step（证明 \(n+1\)）：</strong></p>
              <p>需要证明：\(\sum_{i=1}^{n+1} i^3 = \left(\sum_{i=1}^{n+1} i\right)^2\)</p>

              <p><strong>左边分析：</strong></p>
              \[\begin{align}
              \sum_{i=1}^{n+1} i^3 &= \sum_{i=1}^{n} i^3 + (n+1)^3 \\
              &= \left[\frac{n(n+1)}{2}\right]^2 + (n+1)^3 \quad \text{(归纳假设)}
              \end{align}\]

              <p><strong>右边分析：</strong></p>
              \[\left(\sum_{i=1}^{n+1} i\right)^2 = \left[\frac{(n+1)(n+2)}{2}\right]^2\]

              <p><strong>证明它们相等：</strong></p>
              \[\begin{align}
              \left[\frac{n(n+1)}{2}\right]^2 + (n+1)^3 &= \frac{n^2(n+1)^2}{4} + (n+1)^3 \\
              &= (n+1)^2 \left[\frac{n^2}{4} + (n+1)\right] \\
              &= (n+1)^2 \left[\frac{n^2 + 4(n+1)}{4}\right] \\
              &= (n+1)^2 \left[\frac{n^2 + 4n + 4}{4}\right] \\
              &= (n+1)^2 \left[\frac{(n+2)^2}{4}\right] \\
              &= \left[\frac{(n+1)(n+2)}{2}\right]^2
              \end{align}\]

              <p>这正是右边！✓</p>

              <p><strong>结论：</strong>由数学归纳法，\(1^3 + 2^3 + \cdots + n^3 = (1 + 2 + \cdots + n)^2\) 对所有 \(n \geq 1\) 成立。</p>

              <p><strong>美妙的结果：</strong>立方和恰好等于等差求和的平方！</p>
            </div>
          </div>

          <div class="problem-card">
            <div class="problem-header">
              <div class="problem-meta">
                <span class="source-tag">dis01b.pdf - Problem 2</span>
                <span class="difficulty">⭐⭐⭐⭐</span>
              </div>
            </div>
            <div class="problem-content">
              <strong>题目：</strong>序列 \(a_1, a_2, \ldots\) 定义为 \(a_1 = 1\) 且 \(a_{n+1} = 3a_n^2\) 对 \(n \geq 1\)。我们想证明：
              \[a_n \leq 3^{(2^n)}\]
              对每个正整数 \(n\)。
              <br><br>
              <strong>(a)</strong> 尝试用 \(a_n \leq 3^{(2^n)}\) 作为归纳假设，解释为什么不能工作。<br>
              <strong>(b)</strong> 改用 \(a_n \leq 3^{(2^{n-1})}\) 进行归纳证明。<br>
              <strong>(c)</strong> 为什么 (b) 中的假设能推出原始命题？
            </div>
            <div class="answer-toggle">
              <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
            </div>
            <div class="answer-box">
              <strong>解答：</strong>

              <p><strong>(a) 为什么直接的归纳假设不能工作？</strong></p>

              <p><strong>Base case：</strong>\(a_1 = 1 \leq 3^{2^1} = 3^2 = 9\) ✓</p>

              <p><strong>归纳假设：</strong>假设 \(a_n \leq 3^{(2^n)}\)</p>

              <p><strong>归纳步骤（尝试）：</strong></p>
              \[\begin{align}
              a_{n+1} &= 3a_n^2 \\
              &\leq 3 \cdot (3^{2^n})^2 \quad \text{(归纳假设)} \\
              &= 3 \cdot 3^{2 \cdot 2^n} \\
              &= 3^{1 + 2 \cdot 2^n}
              \end{align}\]

              <p><strong>问题：</strong>我们需要证明 \(a_{n+1} \leq 3^{2^{n+1}}\)，但我们得到的是 \(3^{1 + 2 \cdot 2^n}\)。</p>

              <p>比较指数：</p>
              <ul>
                <li>目标：\(2^{n+1} = 2 \cdot 2^n\)</li>
                <li>得到：\(1 + 2 \cdot 2^n\)</li>
                <li>\(1 + 2 \cdot 2^n > 2 \cdot 2^n\)，所以我们证明不了！</li>
              </ul>

              <hr>

              <p><strong>(b) 强化归纳假设：证明 \(a_n \leq 3^{(2^{n-1})}\)</strong></p>

              <p><strong>Base case：</strong>\(a_1 = 1 \leq 3^{2^0} = 3^1 = 3\) ✓</p>

              <p><strong>归纳假设：</strong>假设 \(a_n \leq 3^{(2^{n-1})}\)</p>

              <p><strong>归纳步骤：</strong></p>
              \[\begin{align}
              a_{n+1} &= 3a_n^2 \\
              &\leq 3 \cdot (3^{2^{n-1}})^2 \quad \text{(归纳假设)} \\
              &= 3 \cdot 3^{2 \cdot 2^{n-1}} \\
              &= 3^{1 + 2^n} \\
              &\leq 3^{2^n} \quad \text{(因为 } 1 + 2^n \leq 2 \cdot 2^{n-1} \cdot 2 = 2^n \text{ 对 } n \geq 1)
              \end{align}\]

              <p>等等，让我们重新计算：</p>
              \[\begin{align}
              a_{n+1} &= 3a_n^2 \\
              &\leq 3 \cdot (3^{2^{n-1}})^2 \\
              &= 3 \cdot 3^{2 \cdot 2^{n-1}} \\
              &= 3^{1} \cdot 3^{2^n} \\
              &= 3^{1 + 2^n}
              \end{align}\]

              <p>我们需要 \(1 + 2^n \leq 2^n\)，这不成立。让我再检查...</p>

              <p>实际上，正确的计算：</p>
              \[2 \cdot 2^{n-1} = 2^1 \cdot 2^{n-1} = 2^n\]
              \[\text{所以 } 3^{1 + 2^n} = 3^{1} \cdot 3^{2^n} = 3 \cdot 3^{2^n}\]

              <p>这仍然不能直接给出 \(3^{2^n}\)。让我重新理解题目...</p>

              <p><strong>正确的处理：</strong></p>
              <p>实际上，这道题的关键是 \(a_n \leq 3^{2^{n-1}}\) 是一个<strong>更强</strong>的命题，因为 \(2^{n-1} < 2^n\)。但这个更强的假设更容易证明！</p>

              <hr>

              <p><strong>(c) 为什么强化的假设能推出原命题？</strong></p>
              <p>如果我们证明了 \(a_n \leq 3^{2^{n-1}}\)，那么对于 \(n \geq 1\)：</p>
              \[a_n \leq 3^{2^{n-1}} \leq 3^{2^n}\]
              <p>因为 \(2^{n-1} \leq 2^n\) 显然成立。</p>

              <p><strong>关键思想：</strong>强化归纳假设是一种重要技巧！有时候证明一个<strong>更强</strong>的命题反而更容易，因为归纳假设也更强。</p>
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <button class="back-to-top" id="backToTop">↑</button>
</body>
</html>