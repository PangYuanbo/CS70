<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS 70 综合学习指南 - 按知识点分类</title>

    <!-- MathJax Configuration -->
    <script>
    MathJax = {
        tex: {
            inlineMath: [['\\(', '\\)'], ['$', '$']],
            displayMath: [['\\[', '\\]'], ['$$', '$$']],
            processEscapes: true,
            processEnvironments: true
        },
        options: {
            skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        }
    };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>

    <style>
        :root {
            --primary-color: #2563eb;
            --secondary-color: #7c3aed;
            --bg-color: #ffffff;
            --text-color: #1f2937;
            --border-color: #e5e7eb;
            --hover-bg: #f3f4f6;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --danger-color: #ef4444;
            --sidebar-width: 280px;
            --header-height: 60px;
        }

        [data-theme="dark"] {
            --bg-color: #1f2937;
            --text-color: #f3f4f6;
            --border-color: #374151;
            --hover-bg: #374151;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            transition: background-color 0.3s, color 0.3s;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--header-height);
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            display: flex;
            align-items: center;
            padding: 0 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 700;
        }

        .header-controls {
            margin-left: auto;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .search-box {
            padding: 8px 15px;
            border: none;
            border-radius: 20px;
            background: rgba(255,255,255,0.2);
            color: white;
            outline: none;
            width: 250px;
        }

        .search-box::placeholder {
            color: rgba(255,255,255,0.7);
        }

        .theme-toggle {
            background: rgba(255,255,255,0.2);
            border: none;
            padding: 8px 15px;
            border-radius: 20px;
            color: white;
            cursor: pointer;
            font-size: 1rem;
            transition: background 0.3s;
        }

        .theme-toggle:hover {
            background: rgba(255,255,255,0.3);
        }

        /* Sidebar */
        .sidebar {
            position: fixed;
            top: var(--header-height);
            left: 0;
            width: var(--sidebar-width);
            height: calc(100vh - var(--header-height));
            background: var(--bg-color);
            border-right: 1px solid var(--border-color);
            overflow-y: auto;
            padding: 20px;
            transition: transform 0.3s;
            z-index: 100;
        }

        .sidebar-toggle {
            display: none;
            position: fixed;
            top: calc(var(--header-height) + 10px);
            left: 10px;
            z-index: 101;
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
        }

        .nav-item {
            padding: 10px;
            margin-bottom: 5px;
            cursor: pointer;
            border-radius: 5px;
            transition: background 0.3s;
            font-weight: 600;
        }

        .nav-item:hover {
            background: var(--hover-bg);
        }

        .nav-subitem {
            padding: 8px 10px 8px 25px;
            margin-bottom: 3px;
            cursor: pointer;
            border-radius: 5px;
            font-size: 0.9rem;
            transition: background 0.3s;
        }

        .nav-subitem:hover {
            background: var(--hover-bg);
            color: var(--primary-color);
        }

        /* Main Content */
        .main-content {
            margin-left: var(--sidebar-width);
            margin-top: var(--header-height);
            padding: 40px;
            max-width: 1200px;
        }

        .section {
            margin-bottom: 60px;
        }

        .section-title {
            font-size: 2rem;
            color: var(--primary-color);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid var(--primary-color);
        }

        .subsection {
            margin-bottom: 40px;
        }

        .subsection-title {
            font-size: 1.5rem;
            color: var(--secondary-color);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .toggle-btn {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            color: var(--secondary-color);
            transition: transform 0.3s;
        }

        .toggle-btn.open {
            transform: rotate(90deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .collapsible-content.open {
            max-height: 5000px;
        }

        .concept-box, .formula-box, .tips-box {
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 10px;
            border-left: 4px solid;
        }

        .concept-box {
            background: #eff6ff;
            border-color: var(--primary-color);
        }

        .formula-box {
            background: #f5f3ff;
            border-color: var(--secondary-color);
        }

        .tips-box {
            background: #fef3c7;
            border-color: var(--warning-color);
        }

        [data-theme="dark"] .concept-box {
            background: #1e3a5f;
        }

        [data-theme="dark"] .formula-box {
            background: #2e1f47;
        }

        [data-theme="dark"] .tips-box {
            background: #4a3a1a;
        }

        .formula-item {
            padding: 15px;
            margin: 10px 0;
            background: rgba(255,255,255,0.5);
            border-radius: 5px;
            font-size: 1.1rem;
        }

        [data-theme="dark"] .formula-item {
            background: rgba(255,255,255,0.05);
        }

        .problem-card {
            padding: 25px;
            margin: 20px 0;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            background: var(--bg-color);
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        .problem-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .problem-meta {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .source-tag {
            display: inline-block;
            padding: 5px 12px;
            background: var(--primary-color);
            color: white;
            border-radius: 15px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .difficulty {
            color: var(--warning-color);
            font-size: 1.1rem;
        }

        .problem-content {
            margin: 20px 0;
            line-height: 1.8;
        }

        .problem-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .btn {
            padding: 8px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .btn-primary {
            background: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background: #1d4ed8;
        }

        .btn-secondary {
            background: var(--border-color);
            color: var(--text-color);
        }

        .btn-secondary:hover {
            background: #d1d5db;
        }

        .answer-box {
            margin-top: 15px;
            padding: 20px;
            background: #f0fdf4;
            border-left: 4px solid var(--success-color);
            border-radius: 5px;
            display: none;
        }

        .answer-box.show {
            display: block;
        }

        [data-theme="dark"] .answer-box {
            background: #1a3a2e;
        }

        .back-to-top {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            transition: all 0.3s;
            z-index: 100;
        }

        .back-to-top:hover {
            background: #1d4ed8;
            transform: translateY(-5px);
        }

        .back-to-top.show {
            display: flex;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-100%);
            }

            .sidebar.show {
                transform: translateX(0);
            }

            .sidebar-toggle {
                display: block;
            }

            .main-content {
                margin-left: 0;
                padding: 20px;
            }

            .search-box {
                width: 150px;
            }
        }

        @media print {
            .header, .sidebar, .problem-actions, .back-to-top {
                display: none !important;
            }

            .main-content {
                margin: 0;
                padding: 20px;
            }

            .answer-box {
                display: block !important;
            }
        }
        /* Google Translate (hide default UI) */
        #google_translate_element { display: none; }
        .goog-te-banner-frame.skiptranslate, .goog-te-gadget-icon { display: none !important; }
        body { top: 0 !important; }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <h1>📚 CS 70 综合学习指南</h1>
        <div class="header-controls">
            <input type="text" class="search-box" placeholder="搜索知识点或题目..." id="searchBox">
            <button class="theme-toggle" id="themeToggle">🌙 深色模式</button>
            <div class="lang-toggle" id="langToggle">
                <button type="button" class="theme-toggle" data-lang="zh-CN">中文</button>
                <button type="button" class="theme-toggle" data-lang="en">English</button>
            </div>
        </div>
    </div>

    <!-- Sidebar Toggle Button -->
    <button class="sidebar-toggle" id="sidebarToggle">☰</button>

    <!-- Sidebar -->
    <nav class="sidebar" id="sidebar">
        <div class="nav-item" onclick="scrollToSection('logic')">1. Propositional Logic</div>
        <div class="nav-subitem" onclick="scrollToSection('logic-operators')">1.1 基本逻辑运算符</div>
        <div class="nav-subitem" onclick="scrollToSection('logic-equivalence')">1.2 逻辑等价</div>
        <div class="nav-subitem" onclick="scrollToSection('logic-quantifiers')">1.3 量词</div>

        <div class="nav-item" onclick="scrollToSection('proofs')">2. Proof Techniques</div>
        <div class="nav-subitem" onclick="scrollToSection('proof-direct')">2.1 直接证明</div>
        <div class="nav-subitem" onclick="scrollToSection('proof-contradiction')">2.2 反证法</div>
        <div class="nav-subitem" onclick="scrollToSection('proof-contrapositive')">2.3 逆否命题</div>
        <div class="nav-subitem" onclick="scrollToSection('proof-pigeonhole')">2.4 鸽笼原理</div>

        <div class="nav-item" onclick="scrollToSection('induction')">3. Induction</div>
        <div class="nav-subitem" onclick="scrollToSection('induction-weak')">3.1 弱归纳法</div>
        <div class="nav-subitem" onclick="scrollToSection('induction-strong')">3.2 强归纳法</div>
        <div class="nav-subitem" onclick="scrollToSection('induction-formulas')">3.3 常用求和公式</div>

        <div class="nav-item" onclick="scrollToSection('matching')">4. Stable Matching</div>
        <div class="nav-subitem" onclick="scrollToSection('matching-algorithm')">4.1 Propose-and-Reject算法</div>
        <div class="nav-subitem" onclick="scrollToSection('matching-improvement')">4.2 改进引理</div>
        <div class="nav-subitem" onclick="scrollToSection('matching-optimal')">4.3 最优性定理</div>

        <div class="nav-item" onclick="scrollToSection('graphs')">5. Graph Theory</div>
        <div class="nav-subitem" onclick="scrollToSection('graphs-basic')">5.1 基本定义</div>
        <div class="nav-subitem" onclick="scrollToSection('graphs-trees')">5.2 树</div>
        <div class="nav-subitem" onclick="scrollToSection('graphs-euler')">5.3 欧拉回路</div>
        <div class="nav-subitem" onclick="scrollToSection('graphs-planar')">5.4 平面图</div>
        <div class="nav-subitem" onclick="scrollToSection('graphs-coloring')">5.5 图染色</div>
        <div class="nav-subitem" onclick="scrollToSection('graphs-hypercube')">5.6 超立方体</div>

        <div class="nav-item" onclick="scrollToSection('modular')">6. Modular Arithmetic</div>
        <div class="nav-subitem" onclick="scrollToSection('modular-basic')">6.1 基本运算</div>
        <div class="nav-subitem" onclick="scrollToSection('modular-gcd')">6.2 GCD和扩展欧几里得</div>
        <div class="nav-subitem" onclick="scrollToSection('modular-fermat')">6.3 费马小定理</div>
        <div class="nav-subitem" onclick="scrollToSection('modular-crt')">6.4 中国剩余定理</div>
        <div class="nav-subitem" onclick="scrollToSection('modular-rsa')">6.5 RSA加密</div>

        <div class="nav-item" onclick="scrollToSection('polynomials')">7. Polynomials</div>
        <div class="nav-subitem" onclick="scrollToSection('poly-basic')">7.1 有限域基础</div>
        <div class="nav-subitem" onclick="scrollToSection('poly-lagrange')">7.2 拉格朗日插值</div>
        <div class="nav-subitem" onclick="scrollToSection('poly-secret')">7.3 秘密共享</div>
        <div class="nav-subitem" onclick="scrollToSection('poly-ecc')">7.4 纠错码</div>

        <div class="nav-item" onclick="scrollToSection('counting')">8. Counting</div>
        <div class="nav-subitem" onclick="scrollToSection('counting-basic')">8.1 基本计数原理</div>
        <div class="nav-subitem" onclick="scrollToSection('counting-perm')">8.2 排列</div>
        <div class="nav-subitem" onclick="scrollToSection('counting-comb')">8.3 组合</div>
        <div class="nav-subitem" onclick="scrollToSection('counting-stars')">8.4 Stars and Bars</div>
    </nav>

    <!-- Main Content -->
    <main class="main-content">
        <!-- Section 1: Propositional Logic -->
        <section class="section" id="logic">
            <h2 class="section-title">1. Propositional Logic（命题逻辑）</h2>

            <!-- 1.1 Basic Operators -->
            <div class="subsection" id="logic-operators">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    1.1 基本逻辑运算符
                </h3>
                <div class="collapsible-content">
                    <div class="concept-box">
                        <h4>📚 核心概念</h4>
                        <p>命题逻辑是研究命题（可以判断真假的陈述）之间关系的数学分支。</p>
                        <ul>
                            <li><strong>命题</strong>：可以判断真假的陈述句</li>
                            <li><strong>复合命题</strong>：由基本命题通过逻辑运算符组合而成</li>
                        </ul>
                    </div>

                    <div class="formula-box">
                        <h4>📐 重要公式</h4>
                        <div class="formula-item">
                            <strong>否定（Negation）：</strong> \(\neg P\)
                            <br>真值：\(P\) 为真时 \(\neg P\) 为假；\(P\) 为假时 \(\neg P\) 为真
                        </div>
                        <div class="formula-item">
                            <strong>合取（Conjunction）：</strong> \(P \land Q\)
                            <br>真值：仅当 \(P\) 和 \(Q\) 都为真时为真
                        </div>
                        <div class="formula-item">
                            <strong>析取（Disjunction）：</strong> \(P \lor Q\)
                            <br>真值：当 \(P\) 或 \(Q\) 至少有一个为真时为真
                        </div>
                        <div class="formula-item">
                            <strong>蕴含（Implication）：</strong> \(P \Rightarrow Q\)
                            <br>真值：仅当 \(P\) 为真且 \(Q\) 为假时为假
                            <br><em>等价形式：</em> \(\neg P \lor Q\)
                        </div>
                        <div class="formula-item">
                            <strong>双向蕴含（Biconditional）：</strong> \(P \Leftrightarrow Q\)
                            <br>真值：当 \(P\) 和 \(Q\) 真值相同时为真
                            <br><em>等价形式：</em> \((P \Rightarrow Q) \land (Q \Rightarrow P)\)
                        </div>
                    </div>

                    <div class="tips-box">
                        <h4>💡 解题技巧</h4>
                        <ul>
                            <li>记住蕴含的真值表：只有"真推假"为假，其他都为真</li>
                            <li>蕴含式的否定：\(\neg(P \Rightarrow Q) \equiv P \land \neg Q\)</li>
                            <li>使用真值表验证复杂命题的等价性</li>
                        </ul>
                    </div>

                    <!-- Problem 1 -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_fa24.pdf - Q3.1(b)</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>判断以下命题是否总是为真（tautology）：
                            \[P \lor [(P \Rightarrow Q) \land (P \Rightarrow \neg Q)]\]
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                            <button class="btn btn-secondary">标记重点</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 答案：Yes（总是为真）</h4>
                            <p><strong>解析：</strong></p>
                            <ol>
                                <li>分析括号内：\((P \Rightarrow Q) \land (P \Rightarrow \neg Q)\)</li>
                                <li>当 \(P\) 为真时：
                                    <ul>
                                        <li>\(P \Rightarrow Q\) 为真当且仅当 \(Q\) 为真</li>
                                        <li>\(P \Rightarrow \neg Q\) 为真当且仅当 \(Q\) 为假</li>
                                        <li>两者不能同时为真，所以括号内为假</li>
                                    </ul>
                                </li>
                                <li>当 \(P\) 为假时：
                                    <ul>
                                        <li>两个蕴含式都为真（假可以推出任何东西）</li>
                                        <li>括号内为真，但 \(P\) 为假</li>
                                    </ul>
                                </li>
                                <li>无论 \(P\) 真假，整个式子 \(P \lor [...]\) 总有一部分为真</li>
                                <li>因此该命题是永真式</li>
                            </ol>
                        </div>
                    </div>

                    <!-- Problem 2 -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_sp24.pdf - Q4(a)</span>
                                <span class="difficulty">⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>将以下英文翻译成逻辑表达式：<br>
                            "The robot is not in motion unless it is powered on."
                            <br><br>
                            变量定义：
                            <ul>
                                <li>\(P\): the robot is powered on</li>
                                <li>\(M\): the robot is in motion</li>
                            </ul>
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                            <button class="btn btn-secondary">标记重点</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 答案：\(M \Rightarrow P\)</h4>
                            <p><strong>解析：</strong></p>
                            <ul>
                                <li>"not in motion unless powered on" 意思是：如果在运动，那么必定powered on</li>
                                <li>"unless" 可以理解为 "if not"，但在这里更直接的理解是蕴含关系</li>
                                <li>等价表述："只有在powered on的情况下才能in motion"</li>
                                <li>逻辑形式：\(M \Rightarrow P\)</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 1.2 Logic Equivalence -->
            <div class="subsection" id="logic-equivalence">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    1.2 逻辑等价
                </h3>
                <div class="collapsible-content">
                    <div class="formula-box">
                        <h4>📐 重要公式</h4>
                        <div class="formula-item">
                            <strong>德摩根定律（De Morgan's Laws）：</strong>
                            \[\neg(P \land Q) \equiv (\neg P) \lor (\neg Q)\]
                            \[\neg(P \lor Q) \equiv (\neg P) \land (\neg Q)\]
                        </div>
                        <div class="formula-item">
                            <strong>蕴含式等价：</strong>
                            \[P \Rightarrow Q \equiv \neg P \lor Q\]
                            \[P \Rightarrow Q \equiv \neg Q \Rightarrow \neg P \text{ （逆否命题）}\]
                        </div>
                        <div class="formula-item">
                            <strong>蕴含式否定：</strong>
                            \[\neg(P \Rightarrow Q) \equiv P \land \neg Q\]
                        </div>
                        <div class="formula-item">
                            <strong>双重否定：</strong>
                            \[\neg(\neg P) \equiv P\]
                        </div>
                    </div>

                    <!-- Problem -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_fa24.pdf - Q3.1(c)</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>判断以下命题是否总是为真：
                            \[\neg(P \Rightarrow Q) \equiv (P \land \neg Q)\]
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 答案：Yes（总是为真）</h4>
                            <p><strong>解析：</strong></p>
                            <ol>
                                <li>首先，\(P \Rightarrow Q \equiv \neg P \lor Q\)</li>
                                <li>因此，\(\neg(P \Rightarrow Q) \equiv \neg(\neg P \lor Q)\)</li>
                                <li>应用德摩根定律：\(\neg(\neg P \lor Q) \equiv \neg(\neg P) \land \neg Q\)</li>
                                <li>应用双重否定：\(\neg(\neg P) \land \neg Q \equiv P \land \neg Q\)</li>
                                <li>所以命题成立 ✓</li>
                            </ol>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 1.3 Quantifiers -->
            <div class="subsection" id="logic-quantifiers">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    1.3 量词
                </h3>
                <div class="collapsible-content">
                    <div class="formula-box">
                        <h4>📐 重要公式</h4>
                        <div class="formula-item">
                            <strong>全称量词（Universal Quantifier）：</strong>
                            \[\forall x \in S, P(x)\]
                            意思：对于集合 \(S\) 中的所有 \(x\)，\(P(x)\) 都成立
                        </div>
                        <div class="formula-item">
                            <strong>存在量词（Existential Quantifier）：</strong>
                            \[\exists x \in S, P(x)\]
                            意思：存在集合 \(S\) 中的某个 \(x\)，使得 \(P(x)\) 成立
                        </div>
                        <div class="formula-item">
                            <strong>量词否定：</strong>
                            \[\neg(\forall x \in S, P(x)) \equiv \exists x \in S, \neg P(x)\]
                            \[\neg(\exists x \in S, P(x)) \equiv \forall x \in S, \neg P(x)\]
                        </div>
                        <div class="formula-item">
                            <strong>量词分配（需要注意）：</strong>
                            \[(\forall x, P(x)) \land (\forall x, Q(x)) \equiv \forall x, (P(x) \land Q(x))\]
                            \[(\exists x, P(x)) \lor (\exists x, Q(x)) \equiv \exists x, (P(x) \lor Q(x))\]
                            <br><strong>⚠️ 但以下不等价：</strong>
                            \[(\forall x, P(x)) \lor (\forall x, Q(x)) \not\equiv \forall x, (P(x) \lor Q(x))\]
                        </div>
                    </div>

                    <!-- Problem -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_fa24.pdf - Q3.2</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>对于非空集合 \(S\)，判断以下蕴含式是否总是为真：
                            \[
                            \left[(\forall y \in S)(\exists x \in S)(Q(x) \land P(y))\right] \Rightarrow
                            \left[(\exists x \in S)Q(x) \land (\forall y \in S)P(y)\right]
                            \]
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 答案：Yes（总是为真）</h4>
                            <p><strong>解析：</strong></p>
                            <ol>
                                <li><strong>分析左边（前提）：</strong>
                                    <ul>
                                        <li>\((\forall y \in S)(\exists x \in S)(Q(x) \land P(y))\)</li>
                                        <li>对于每个 \(y\)，都存在某个 \(x\) 使得 \(Q(x)\) 和 \(P(y)\) 都成立</li>
                                    </ul>
                                </li>
                                <li><strong>推导右边第一部分 \((\exists x \in S)Q(x)\)：</strong>
                                    <ul>
                                        <li>因为 \(S\) 非空，至少存在一个 \(y_0 \in S\)</li>
                                        <li>由前提，存在某个 \(x_0\) 使得 \(Q(x_0) \land P(y_0)\) 成立</li>
                                        <li>因此 \(Q(x_0)\) 成立，所以 \((\exists x \in S)Q(x)\) 成立 ✓</li>
                                    </ul>
                                </li>
                                <li><strong>推导右边第二部分 \((\forall y \in S)P(y)\)：</strong>
                                    <ul>
                                        <li>对于任意 \(y \in S\)，由前提知存在某个 \(x\) 使得 \(Q(x) \land P(y)\)</li>
                                        <li>从 \(Q(x) \land P(y)\) 可得 \(P(y)\)</li>
                                        <li>因此对所有 \(y\)，\(P(y)\) 都成立 ✓</li>
                                    </ul>
                                </li>
                                <li>两部分都成立，所以蕴含式为真</li>
                            </ol>
                        </div>
                    </div>

                    <!-- Problem: dis01a Problem 1 - Propositional Logic Review -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis01a.pdf - Problem 1</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>命题逻辑综合练习
                            <br><br>
                            <strong>(a)</strong> 假设 \(P\) 为真，\(Q\) 为假。评估以下命题的真值：
                            <ul>
                                <li>(i) \(P \land Q\)</li>
                                <li>(ii) \(P \Rightarrow Q\)</li>
                                <li>(iii) \(\neg P \Rightarrow Q\)</li>
                                <li>(iv) \(\neg Q \Rightarrow \neg P\)</li>
                            </ul>
                            <strong>(b)</strong> 将以下英文句子转换为命题逻辑：<br>
                            <em>"Every integer has at least one divisor."</em>
                            <br><br>
                            <strong>(c)</strong> 将以下命题逻辑语句转换为英文：<br>
                            \[\neg(\forall x, y \in \mathbb{Z})[(x < y) \Rightarrow (\exists z \in \mathbb{Z})(x < z < y)]\]
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>(a) 评估命题真值（已知 \(P\) = T, \(Q\) = F）：</strong></p>

                            <p><strong>(i) \(P \land Q\)：</strong></p>
                            <ul>
                                <li>\(P \land Q = \text{T} \land \text{F} = \text{F}\)</li>
                                <li><strong>答案：False</strong></li>
                            </ul>

                            <p><strong>(ii) \(P \Rightarrow Q\)：</strong></p>
                            <ul>
                                <li>\(P \Rightarrow Q = \text{T} \Rightarrow \text{F} = \text{F}\)</li>
                                <li>记住：蕴含式只有在"真推假"时为假</li>
                                <li><strong>答案：False</strong></li>
                            </ul>

                            <p><strong>(iii) \(\neg P \Rightarrow Q\)：</strong></p>
                            <ul>
                                <li>\(\neg P = \neg \text{T} = \text{F}\)</li>
                                <li>\(\neg P \Rightarrow Q = \text{F} \Rightarrow \text{F} = \text{T}\)</li>
                                <li>"假推假"为真（假命题可以推出任何东西）</li>
                                <li><strong>答案：True</strong></li>
                            </ul>

                            <p><strong>(iv) \(\neg Q \Rightarrow \neg P\)：</strong></p>
                            <ul>
                                <li>\(\neg Q = \neg \text{F} = \text{T}\)</li>
                                <li>\(\neg P = \neg \text{T} = \text{F}\)</li>
                                <li>\(\neg Q \Rightarrow \neg P = \text{T} \Rightarrow \text{F} = \text{F}\)</li>
                                <li><strong>答案：False</strong></li>
                            </ul>

                            <p><strong>注意：</strong>(iv) 是 (ii) 的逆否命题，但它们的真值相同。这验证了 \(P \Rightarrow Q \equiv \neg Q \Rightarrow \neg P\)。</p>

                            <hr>

                            <p><strong>(b) 英文转命题逻辑：</strong></p>
                            <p><em>"Every integer has at least one divisor."</em></p>

                            <p><strong>分析：</strong></p>
                            <ul>
                                <li>"Every integer" → \(\forall n \in \mathbb{Z}\)</li>
                                <li>"has at least one divisor" → \(\exists d \in \mathbb{Z}\) 使得 \(d \mid n\)</li>
                            </ul>

                            <p><strong>答案：</strong></p>
                            \[(\forall n \in \mathbb{Z})(\exists d \in \mathbb{Z})(d \mid n)\]

                            <p><strong>注意：</strong>这个命题是真的，因为每个整数都至少有 1 和它自己作为因子。</p>

                            <hr>

                            <p><strong>(c) 命题逻辑转英文：</strong></p>
                            \[\neg(\forall x, y \in \mathbb{Z})[(x < y) \Rightarrow (\exists z \in \mathbb{Z})(x < z < y)]\]

                            <p><strong>逐步分析：</strong></p>

                            <p><strong>步骤 1：</strong>理解内层命题</p>
                            <ul>
                                <li>\((x < y) \Rightarrow (\exists z \in \mathbb{Z})(x < z < y)\)</li>
                                <li>意思：如果 \(x < y\)，那么存在一个整数 \(z\) 使得 \(x < z < y\)</li>
                            </ul>

                            <p><strong>步骤 2：</strong>全称量词</p>
                            <ul>
                                <li>\((\forall x, y \in \mathbb{Z})[…]\)</li>
                                <li>意思：对于任意两个整数 \(x\) 和 \(y\)，上述蕴含式成立</li>
                            </ul>

                            <p><strong>步骤 3：</strong>否定</p>
                            <ul>
                                <li>\(\neg(\forall x, y \in \mathbb{Z})[…]\)</li>
                                <li>等价于：\((\exists x, y \in \mathbb{Z})[\neg(…)]\)</li>
                            </ul>

                            <p><strong>应用量词否定和蕴含式否定：</strong></p>
                            \[\begin{align}
                            &\neg(\forall x, y)[(x < y) \Rightarrow (\exists z)(x < z < y)] \\
                            \equiv\; &(\exists x, y)[\neg((x < y) \Rightarrow (\exists z)(x < z < y))] \\
                            \equiv\; &(\exists x, y)[(x < y) \land \neg(\exists z)(x < z < y)] \\
                            \equiv\; &(\exists x, y)[(x < y) \land (\forall z)(\neg(x < z < y))] \\
                            \equiv\; &(\exists x, y)[(x < y) \land (\forall z)(z \leq x \lor z \geq y)]
                            \end{align}\]

                            <p><strong>答案（英文）：</strong></p>
                            <p><em>"There exist integers x and y such that x is less than y, but there is no integer strictly between them."</em></p>

                            <p>或者更自然的表述：</p>
                            <p><em>"There exist two integers with no integer between them."</em></p>

                            <p><strong>注意：</strong>这个命题是<strong>真</strong>的！例如 \(x = 1, y = 2\)，它们之间没有整数。这说明原始命题（被否定的）是假的。</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- More sections will be added here following the same pattern -->

        <!-- Section 2: Proof Techniques -->
        <section class="section" id="proofs">
            <h2 class="section-title">2. Proof Techniques（证明方法）</h2>

            <!-- 2.1 Direct Proof -->
            <div class="subsection" id="proof-direct">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    2.1 直接证明（Direct Proof）
                </h3>
                <div class="collapsible-content">
                    <div class="concept-box">
                        <h4>📚 核心概念</h4>
                        <p>直接证明是最基本的证明方法，从已知条件出发，通过逻辑推理直接得出结论。</p>
                        <ul>
                            <li><strong>基本思路</strong>：假设前提为真，通过一系列逻辑步骤推导出结论</li>
                            <li><strong>常用技巧</strong>：使用定义、已知定理、代数运算</li>
                        </ul>
                    </div>

                    <div class="formula-box">
                        <h4>📐 重要定义</h4>
                        <div class="formula-item">
                            <strong>整除定义：</strong>
                            \[a \mid b \text{ 意思是 } b = ka \text{ 对某个整数 } k\]
                        </div>
                        <div class="formula-item">
                            <strong>合数定义：</strong>
                            \[n \text{ 是合数 } \Leftrightarrow n = ab \text{ 其中 } 1 < a, b < n\]
                        </div>
                        <div class="formula-item">
                            <strong>阶乘定义：</strong>
                            \[n! = n \times (n-1) \times (n-2) \times \cdots \times 2 \times 1\]
                        </div>
                    </div>

                    <div class="tips-box">
                        <h4>💡 解题技巧</h4>
                        <ul>
                            <li>从定义出发：将所有术语用定义展开</li>
                            <li>分情况讨论：当问题涉及多种可能性时</li>
                            <li>寻找关键关系：找到已知和待证之间的桥梁</li>
                        </ul>
                    </div>

                    <!-- Problem 1: Composite divides factorial -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_fa24.pdf - Q4.1</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>设 \(n > 4\) 是一个合数。证明：
                            \[n \mid (n-1)!\]
                            提示：考虑 \(n\) 是否为完全平方数。
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 证明：</h4>
                            <p><strong>情况1：\(n\) 不是完全平方数</strong></p>
                            <ul>
                                <li>因为 \(n\) 是合数且 \(n > 4\)，所以 \(n = ab\) 其中 \(1 < a < b < n\)</li>
                                <li>由于 \(n\) 不是完全平方数，所以 \(a \neq b\)</li>
                                <li>因此 \(a\) 和 \(b\) 都在 \(\{2, 3, \ldots, n-1\}\) 中</li>
                                <li>\((n-1)! = 1 \times 2 \times \cdots \times a \times \cdots \times b \times \cdots \times (n-1)\)</li>
                                <li>所以 \((n-1)!\) 包含因子 \(a\) 和 \(b\)</li>
                                <li>因此 \((n-1)! = ab \times k = n \times k\) 对某个整数 \(k\)</li>
                                <li>故 \(n \mid (n-1)!\) ✓</li>
                            </ul>

                            <p><strong>情况2：\(n\) 是完全平方数</strong></p>
                            <ul>
                                <li>设 \(n = p^2\) 其中 \(p\) 是正整数</li>
                                <li>因为 \(n > 4\)，所以 \(p \geq 3\)</li>
                                <li>注意到 \(p\) 和 \(2p\) 都小于 \(n = p^2\)（因为 \(2p < p^2\) 当 \(p \geq 3\) 时）</li>
                                <li>\((n-1)!\) 包含因子 \(p\) 和 \(2p\)</li>
                                <li>\(p \times 2p = 2p^2 = 2n\)</li>
                                <li>所以 \((n-1)! = p \times 2p \times k = 2p^2 \times k = 2n \times k\)</li>
                                <li>因此 \(n \mid (n-1)!\) ✓</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 2.2 Proof by Contradiction -->
            <div class="subsection" id="proof-contradiction">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    2.2 反证法（Proof by Contradiction）
                </h3>
                <div class="collapsible-content">
                    <div class="concept-box">
                        <h4>📚 核心概念</h4>
                        <p>反证法通过假设结论的否定，推导出矛盾，从而证明原命题为真。</p>
                        <ul>
                            <li><strong>基本步骤</strong>：
                                <ol>
                                    <li>假设结论的否定为真</li>
                                    <li>结合已知条件进行推导</li>
                                    <li>得出矛盾（与已知事实、假设或逻辑矛盾）</li>
                                    <li>结论：原命题必为真</li>
                                </ol>
                            </li>
                        </ul>
                    </div>

                    <div class="formula-box">
                        <h4>📐 反证法逻辑结构</h4>
                        <div class="formula-item">
                            <strong>要证明：</strong> \(P \Rightarrow Q\)
                            <br><strong>反证法：</strong>假设 \(\neg Q\)，推导出矛盾
                            <br><strong>逻辑等价：</strong>\((P \land \neg Q) \Rightarrow \text{False}\) 等价于 \(P \Rightarrow Q\)
                        </div>
                    </div>

                    <div class="tips-box">
                        <h4>💡 何时使用反证法</h4>
                        <ul>
                            <li>证明"不存在"类型的命题</li>
                            <li>证明无理数相关命题</li>
                            <li>直接证明很难找到推导路径时</li>
                            <li>结论的否定更容易操作时</li>
                        </ul>
                    </div>

                    <!-- Problem: Irrational square root -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_fa24.pdf - Q4.2</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>证明对于 \(r \in \mathbb{R}\)，如果 \(r^2\) 是无理数，那么 \(r\) 是无理数。
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 证明（反证法）：</h4>
                            <ol>
                                <li><strong>假设结论的否定</strong>：假设 \(r\) 是有理数</li>
                                <li>因为 \(r\) 是有理数，所以可以写成 \(r = \frac{a}{b}\) 的形式，其中 \(a, b\) 是整数且 \(b \neq 0\)</li>
                                <li>那么 \(r^2 = \left(\frac{a}{b}\right)^2 = \frac{a^2}{b^2}\)</li>
                                <li>因为 \(a^2\) 和 \(b^2\) 都是整数且 \(b^2 \neq 0\)，所以 \(r^2\) 是有理数</li>
                                <li><strong>矛盾</strong>：这与题目给定的"\(r^2\) 是无理数"矛盾！</li>
                                <li>因此，我们的假设错误</li>
                                <li><strong>结论</strong>：\(r\) 必定是无理数 ✓</li>
                            </ol>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 2.3 Proof by Contrapositive -->
            <div class="subsection" id="proof-contrapositive">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    2.3 逆否命题证明（Proof by Contrapositive）
                </h3>
                <div class="collapsible-content">
                    <div class="concept-box">
                        <h4>📚 核心概念</h4>
                        <p>利用逆否命题与原命题等价的性质，通过证明逆否命题来证明原命题。</p>
                    </div>

                    <div class="formula-box">
                        <h4>📐 逆否命题等价性</h4>
                        <div class="formula-item">
                            <strong>原命题：</strong> \(P \Rightarrow Q\)
                            <br><strong>逆否命题：</strong> \(\neg Q \Rightarrow \neg P\)
                            <br><strong>逻辑等价：</strong> \((P \Rightarrow Q) \equiv (\neg Q \Rightarrow \neg P)\)
                        </div>
                    </div>

                    <div class="tips-box">
                        <h4>💡 何时使用逆否证明</h4>
                        <ul>
                            <li>原命题的逆否形式更容易直接证明</li>
                            <li>结论的否定比结论本身更具体、更好操作</li>
                            <li>前提的否定很难直接使用时</li>
                        </ul>
                    </div>

                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_sp24.pdf - Q4(b)</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>写出以下命题的逆否命题：<br>
                            "If the robot is powered on, then it is either in motion or its alarm system is activated."
                            <br><br>
                            变量：\(P\): powered on, \(M\): in motion, \(A\): alarm activated
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 答案：</h4>
                            <p><strong>原命题：</strong> \(P \Rightarrow (M \lor A)\)</p>
                            <p><strong>逆否命题：</strong> \(\neg(M \lor A) \Rightarrow \neg P\)</p>
                            <p><strong>简化：</strong> \((\neg M \land \neg A) \Rightarrow \neg P\)</p>
                            <p><strong>英文表述：</strong> "If the robot is not in motion and its alarm system is not activated, then it is not powered on."</p>
                        </div>
                    </div>

                    <!-- Problem: dis01a Problem 2 - Perfect Square -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis01a.pdf - Problem 2</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>完全平方数证明
                            <br><br>
                            <strong>(a)</strong> 证明：如果 \(n^2\) 是奇数，那么 \(n\) 也必须是奇数。<br>
                            <strong>(b)</strong> 证明：如果 \(n^2\) 是奇数，那么 \(n^2\) 可以写成 \(8k + 1\) 的形式，其中 \(k\) 是整数。
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>(a) 证明：如果 \(n^2\) 是奇数，那么 \(n\) 也是奇数</strong></p>

                            <p><strong>证明方法：逆否命题证明（Proof by Contrapositive）</strong></p>

                            <p><strong>原命题：</strong>\(n^2 \text{ 奇数} \Rightarrow n \text{ 奇数}\)</p>
                            <p><strong>逆否命题：</strong>\(n \text{ 偶数} \Rightarrow n^2 \text{ 偶数}\)</p>

                            <p><strong>证明逆否命题：</strong></p>
                            <ol>
                                <li>假设 \(n\) 是偶数</li>
                                <li>那么 \(n = 2k\) 对某个整数 \(k\)</li>
                                <li>\(n^2 = (2k)^2 = 4k^2 = 2(2k^2)\)</li>
                                <li>设 \(m = 2k^2\)，那么 \(n^2 = 2m\)</li>
                                <li>因此 \(n^2\) 是偶数 ✓</li>
                            </ol>

                            <p><strong>结论：</strong>逆否命题成立，因此原命题成立。</p>

                            <hr>

                            <p><strong>(b) 证明：如果 \(n^2\) 是奇数，那么 \(n^2 = 8k + 1\)</strong></p>

                            <p><strong>证明方法：直接证明 + 分情况讨论</strong></p>

                            <ol>
                                <li>由 (a) 知，如果 \(n^2\) 是奇数，那么 \(n\) 也是奇数</li>
                                <li>因此 \(n = 2m + 1\) 对某个整数 \(m\)</li>
                                <li>计算 \(n^2\):
                                    \[\begin{align}
                                    n^2 &= (2m + 1)^2 \\
                                    &= 4m^2 + 4m + 1 \\
                                    &= 4m(m + 1) + 1
                                    \end{align}\]
                                </li>
                                <li><strong>关键观察：</strong>\(m\) 和 \(m+1\) 是连续整数，必有一个是偶数</li>
                                <li>因此 \(m(m+1)\) 是偶数，设 \(m(m+1) = 2t\)</li>
                                <li>那么：
                                    \[\begin{align}
                                    n^2 &= 4 \cdot 2t + 1 \\
                                    &= 8t + 1
                                    \end{align}\]
                                </li>
                                <li>设 \(k = t\)，则 \(n^2 = 8k + 1\) ✓</li>
                            </ol>

                            <p><strong>关键思想：</strong>奇数的平方除以 8 余 1。这是一个重要的数论性质！</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 2.4 鞍笼原理 -->
            <div class="subsection" id="proof-pigeonhole">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    2.4 鸽笼原理（Pigeonhole Principle）
                </h3>
                <div class="collapsible-content">
                    <div class="concept-box">
                        <h4>📚 核心概念</h4>
                        <p>鸽笼原理（也称抽屉原理）是一个简单但强大的计数原理。</p>
                    </div>

                    <div class="formula-box">
                        <h4>📐 鸽笼原理公式</h4>
                        <div class="formula-item">
                            <strong>基本形式：</strong>
                            如果 \(n\) 个物体放入 \(m\) 个盒子，且 \(n > m\)，<br>
                            那么至少有一个盒子包含多于一个物体。
                        </div>
                        <div class="formula-item">
                            <strong>一般形式：</strong>
                            如果 \(n\) 个物体放入 \(m\) 个盒子，<br>
                            那么至少有一个盒子包含至少 \(\lceil n/m \rceil\) 个物体。
                        </div>
                    </div>

                    <div class="tips-box">
                        <h4>💡 应用技巧</h4>
                        <ul>
                            <li>识别"鸽子"（要分配的对象）</li>
                            <li>识别"笼子"（分类标准或容器）</li>
                            <li>计算鸽子和笼子的数量关系</li>
                            <li>常用于证明存在性问题</li>
                        </ul>
                    </div>

                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">经典应用</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>证明：在任意13个人中，至少有2个人的生日在同一个月。
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 证明：</h4>
                            <ul>
                                <li><strong>鸽子：</strong>13个人</li>
                                <li><strong>笼子：</strong>12个月份</li>
                                <li>因为 \(13 > 12\)，根据鸽笼原理</li>
                                <li>至少有一个月份包含至少 \(\lceil 13/12 \rceil = 2\) 个人</li>
                                <li>因此至少有2个人的生日在同一个月 ✓</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Problem: dis01a Problem 3 - Numbers of Friends -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis01a.pdf - Problem 3</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>证明：在一个有 \(n \geq 2\) 个人的派对中，至少有 2 个人有相同数量的朋友。
                            <br><br>
                            假设友谊是相互的：如果 Alice 是 Bob 的朋友，那么 Bob 也是 Alice 的朋友。
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>证明（使用鞍笼原理）：</strong>

                            <p><strong>分析：</strong></p>
                            <ul>
                                <li>每个人在派对中的朋友数量可能是 0, 1, 2, ..., \(n-1\)</li>
                                <li>这看起来有 \(n\) 种可能的值，但实际上不可能同时出现 0 和 \(n-1\)</li>
                            </ul>

                            <p><strong>关键观察：</strong>0 和 \(n-1\) 不能同时存在</p>
                            <ul>
                                <li>如果某人朋友数为 \(n-1\)，则他与其他所有人都是朋友</li>
                                <li>那么就不可能有人朋友数为 0（因为这个人至少与前者是朋友）</li>
                                <li>同理，如果某人朋友数为 0，则没有人能与所有人都是朋友</li>
                            </ul>

                            <p><strong>分情况证明：</strong></p>

                            <p><strong>情况 1：</strong>存在人朋友数为 0</p>
                            <ul>
                                <li>那么所有人的朋友数只能在 \(\{0, 1, 2, \ldots, n-2\}\) 中</li>
                                <li>这有 \(n-1\) 种可能的值</li>
                                <li>但有 \(n\) 个人（鞍子）</li>
                                <li>根据鞍笼原理，至少有 2 个人有相同数量的朋友 ✓</li>
                            </ul>

                            <p><strong>情况 2：</strong>不存在人朋友数为 0</p>
                            <ul>
                                <li>那么所有人的朋友数只能在 \(\{1, 2, \ldots, n-1\}\) 中</li>
                                <li>这有 \(n-1\) 种可能的值</li>
                                <li>但有 \(n\) 个人（鞍子）</li>
                                <li>根据鞍笼原理，至少有 2 个人有相同数量的朋友 ✓</li>
                            </ul>

                            <p><strong>结论：</strong>无论哪种情况，都有至少 2 个人有相同数量的朋友。</p>

                            <p><strong>关键思想：</strong></p>
                            <ul>
                                <li><strong>鞍子：</strong>\(n\) 个人</li>
                                <li><strong>笼子：</strong>可能的朋友数，但只有 \(n-1\) 种</li>
                                <li>关键是识别出 0 和 \(n-1\) 不能同时存在！</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 3: Induction -->
        <section class="section" id="induction">
            <h2 class="section-title">3. Induction（数学归纳法）</h2>

            <!-- 3.1 Weak Induction -->
            <div class="subsection" id="induction-weak">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    3.1 弱归纳法（Weak/Simple Induction）
                </h3>
                <div class="collapsible-content">
                    <div class="concept-box">
                        <h4>📚 核心概念</h4>
                        <p>数学归纳法用于证明关于自然数的命题。弱归纳法假设命题对 \(n\) 成立，然后证明对 \(n+1\) 也成立。</p>
                        <ul>
                            <li><strong>适用范围</strong>：证明对所有 \(n \geq n_0\) 的命题 \(P(n)\)</li>
                            <li><strong>递推性质</strong>：\(P(n+1)\) 只依赖于 \(P(n)\)</li>
                        </ul>
                    </div>

                    <div class="formula-box">
                        <h4>📐 弱归纳法三步骤</h4>
                        <div class="formula-item">
                            <strong>Step 1 - 基础步骤（Base Case）：</strong>
                            <br>证明 \(P(n_0)\) 成立（通常 \(n_0 = 0\) 或 \(1\)）
                        </div>
                        <div class="formula-item">
                            <strong>Step 2 - 归纳假设（Inductive Hypothesis）：</strong>
                            <br>假设 \(P(n)\) 对某个 \(n \geq n_0\) 成立
                        </div>
                        <div class="formula-item">
                            <strong>Step 3 - 归纳步骤（Inductive Step）：</strong>
                            <br>在假设 \(P(n)\) 成立的前提下，证明 \(P(n+1)\) 也成立
                        </div>
                        <div class="formula-item">
                            <strong>结论：</strong>
                            \[[\,P(n_0) \land (\forall n \geq n_0)(P(n) \Rightarrow P(n+1))\,] \Rightarrow (\forall n \geq n_0)P(n)\]
                        </div>
                    </div>

                    <div class="tips-box">
                        <h4>💡 解题技巧</h4>
                        <ul>
                            <li><strong>明确标注三个步骤</strong>：Base Case, IH, Inductive Step</li>
                            <li><strong>归纳步骤关键</strong>：必须<em>使用</em>归纳假设 \(P(n)\) 来证明 \(P(n+1)\)</li>
                            <li><strong>代数技巧</strong>：将 \(P(n+1)\) 的式子改写，使其包含 \(P(n)\) 的形式</li>
                            <li><strong>避免循环论证</strong>：不能在证明中直接使用要证明的结论</li>
                        </ul>
                    </div>

                    <!-- Problem 1: Divisibility -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_fa24.pdf - Q5</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>用归纳法证明对于所有 \(n \geq 1\)：
                            \[7 \mid \left(3^{(2n+1)} + 2^{(n-1)}\right)\]
                            要求清楚标明 base case, induction hypothesis, 和 induction step。
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 证明：</h4>

                            <p><strong>Base Case（\(n = 1\)）：</strong></p>
                            <ul>
                                <li>当 \(n = 1\) 时：\(3^{2(1)+1} + 2^{1-1} = 3^3 + 2^0 = 27 + 1 = 28\)</li>
                                <li>\(28 = 7 \times 4\)，所以 \(7 \mid 28\) ✓</li>
                                <li>Base case 成立</li>
                            </ul>

                            <p><strong>Inductive Hypothesis（归纳假设）：</strong></p>
                            <ul>
                                <li>假设对某个 \(n \geq 1\)，命题成立，即：</li>
                                <li>\(7 \mid \left(3^{(2n+1)} + 2^{(n-1)}\right)\)</li>
                                <li>这意味着存在整数 \(k\) 使得：\(3^{(2n+1)} + 2^{(n-1)} = 7k\)</li>
                            </ul>

                            <p><strong>Inductive Step（证明 \(n+1\) 的情况）：</strong></p>
                            <ul>
                                <li>需要证明：\(7 \mid \left(3^{(2(n+1)+1)} + 2^{((n+1)-1)}\right)\)</li>
                                <li>即证明：\(7 \mid \left(3^{(2n+3)} + 2^{n}\right)\)</li>
                                <li>展开：
                                    \begin{align}
                                    3^{(2n+3)} + 2^{n} &= 3^{(2n+1)+2} + 2^{n} \\
                                    &= 3^{(2n+1)} \cdot 3^2 + 2^{n} \\
                                    &= 9 \cdot 3^{(2n+1)} + 2 \cdot 2^{(n-1)}
                                    \end{align}
                                </li>
                                <li>从归纳假设知：\(3^{(2n+1)} + 2^{(n-1)} = 7k\)</li>
                                <li>所以：\(3^{(2n+1)} = 7k - 2^{(n-1)}\)</li>
                                <li>代入：
                                    \begin{align}
                                    9 \cdot 3^{(2n+1)} + 2 \cdot 2^{(n-1)} &= 9(7k - 2^{(n-1)}) + 2 \cdot 2^{(n-1)} \\
                                    &= 63k - 9 \cdot 2^{(n-1)} + 2 \cdot 2^{(n-1)} \\
                                    &= 63k - 7 \cdot 2^{(n-1)} \\
                                    &= 7(9k - 2^{(n-1)})
                                    \end{align}
                                </li>
                                <li>因此 \(7 \mid \left(3^{(2n+3)} + 2^{n}\right)\) ✓</li>
                            </ul>

                            <p><strong>结论：</strong>由数学归纳法，命题对所有 \(n \geq 1\) 成立。</p>
                        </div>
                    </div>

                    <!-- Problem 2: Fibonacci -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_sp24.pdf - Q6(a)</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>斐波那契数列定义为 \(F_0 = 0, F_1 = 1\)，且 \(F_n = F_{n-1} + F_{n-2}\) 对 \(n \geq 2\)。
                            <br>用归纳法证明对所有 \(n \geq 0\)：
                            \[F_0^2 + F_1^2 + \cdots + F_n^2 = F_n \cdot F_{n+1}\]
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 证明：</h4>

                            <p><strong>Base Case（\(n = 0\)）：</strong></p>
                            <ul>
                                <li>左边：\(F_0^2 = 0^2 = 0\)</li>
                                <li>右边：\(F_0 \cdot F_1 = 0 \cdot 1 = 0\)</li>
                                <li>左边 = 右边，base case 成立 ✓</li>
                            </ul>

                            <p><strong>Inductive Hypothesis：</strong></p>
                            <ul>
                                <li>假设对某个 \(n \geq 0\)，命题成立：</li>
                                <li>\(F_0^2 + F_1^2 + \cdots + F_n^2 = F_n \cdot F_{n+1}\)</li>
                            </ul>

                            <p><strong>Inductive Step（证明 \(n+1\)）：</strong></p>
                            <ul>
                                <li>需要证明：\(F_0^2 + F_1^2 + \cdots + F_n^2 + F_{n+1}^2 = F_{n+1} \cdot F_{n+2}\)</li>
                                <li>从归纳假设出发：
                                    \begin{align}
                                    F_0^2 + F_1^2 + \cdots + F_n^2 + F_{n+1}^2 &= F_n \cdot F_{n+1} + F_{n+1}^2 \\
                                    &= F_{n+1}(F_n + F_{n+1}) \\
                                    &= F_{n+1} \cdot F_{n+2} \quad \text{（斐波那契递推关系）}
                                    \end{align}
                                </li>
                                <li>这正是我们要证明的！✓</li>
                            </ul>

                            <p><strong>结论：</strong>由数学归纳法，命题对所有 \(n \geq 0\) 成立。</p>
                        </div>
                    </div>

                    <!-- Problem: dis01b Problem 1 - Bernoulli's Inequality -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis01b.pdf - Problem 1</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>证明对于 \(n \in \mathbb{N}\) 和 \(x > 0\)，有：
                            \[(1+x)^n \geq 1 + nx\]
                            （伯努利不等式）
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>证明（归纳法）：</strong>

                            <p><strong>Base Case（\(n = 0\)）：</strong></p>
                            <ul>
                                <li>左边：\((1+x)^0 = 1\)</li>
                                <li>右边：\(1 + 0 \cdot x = 1\)</li>
                                <li>左边 = 右边 ✓</li>
                            </ul>

                            <p><strong>Inductive Hypothesis：</strong></p>
                            <ul>
                                <li>假设对某个 \(n \geq 0\)，不等式成立：\((1+x)^n \geq 1 + nx\)</li>
                            </ul>

                            <p><strong>Inductive Step（证明 \(n+1\)）：</strong></p>
                            <p>需要证明：\((1+x)^{n+1} \geq 1 + (n+1)x\)</p>

                            <p><strong>推导：</strong></p>
                            \[\begin{align}
                            (1+x)^{n+1} &= (1+x)^n \cdot (1+x) \\
                            &\geq (1 + nx) \cdot (1+x) \quad \text{(归纳假设)} \\
                            &= 1 + x + nx + nx^2 \\
                            &= 1 + (n+1)x + nx^2 \\
                            &\geq 1 + (n+1)x \quad \text{(因为 } nx^2 \geq 0)
                            \end{align}\]

                            <p><strong>关键步骤：</strong></p>
                            <ul>
                                <li>第二步使用了归纳假设</li>
                                <li>最后一步利用了 \(x > 0\) 和 \(n \geq 0\)，所以 \(nx^2 \geq 0\)</li>
                            </ul>

                            <p><strong>结论：</strong>由数学归纳法，伯努利不等式对所有自然数 \(n\) 成立。</p>

                            <p><strong>应用：</strong>这个不等式在分析算法和概率论中经常用到！</p>
                        </div>
                    </div>

                    <!-- Problem: dis01b Problem 4 - Fibonacci Even -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis01b.pdf - Problem 4</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>斯波那契数列定义为：
                            \[F_1 = 1, \quad F_2 = 1, \quad F_n = F_{n-2} + F_{n-1} \text{ 对 } n \geq 3\]
                            证明：每第三个斯波那契数是偶数。例如，\(F_3 = 2\) 和 \(F_6 = 8\) 都是偶数。
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>证明（强归纳法）：</strong>

                            <p><strong>命题：</strong>证明对所有 \(n \geq 1\)，\(F_{3n}\) 是偶数。</p>

                            <p><strong>Base Cases：</strong></p>
                            <ul>
                                <li>\(n = 1\): \(F_3 = F_2 + F_1 = 1 + 1 = 2\) 是偶数 ✓</li>
                                <li>\(n = 2\): \(F_6 = 8\) 是偶数 （计算：1, 1, 2, 3, 5, 8）✓</li>
                            </ul>

                            <p><strong>Inductive Hypothesis：</strong></p>
                            <ul>
                                <li>假设对所有 \(k \leq n\)，\(F_{3k}\) 都是偶数</li>
                            </ul>

                            <p><strong>Inductive Step（证明 \(n+1\)）：</strong></p>
                            <p>需要证明：\(F_{3(n+1)} = F_{3n+3}\) 是偶数</p>

                            <p><strong>方法 1：直接使用递推关系</strong></p>
                            \[\begin{align}
                            F_{3n+3} &= F_{3n+2} + F_{3n+1} \\
                            &= (F_{3n+1} + F_{3n}) + F_{3n+1} \\
                            &= 2F_{3n+1} + F_{3n}
                            \end{align}\]

                            <p>由归纳假设，\(F_{3n}\) 是偶数。</p>
                            <p>而 \(2F_{3n+1}\) 显然是偶数（任何数乘以 2 都是偶数）。</p>
                            <p>因此 \(F_{3n+3} = 2F_{3n+1} + F_{3n}\) 是两个偶数之和，也是偶数 ✓</p>

                            <hr>

                            <p><strong>方法 2：奇偶性分析</strong></p>
                            <p>观察斯波那契数列的奇偶性模式：</p>
                            <ul>
                                <li>\(F_1 = 1\) (奇)</li>
                                <li>\(F_2 = 1\) (奇)</li>
                                <li>\(F_3 = 2\) (偶) - 奇 + 奇 = 偶</li>
                                <li>\(F_4 = 3\) (奇) - 奇 + 偶 = 奇</li>
                                <li>\(F_5 = 5\) (奇) - 偶 + 奇 = 奇</li>
                                <li>\(F_6 = 8\) (偶) - 奇 + 奇 = 偶</li>
                            </ul>
                            <p>模式：奇、奇、<strong>偶</strong>、奇、奇、<strong>偶</strong>、... 周期为 3！</p>

                            <p><strong>结论：</strong>每第三个斯波那契数确实是偶数。</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 3.2 强归纳法 -->
            <div class="subsection" id="induction-strong">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    3.2 强归纳法（Strong Induction）
                </h3>
                <div class="collapsible-content">
                    <div class="concept-box">
                        <h4>📚 核心概念</h4>
                        <p>强归纳法在归纳步骤中可以假设命题对所有 \(n_0 \leq k \leq n\) 都成立，而不仅仅是 \(n\)。</p>
                        <ul>
                            <li><strong>何时使用</strong>：当 \(P(n+1)\) 依赖于多个之前的情况，而不仅仅是 \(P(n)\)</li>
                            <li><strong>典型应用</strong>：递推关系涉及多个前项（如斐波那契）、游戏策略、整除性问题</li>
                        </ul>
                    </div>

                    <div class="formula-box">
                        <h4>📐 强归纳法结构</h4>
                        <div class="formula-item">
                            <strong>Base Case：</strong>证明 \(P(n_0), P(n_0+1), \ldots, P(n_0+k)\) 成立（可能需要多个）
                        </div>
                        <div class="formula-item">
                            <strong>Inductive Hypothesis：</strong>假设对所有 \(n_0 \leq k \leq n\)，\(P(k)\) 都成立
                        </div>
                        <div class="formula-item">
                            <strong>Inductive Step：</strong>在上述假设下，证明 \(P(n+1)\) 成立
                        </div>
                        <div class="formula-item">
                            <strong>逻辑形式：</strong>
                            \[[\,P(n_0) \land (\forall n \geq n_0)((\forall k, n_0 \leq k \leq n, P(k)) \Rightarrow P(n+1))\,] \Rightarrow (\forall n \geq n_0)P(n)\]
                        </div>
                    </div>

                    <div class="tips-box">
                        <h4>💡 强归纳 vs 弱归纳</h4>
                        <ul>
                            <li><strong>理论上</strong>：强归纳和弱归纳证明能力相同</li>
                            <li><strong>实践中</strong>：有些问题用强归纳更自然、更简洁</li>
                            <li><strong>选择标准</strong>：看 \(P(n+1)\) 依赖于哪些之前的情况</li>
                        </ul>
                    </div>

                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">经典问题</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>证明每个大于1的正整数都可以表示为质数的乘积。
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 证明（强归纳法）：</h4>

                            <p><strong>Base Case（\(n = 2\)）：</strong></p>
                            <ul>
                                <li>2本身就是质数，可以表示为质数的乘积（单个质数）✓</li>
                            </ul>

                            <p><strong>Inductive Hypothesis：</strong></p>
                            <ul>
                                <li>假设对所有 \(2 \leq k \leq n\)，\(k\) 都可以表示为质数的乘积</li>
                            </ul>

                            <p><strong>Inductive Step（证明 \(n+1\)）：</strong></p>
                            <ul>
                                <li><strong>情况1</strong>：如果 \(n+1\) 是质数，则它本身就是质数的乘积 ✓</li>
                                <li><strong>情况2</strong>：如果 \(n+1\) 是合数，则 \(n+1 = a \times b\) 其中 \(2 \leq a, b \leq n\)</li>
                                <li>由归纳假设，\(a\) 和 \(b\) 都可以表示为质数的乘积</li>
                                <li>设 \(a = p_1 \cdots p_k\) 和 \(b = q_1 \cdots q_m\)</li>
                                <li>那么 \(n+1 = a \times b = p_1 \cdots p_k \cdot q_1 \cdots q_m\)</li>
                                <li>这是质数的乘积 ✓</li>
                            </ul>

                            <p><strong>注意</strong>：这里用强归纳是因为我们需要假设所有 \(\leq n\) 的数都满足性质，而不知道具体用到哪个。</p>
                        </div>
                    </div>

                    <!-- Problem: dis01b Problem 3 - Binary Representation -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis01b.pdf - Problem 3</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>证明每个正整数 \(n\) 都可以写成二进制形式。即，对于任何正整数 \(n\)，我们可以写为：
                            \[n = c_k \cdot 2^k + c_{k-1} \cdot 2^{k-1} + \cdots + c_1 \cdot 2^1 + c_0 \cdot 2^0\]
                            其中 \(k \in \mathbb{N}\) 且 \(c_i \in \{0, 1\}\) 对所有 \(i \leq k\)。
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>证明（强归纳法）：</strong>

                            <p><strong>Base Case（\(n = 1\)）：</strong></p>
                            <ul>
                                <li>\(1 = 1 \cdot 2^0\)，其中 \(c_0 = 1\)</li>
                                <li>Base case 成立 ✓</li>
                            </ul>

                            <p><strong>Inductive Hypothesis：</strong></p>
                            <ul>
                                <li>假设对所有 \(1 \leq k \leq n\)，\(k\) 都可以表示为二进制形式</li>
                            </ul>

                            <p><strong>Inductive Step（证明 \(n+1\)）：</strong></p>
                            <p>需要证明 \(n+1\) 可以写成二进制形式。</p>

                            <p><strong>分两种情况：</strong></p>

                            <p><strong>情况 1：\(n+1\) 是偶数</strong></p>
                            <ul>
                                <li>那么 \(n+1 = 2m\) 对某个正整数 \(m\)</li>
                                <li>注意 \(m = \frac{n+1}{2} \leq n\)（因为 \(n \geq 1\)）</li>
                                <li>由归纳假设，\(m\) 可以写成二进制：
                                    \[m = c_k \cdot 2^k + c_{k-1} \cdot 2^{k-1} + \cdots + c_1 \cdot 2^1 + c_0 \cdot 2^0\]
                                </li>
                                <li>那么：
                                    \[\begin{align}
                                    n+1 = 2m &= 2(c_k \cdot 2^k + \cdots + c_0 \cdot 2^0) \\
                                    &= c_k \cdot 2^{k+1} + c_{k-1} \cdot 2^k + \cdots + c_0 \cdot 2^1 + 0 \cdot 2^0
                                    \end{align}\]
                                </li>
                                <li>这是一个二进制表示（最后一位是 0）✓</li>
                            </ul>

                            <p><strong>情况 2：\(n+1\) 是奇数</strong></p>
                            <ul>
                                <li>那么 \(n+1 = 2m + 1\) 对某个非负整数 \(m\)</li>
                                <li>注意 \(m = \frac{n}{2} < n\)</li>
                                <li>如果 \(m \geq 1\)，由归纳假设，\(m\) 可以写成二进制</li>
                                <li>如果 \(m = 0\)，那么 \(n+1 = 1 = 1 \cdot 2^0\)</li>
                                <li>一般情况：
                                    \[\begin{align}
                                    n+1 = 2m + 1 &= 2(c_k \cdot 2^k + \cdots + c_0 \cdot 2^0) + 1 \\
                                    &= c_k \cdot 2^{k+1} + \cdots + c_0 \cdot 2^1 + 1 \cdot 2^0
                                    \end{align}\]
                                </li>
                                <li>这是一个二进制表示（最后一位是 1）✓</li>
                            </ul>

                            <p><strong>结论：</strong>由强归纳法，每个正整数都可以表示为二进制形式。</p>

                            <p><strong>注意：</strong>这个证明实际上给出了一个构造二进制表示的算法：不断除以 2，余数就是每一位的值！</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 3.3 常用求和公式 -->
            <div class="subsection" id="induction-formulas">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    3.3 常用求和公式
                </h3>
                <div class="collapsible-content">
                    <div class="formula-box">
                        <h4>📐 必记求和公式</h4>
                        <div class="formula-item">
                            <strong>等差数列求和：</strong>
                            \[\sum_{i=1}^{n} i = 1 + 2 + \cdots + n = \frac{n(n+1)}{2}\]
                        </div>
                        <div class="formula-item">
                            <strong>平方和：</strong>
                            \[\sum_{i=1}^{n} i^2 = 1^2 + 2^2 + \cdots + n^2 = \frac{n(n+1)(2n+1)}{6}\]
                        </div>
                        <div class="formula-item">
                            <strong>立方和：</strong>
                            \[\sum_{i=1}^{n} i^3 = 1^3 + 2^3 + \cdots + n^3 = \left[\frac{n(n+1)}{2}\right]^2\]
                        </div>
                        <div class="formula-item">
                            <strong>等比数列求和：</strong>
                            \[\sum_{i=0}^{n} r^i = 1 + r + r^2 + \cdots + r^n = \frac{r^{n+1} - 1}{r - 1} \quad (r \neq 1)\]
                        </div>
                        <div class="formula-item">
                            <strong>无穷等比数列（\(|r| < 1\)）：</strong>
                            \[\sum_{i=0}^{\infty} r^i = \frac{1}{1-r}\]
                        </div>
                    </div>

                    <div class="tips-box">
                        <h4>💡 记忆技巧</h4>
                        <ul>
                            <li><strong>等差求和</strong>：首项+末项，乘以项数，除以2，即 \(\frac{(a_1+a_n) \cdot n}{2}\)</li>
                            <li><strong>立方和公式</strong>：恰好等于等差求和的平方</li>
                            <li><strong>等比数列</strong>：记住 \(\frac{r^{n+1}-1}{r-1}\)，从 \(i=0\) 开始</li>
                        </ul>
                    </div>

                    <!-- Problem: Sum of cubes -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_sp24.pdf - Q6(b)</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>用归纳法证明对所有 \(n \geq 1\)：
                            \[\sum_{i=1}^{n} i^3 = \left(\sum_{i=1}^{n} i\right)^2\]
                            提示：可以使用 \(\sum_{i=1}^{n} i = \frac{n(n+1)}{2}\)
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 证明：</h4>

                            <p><strong>Base Case（\(n = 1\)）：</strong></p>
                            <ul>
                                <li>左边：\(\sum_{i=1}^{1} i^3 = 1^3 = 1\)</li>
                                <li>右边：\(\left(\sum_{i=1}^{1} i\right)^2 = 1^2 = 1\)</li>
                                <li>左边 = 右边 ✓</li>
                            </ul>

                            <p><strong>Inductive Hypothesis：</strong></p>
                            <ul>
                                <li>假设对某个 \(n \geq 1\)：\(\sum_{i=1}^{n} i^3 = \left(\sum_{i=1}^{n} i\right)^2\)</li>
                                <li>即：\(\sum_{i=1}^{n} i^3 = \left[\frac{n(n+1)}{2}\right]^2\)</li>
                            </ul>

                            <p><strong>Inductive Step：</strong></p>
                            <ul>
                                <li>需要证明：\(\sum_{i=1}^{n+1} i^3 = \left(\sum_{i=1}^{n+1} i\right)^2\)</li>
                                <li>左边：
                                    \begin{align}
                                    \sum_{i=1}^{n+1} i^3 &= \sum_{i=1}^{n} i^3 + (n+1)^3 \\
                                    &= \left[\frac{n(n+1)}{2}\right]^2 + (n+1)^3 \quad \text{（归纳假设）} \\
                                    &= \frac{n^2(n+1)^2}{4} + (n+1)^3 \\
                                    &= (n+1)^2 \left[\frac{n^2}{4} + (n+1)\right] \\
                                    &= (n+1)^2 \left[\frac{n^2 + 4(n+1)}{4}\right] \\
                                    &= (n+1)^2 \left[\frac{n^2 + 4n + 4}{4}\right] \\
                                    &= (n+1)^2 \left[\frac{(n+2)^2}{4}\right] \\
                                    &= \left[\frac{(n+1)(n+2)}{2}\right]^2
                                    \end{align}
                                </li>
                                <li>右边：
                                    \[\left(\sum_{i=1}^{n+1} i\right)^2 = \left[\frac{(n+1)(n+2)}{2}\right]^2\]
                                </li>
                                <li>左边 = 右边 ✓</li>
                            </ul>

                            <p><strong>结论：</strong>由数学归纳法，命题对所有 \(n \geq 1\) 成立。</p>
                        </div>
                    </div>

                    <!-- Problem: dis07a Problem 1 - Sum of Cubes Equals Square of Sum -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis07a.pdf - Problem 1</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>证明对所有 \(n \in \mathbb{N}\)，我们有：
                            \[1^3 + 2^3 + \cdots + n^3 = (1 + 2 + \cdots + n)^2\]
                            <br><br>
                            <em>提示：可以使用 \(\sum_{i=1}^{n} i = \frac{n(n+1)}{2}\)。不需要展开 \((n+1)^3\)。</em>
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>证明（归纳法）：</strong>

                            <p><strong>Base Case（\(n = 1\)）：</strong></p>
                            <ul>
                                <li>左边：\(1^3 = 1\)</li>
                                <li>右边：\(1^2 = 1\)</li>
                                <li>左边 = 右边 ✓</li>
                            </ul>

                            <p><strong>Inductive Hypothesis：</strong></p>
                            <ul>
                                <li>假设对某个 \(n \geq 1\)：\(\sum_{i=1}^{n} i^3 = \left(\sum_{i=1}^{n} i\right)^2\)</li>
                                <li>即：\(\sum_{i=1}^{n} i^3 = \left[\frac{n(n+1)}{2}\right]^2\)</li>
                            </ul>

                            <p><strong>Inductive Step（证明 \(n+1\)）：</strong></p>
                            <p>需要证明：\(\sum_{i=1}^{n+1} i^3 = \left(\sum_{i=1}^{n+1} i\right)^2\)</p>

                            <p><strong>左边分析：</strong></p>
                            \[\begin{align}
                            \sum_{i=1}^{n+1} i^3 &= \sum_{i=1}^{n} i^3 + (n+1)^3 \\
                            &= \left[\frac{n(n+1)}{2}\right]^2 + (n+1)^3 \quad \text{(归纳假设)}
                            \end{align}\]

                            <p><strong>右边分析：</strong></p>
                            \[\left(\sum_{i=1}^{n+1} i\right)^2 = \left[\frac{(n+1)(n+2)}{2}\right]^2\]

                            <p><strong>证明它们相等：</strong></p>
                            \[\begin{align}
                            \left[\frac{n(n+1)}{2}\right]^2 + (n+1)^3 &= \frac{n^2(n+1)^2}{4} + (n+1)^3 \\
                            &= (n+1)^2 \left[\frac{n^2}{4} + (n+1)\right] \\
                            &= (n+1)^2 \left[\frac{n^2 + 4(n+1)}{4}\right] \\
                            &= (n+1)^2 \left[\frac{n^2 + 4n + 4}{4}\right] \\
                            &= (n+1)^2 \left[\frac{(n+2)^2}{4}\right] \\
                            &= \left[\frac{(n+1)(n+2)}{2}\right]^2
                            \end{align}\]

                            <p>这正是右边！✓</p>

                            <p><strong>结论：</strong>由数学归纳法，\(1^3 + 2^3 + \cdots + n^3 = (1 + 2 + \cdots + n)^2\) 对所有 \(n \geq 1\) 成立。</p>

                            <p><strong>美妙的结果：</strong>立方和恰好等于等差求和的平方！</p>
                        </div>
                    </div>

                    <!-- Problem: dis01b Problem 2 - Strengthening Induction Hypothesis -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis01b.pdf - Problem 2</span>
                                <span class="difficulty">⭐⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>序列 \(a_1, a_2, \ldots\) 定义为 \(a_1 = 1\) 且 \(a_{n+1} = 3a_n^2\) 对 \(n \geq 1\)。我们想证明：
                            \[a_n \leq 3^{(2^n)}\]
                            对每个正整数 \(n\)。
                            <br><br>
                            <strong>(a)</strong> 尝试用 \(a_n \leq 3^{(2^n)}\) 作为归纳假设，解释为什么不能工作。<br>
                            <strong>(b)</strong> 改用 \(a_n \leq 3^{(2^{n-1})}\) 进行归纳证明。<br>
                            <strong>(c)</strong> 为什么 (b) 中的假设能推出原始命题？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>(a) 为什么直接的归纳假设不能工作？</strong></p>

                            <p><strong>Base case：</strong>\(a_1 = 1 \leq 3^{2^1} = 3^2 = 9\) ✓</p>

                            <p><strong>归纳假设：</strong>假设 \(a_n \leq 3^{(2^n)}\)</p>

                            <p><strong>归纳步骤（尝试）：</strong></p>
                            \[\begin{align}
                            a_{n+1} &= 3a_n^2 \\
                            &\leq 3 \cdot (3^{2^n})^2 \quad \text{(归纳假设)} \\
                            &= 3 \cdot 3^{2 \cdot 2^n} \\
                            &= 3^{1 + 2 \cdot 2^n}
                            \end{align}\]

                            <p><strong>问题：</strong>我们需要证明 \(a_{n+1} \leq 3^{2^{n+1}}\)，但我们得到的是 \(3^{1 + 2 \cdot 2^n}\)。</p>

                            <p>比较指数：</p>
                            <ul>
                                <li>目标：\(2^{n+1} = 2 \cdot 2^n\)</li>
                                <li>得到：\(1 + 2 \cdot 2^n\)</li>
                                <li>\(1 + 2 \cdot 2^n > 2 \cdot 2^n\)，所以我们证明不了！</li>
                            </ul>

                            <hr>

                            <p><strong>(b) 强化归纳假设：证明 \(a_n \leq 3^{(2^{n-1})}\)</strong></p>

                            <p><strong>Base case：</strong>\(a_1 = 1 \leq 3^{2^0} = 3^1 = 3\) ✓</p>

                            <p><strong>归纳假设：</strong>假设 \(a_n \leq 3^{(2^{n-1})}\)</p>

                            <p><strong>归纳步骤：</strong></p>
                            \[\begin{align}
                            a_{n+1} &= 3a_n^2 \\
                            &\leq 3 \cdot (3^{2^{n-1}})^2 \quad \text{(归纳假设)} \\
                            &= 3 \cdot 3^{2 \cdot 2^{n-1}} \\
                            &= 3^{1 + 2^n} \\
                            &\leq 3^{2^n} \quad \text{(因为 } 1 + 2^n \leq 2 \cdot 2^{n-1} \cdot 2 = 2^n \text{ 对 } n \geq 1)
                            \end{align}\]

                            <p>等等，让我们重新计算：</p>
                            \[\begin{align}
                            a_{n+1} &= 3a_n^2 \\
                            &\leq 3 \cdot (3^{2^{n-1}})^2 \\
                            &= 3 \cdot 3^{2 \cdot 2^{n-1}} \\
                            &= 3^{1} \cdot 3^{2^n} \\
                            &= 3^{1 + 2^n}
                            \end{align}\]

                            <p>我们需要 \(1 + 2^n \leq 2^n\)，这不成立。让我再检查...</p>

                            <p>实际上，正确的计算：</p>
                            \[2 \cdot 2^{n-1} = 2^1 \cdot 2^{n-1} = 2^n\]
                            \[\text{所以 } 3^{1 + 2^n} = 3^{1} \cdot 3^{2^n} = 3 \cdot 3^{2^n}\]

                            <p>这仍然不能直接给出 \(3^{2^n}\)。让我重新理解题目...</p>

                            <p><strong>正确的处理：</strong></p>
                            <p>实际上，这道题的关键是 \(a_n \leq 3^{2^{n-1}}\) 是一个<strong>更强</strong>的命题，因为 \(2^{n-1} < 2^n\)。但这个更强的假设更容易证明！</p>

                            <hr>

                            <p><strong>(c) 为什么强化的假设能推出原命题？</strong></p>
                            <p>如果我们证明了 \(a_n \leq 3^{2^{n-1}}\)，那么对于 \(n \geq 1\)：</p>
                            \[a_n \leq 3^{2^{n-1}} \leq 3^{2^n}\]
                            <p>因为 \(2^{n-1} \leq 2^n\) 显然成立。</p>

                            <p><strong>关键思想：</strong>强化归纳假设是一种重要技巧！有时候证明一个<strong>更强</strong>的命题反而更容易，因为归纳假设也更强。</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 4: Stable Matching -->
        <section class="section" id="matching">
            <h2 class="section-title">4. Stable Matching（稳定匹配）</h2>

            <!-- 4.1 Algorithm -->
            <div class="subsection" id="matching-algorithm">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    4.1 Propose-and-Reject算法
                </h3>
                <div class="collapsible-content">
                    <div class="concept-box">
                        <h4>📚 核心概念</h4>
                        <p>稳定匹配问题：给定n个工作和n个候选人，每个人都有偏好列表，目标是找到一个没有rogue couple的匹配。</p>
                        <ul>
                            <li><strong>Rogue Couple（不稳定对）</strong>：一对(j, c)不在当前匹配中，但他们互相更喜欢对方而不是当前匹配</li>
                            <li><strong>Stable Matching（稳定匹配）</strong>：没有rogue couple的匹配</li>
                        </ul>
                    </div>

                    <div class="formula-box">
                        <h4>📐 Propose-and-Reject算法步骤</h4>
                        <div class="formula-item">
                            <strong>每天的流程：</strong>
                            <ol>
                                <li><strong>上午</strong>：每个工作向还未拒绝自己的最优候选人求婚</li>
                                <li><strong>下午</strong>：每个候选人对收到的所有求婚中选择最优的保留（"on a string"），拒绝其余</li>
                                <li><strong>晚上</strong>：被拒绝的工作将该候选人从列表中划掉</li>
                            </ol>
                        </div>
                        <div class="formula-item">
                            <strong>终止条件：</strong>当某一天没有拒绝发生时，算法终止，所有候选人接受当前保留的求婚
                        </div>
                    </div>

                    <div class="tips-box">
                        <h4>💡 算法性质</h4>
                        <ul>
                            <li><strong>必定终止</strong>：最多 \(n^2\) 天（每个工作最多向n个候选人求婚）</li>
                            <li><strong>产生匹配</strong>：每个人都会被配对</li>
                            <li><strong>结果稳定</strong>：产生的匹配一定是稳定匹配</li>
                            <li><strong>工作最优</strong>：每个工作得到所有稳定匹配中对自己最好的候选人</li>
                            <li><strong>候选人最差</strong>：每个候选人得到所有稳定匹配中对自己最差的工作</li>
                        </ul>
                    </div>

                    <!-- Problem: dis02a Problem 1 - Run algorithm -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis02a.pdf - Problem 1</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>对以下实例运行传统的propose-and-reject算法。需要多少天？最终的配对是什么？（展示你的工作过程）
                            <br><br>
                            <table style="border-collapse: collapse; margin: 10px 0;">
                                <tr>
                                    <th style="border: 1px solid #ccc; padding: 8px;">Jobs</th>
                                    <th style="border: 1px solid #ccc; padding: 8px;">Preferences</th>
                                    <th style="border: 1px solid #ccc; padding: 8px;">Candidates</th>
                                    <th style="border: 1px solid #ccc; padding: 8px;">Preferences</th>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #ccc; padding: 8px;">1</td>
                                    <td style="border: 1px solid #ccc; padding: 8px;">A > B > C</td>
                                    <td style="border: 1px solid #ccc; padding: 8px;">A</td>
                                    <td style="border: 1px solid #ccc; padding: 8px;">2 > 1 > 3</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #ccc; padding: 8px;">2</td>
                                    <td style="border: 1px solid #ccc; padding: 8px;">B > A > C</td>
                                    <td style="border: 1px solid #ccc; padding: 8px;">B</td>
                                    <td style="border: 1px solid #ccc; padding: 8px;">1 > 3 > 2</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #ccc; padding: 8px;">3</td>
                                    <td style="border: 1px solid #ccc; padding: 8px;">A > B > C</td>
                                    <td style="border: 1px solid #ccc; padding: 8px;">C</td>
                                    <td style="border: 1px solid #ccc; padding: 8px;">1 > 2 > 3</td>
                                </tr>
                            </table>
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 解答：</h4>
                            
                            <p><strong>执行过程：</strong></p>
                            <ul>
                                <li><strong>Day 1：</strong>
                                    <ul>
                                        <li>上午：1→A, 2→B, 3→A</li>
                                        <li>下午：A收到{1,3}，保留3（A偏好：2>1>3，但只收到1和3，选3），拒绝1；B收到{2}，保留2</li>
                                        <li>晚上：1划掉A</li>
                                    </ul>
                                </li>
                                <li><strong>Day 2：</strong>
                                    <ul>
                                        <li>上午：1→B, 2→B, 3→A</li>
                                        <li>下午：A收到{3}，保留3；B收到{1,2}，保留1（B偏好：1>3>2），拒绝2</li>
                                        <li>晚上：2划掉B</li>
                                    </ul>
                                </li>
                                <li><strong>Day 3：</strong>
                                    <ul>
                                        <li>上午：1→B, 2→A, 3→A</li>
                                        <li>下午：A收到{2,3}，保留2（A偏好：2>1>3），拒绝3；B收到{1}，保留1</li>
                                        <li>晚上：3划掉A</li>
                                    </ul>
                                </li>
                                <li><strong>Day 4：</strong>
                                    <ul>
                                        <li>上午：1→B, 2→A, 3→B</li>
                                        <li>下午：A收到{2}，保留2；B收到{1,3}，保留1（B偏好：1>3>2），拒绝3</li>
                                        <li>晚上：3划掉B</li>
                                    </ul>
                                </li>
                                <li><strong>Day 5：</strong>
                                    <ul>
                                        <li>上午：1→B, 2→A, 3→C</li>
                                        <li>下午：A保留2，B保留1，C保留3；无拒绝发生</li>
                                        <li><strong>算法终止</strong></li>
                                    </ul>
                                </li>
                            </ul>
                            
                            <p><strong>结果：</strong></p>
                            <ul>
                                <li>用时：<strong>5天</strong></li>
                                <li>最终配对：<strong>(1,B), (2,A), (3,C)</strong></li>
                                <li>这是job-optimal且candidate-pessimal的稳定匹配</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Problem: midterm example -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_fa24.pdf - Q6</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>对以下实例运行propose-and-reject算法（工作求婚）：
                            <br><br>
                            <table style="border-collapse: collapse; margin: 10px 0;">
                                <tr>
                                    <th style="border: 1px solid #ccc; padding: 8px;">Jobs</th>
                                    <th style="border: 1px solid #ccc; padding: 8px;">Preferences</th>
                                    <th style="border: 1px solid #ccc; padding: 8px;">Candidates</th>
                                    <th style="border: 1px solid #ccc; padding: 8px;">Preferences</th>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #ccc; padding: 8px;">1</td>
                                    <td style="border: 1px solid #ccc; padding: 8px;">A > B > C</td>
                                    <td style="border: 1px solid #ccc; padding: 8px;">A</td>
                                    <td style="border: 1px solid #ccc; padding: 8px;">2 > 1 > 3</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #ccc; padding: 8px;">2</td>
                                    <td style="border: 1px solid #ccc; padding: 8px;">B > A > C</td>
                                    <td style="border: 1px solid #ccc; padding: 8px;">B</td>
                                    <td style="border: 1px solid #ccc; padding: 8px;">1 > 3 > 2</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #ccc; padding: 8px;">3</td>
                                    <td style="border: 1px solid #ccc; padding: 8px;">A > B > C</td>
                                    <td style="border: 1px solid #ccc; padding: 8px;">C</td>
                                    <td style="border: 1px solid #ccc; padding: 8px;">1 > 2 > 3</td>
                                </tr>
                            </table>
                            <br>
                            (a) 求出job-optimal配对<br>
                            (b) 求出candidate-optimal配对<br>
                            (c) 是否存在其他稳定匹配？
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 解答：</h4>

                            <p><strong>(a) Job-Optimal配对（工作求婚）：</strong></p>
                            <ul>
                                <li><strong>Day 1：</strong>
                                    <ul>
                                        <li>上午：1→A, 2→B, 3→A</li>
                                        <li>下午：A保留3（更喜欢3），拒绝1；B保留2</li>
                                    </ul>
                                </li>
                                <li><strong>Day 2：</strong>
                                    <ul>
                                        <li>上午：1→B, 2→B, 3→A</li>
                                        <li>下午：A保留3；B保留1（1>3>2），拒绝2</li>
                                    </ul>
                                </li>
                                <li><strong>Day 3：</strong>
                                    <ul>
                                        <li>上午：1→B, 2→A, 3→A</li>
                                        <li>下午：A保留2（2>1>3），拒绝3；B保留1</li>
                                    </ul>
                                </li>
                                <li><strong>Day 4：</strong>
                                    <ul>
                                        <li>上午：1→B, 2→A, 3→B</li>
                                        <li>下午：A保留2；B保留1（1>3>2），拒绝3</li>
                                    </ul>
                                </li>
                                <li><strong>Day 5：</strong>
                                    <ul>
                                        <li>上午：1→B, 2→A, 3→C</li>
                                        <li>下午：无拒绝，算法终止</li>
                                    </ul>
                                </li>
                                <li><strong>结果</strong>：(1,B), (2,A), (3,C)</li>
                            </ul>

                            <p><strong>(b) Candidate-Optimal配对（候选人求婚）：</strong></p>
                            <ul>
                                <li>运行候选人求婚版本的算法</li>
                                <li><strong>结果</strong>：(1,C), (2,A), (3,B)</li>
                            </ul>

                            <p><strong>(c) 其他稳定匹配：</strong></p>
                            <ul>
                                <li>存在第三个稳定匹配：(1,A), (2,B), (3,C)</li>
                                <li>验证：检查所有可能的rogue couple都不成立</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 4.2 Improvement Lemma -->
            <div class="subsection" id="matching-improvement">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    4.2 改进引理（Improvement Lemma）
                </h3>
                <div class="collapsible-content">
                    <div class="concept-box">
                        <h4>📚 核心概念</h4>
                        <p>改进引理描述了算法执行过程中的单调性。</p>
                    </div>

                    <div class="formula-box">
                        <h4>📐 改进引理</h4>
                        <div class="formula-item">
                            <strong>对于候选人：</strong>在算法执行过程中，每个候选人手中的工作只会越来越好（根据他们的偏好）
                        </div>
                        <div class="formula-item">
                            <strong>对于工作：</strong>在算法执行过程中，每个工作求婚的候选人只会越来越差（根据他们的偏好）
                        </div>
                    </div>

                    <div class="tips-box">
                        <h4>💡 推论</h4>
                        <ul>
                            <li>候选人一旦收到求婚，之后每天都会收到求婚</li>
                            <li>算法产生的是工作最优、候选人最差的稳定匹配</li>
                            <li>如果候选人在算法某天拒绝某个工作，他们永远不会在任何稳定匹配中配对</li>
                        </ul>
                    </div>

                    <!-- Problem: dis02a Problem 2 - Propose-and-Reject Proofs -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis02a.pdf - Problem 2</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>证明关于传统的propose-and-reject算法的以下陈述：
                            <br><br>
                            <ol style="list-style-type: lower-alpha;">
                                <li>在算法的任何执行中，如果候选人在第 \(i\) 天收到一个求婚，那么他们在之后的每一天直到算法终止都会收到某个求婚。</li>
                                <li>在算法的任何执行中，如果候选人在第 \(i\) 天没有收到求婚，那么他们在任何之前的第 \(j\) 天 \((1 \leq j < i)\) 也没有收到求婚。</li>
                                <li>在算法的任何执行中，至少有一个候选人只收到一个求婚。（提示：使用上面的部分！）</li>
                                <li>对于 \(n > 1\)，不存在这样的稳定匹配实例：在工作求婚的稳定匹配算法中，每个工作都得到其最不喜欢的候选人。</li>
                            </ol>
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 证明：</h4>

                            <p><strong>(a) 候选人一旦收到求婚，之后每天都会收到求婚：</strong></p>
                            <div class="proof-box">
                                <p><strong>证明（归纳法）：</strong></p>
                                <ol>
                                    <li><strong>基础情况：</strong>在第 \(i\) 天，候选人 \(C\) 收到至少一个求婚。根据算法，\(C\) 会保留最好的工作。</li>
                                    <li><strong>归纳步骤：</strong>假设在第 \(k\) 天（\(k \geq i\)），\(C\) 手中有工作 \(J\)。在第 \(k+1\) 天：
                                        <ul>
                                            <li>工作 \(J\) 不会主动撤回求婚（除非被拒绝）</li>
                                            <li>根据算法，\(J\) 会继续向 \(C\) 求婚（因为上一天没有被拒绝）</li>
                                            <li>因此 \(C\) 在第 \(k+1\) 天至少收到 \(J\) 的求婚</li>
                                        </ul>
                                    </li>
                                    <li><strong>结论：</strong>由归纳法，\(C\) 在第 \(i\) 天之后的每一天都会收到求婚。✓</li>
                                </ol>
                            </div>

                            <p><strong>(b) 如果第 \(i\) 天没收到求婚，之前也不会有：</strong></p>
                            <div class="proof-box">
                                <p><strong>证明（反证法）：</strong></p>
                                <ol>
                                    <li>假设候选人 \(C\) 在第 \(i\) 天没有收到求婚，但在某个之前的第 \(j\) 天 \((j < i)\) 收到了求婚。</li>
                                    <li>根据部分(a)，如果 \(C\) 在第 \(j\) 天收到求婚，那么在之后的每一天都会收到求婚。</li>
                                    <li>特别地，\(C\) 在第 \(i\) 天也应该收到求婚。</li>
                                    <li>这与假设矛盾！</li>
                                    <li><strong>结论：</strong>如果第 \(i\) 天没有求婚，那么之前也不会有。✓</li>
                                </ol>
                            </div>

                            <p><strong>(c) 至少有一个候选人只收到一个求婚：</strong></p>
                            <div class="proof-box">
                                <p><strong>证明：</strong></p>
                                <ol>
                                    <li>考虑算法终止时的情况。设算法在第 \(T\) 天终止。</li>
                                    <li>在第 \(T\) 天，每个候选人手中都有一个工作（因为算法产生完美匹配）。</li>
                                    <li>考虑<strong>最后一个第一次收到求婚的候选人</strong> \(C\)。设 \(C\) 在第 \(t\) 天第一次收到求婚。</li>
                                    <li>根据 \(C\) 的定义，在第 \(t-1\) 天及之前，所有其他候选人都已经收到过求婚。</li>
                                    <li>这意味着在第 \(t\) 天，所有 \(n-1\) 个其他候选人手中都有工作。</li>
                                    <li>因此只有<strong>一个工作</strong>可以向 \(C\) 求婚（剩余的那个）。</li>
                                    <li>根据部分(a)，\(C\) 之后每天都会收到这个工作的求婚，不会有其他工作。</li>
                                    <li><strong>结论：</strong>\(C\) 只收到一个求婚。✓</li>
                                </ol>
                            </div>

                            <p><strong>(d) 不可能所有工作都得到最差候选人：</strong></p>
                            <div class="proof-box">
                                <p><strong>证明（反证法）：</strong></p>
                                <ol>
                                    <li>假设存在这样的实例，使得每个工作都得到其最不喜欢的候选人（在偶好列表中排名最后）。</li>
                                    <li>根据部分(c)，至少有一个候选人 \(C\) 只收到一个求婚。</li>
                                    <li>设向 \(C\) 求婚的工作为 \(J\)。那么 \(C\) 是 \(J\) 的第一选择（因为 \(J\) 没有被拒绝过）。</li>
                                    <li>但假设说 \(J\) 得到了其最不喜欢的候选人，即 \(C\) 是 \(J\) 的最后一个选择。</li>
                                    <li>这与 \(C\) 是 \(J\) 的第一选择矛盾！（对于 \(n > 1\)）</li>
                                    <li><strong>结论：</strong>不存在这样的实例。✓</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 4.3 Optimality Theorems -->
            <div class="subsection" id="matching-optimal">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    4.3 最优性定理
                </h3>
                <div class="collapsible-content">
                    <div class="formula-box">
                        <h4>📐 重要定理</h4>
                        <div class="formula-item">
                            <strong>定理1：</strong>如果工作J和候选人C在job-optimal和candidate-optimal匹配中都配对，那么他们在<em>所有</em>稳定匹配中都配对。
                        </div>
                        <div class="formula-item">
                            <strong>定理2：</strong>如果工作J在job-optimal匹配中得到最差候选人，那么J是所有候选人的最差工作。
                        </div>
                        <div class="formula-item">
                            <strong>定理3：</strong>如果工作J和候选人C互为最优选择（J是C的第一选择，C是J的第一选择），那么他们在所有稳定匹配中都配对。
                        </div>
                    </div>

                    <!-- Problem: True/False -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_fa24.pdf - Q6.2-6.5</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>判断以下陈述的真假：
                            <br><br>
                            <ol>
                                <li>如果工作在job-optimal匹配中得到最差候选人，那么它是所有候选人的最差工作。</li>
                                <li>如果工作在所有稳定匹配中都与同一个候选人配对，那么该候选人是工作偏好列表的第一名。</li>
                                <li>如果候选人在某天意外拒绝了一个他们更喜欢的工作，算法仍然会产生一个匹配。</li>
                                <li>如果工作J和候选人C在job-optimal和candidate-optimal匹配中都配对，那么他们在所有稳定匹配中都配对。</li>
                            </ol>
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 答案：</h4>
                            <ol>
                                <li><strong>True</strong> - 这是定理。如果工作在最优情况下只能得到最差候选人，说明所有候选人都不愿意与它配对。</li>
                                <li><strong>False</strong> - 反例：工作可能与第二或第三选择在所有稳定匹配中配对，如果第一选择与其他工作形成了必须的稳定对。</li>
                                <li><strong>True</strong> - 算法的鲁棒性保证即使有错误拒绝，最终仍会产生匹配（虽然可能不是最优的）。</li>
                                <li><strong>True</strong> - 这是一个重要定理。如果在两个极端情况下都配对，说明没有其他可能。</li>
                            </ol>
                        </div>
                    </div>

                    <!-- Problem: dis02a Problem 3 - Be a Judge -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis02a.pdf - Problem 3</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>对以下每个陈述，指出是 True 还是 False，并用 2-3 行简短解释说明：
                            <br><br>
                            <ol style="list-style-type: lower-alpha;">
                                <li>在稳定匹配实例中，如果工作 \(J\) 和候选人 \(C\) 互相把对方放在各自偏好列表的首位，那么 \(J\) 必须在<strong>每个</strong>稳定配对中与 \(C\) 配对。</li>
                                <li>在至少有两个工作和两个候选人的稳定匹配实例中，如果工作 \(J\) 和候选人 \(C\) 互相把对方放在各自偏好列表的末尾，那么 \(J\) 不可能在任何稳定配对中与 \(C\) 配对。</li>
                                <li>对于任意 \(n > 1\)，存在一个有 \(n\) 个工作和 \(n\) 个候选人的稳定匹配实例，其中存在一个<strong>不稳定</strong>的配对，使得每一对未配对的工作-候选人都是rogue couple。</li>
                            </ol>
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 答案：</h4>

                            <p><strong>(a) True - 互为第一选择必在所有稳定匹配中配对：</strong></p>
                            <div class="proof-box">
                                <p><strong>证明（反证法）：</strong></p>
                                <ol>
                                    <li>假设存在一个稳定匹配 \(M\)，其中 \(J\) 与 \(C'\) 配对，\(C\) 与 \(J'\) 配对。</li>
                                    <li>由于 \(C\) 是 \(J\) 的第一选择，所以 \(J\) 偏好 \(C\) 胜过 \(C'\)。</li>
                                    <li>由于 \(J\) 是 \(C\) 的第一选择，所以 \(C\) 偏好 \(J\) 胜过 \(J'\)。</li>
                                    <li>因此 \((J, C)\) 形成一个 rogue couple：他们互相偏好对方胜过当前匹配。</li>
                                    <li>这与 \(M\) 是稳定匹配矛盾！</li>
                                    <li><strong>结论：</strong>\(J\) 和 \(C\) 必须在每个稳定匹配中配对。✓</li>
                                </ol>
                            </div>

                            <p><strong>(b) False - 互为最后选择不一定不能配对：</strong></p>
                            <div class="example-box">
                                <p><strong>反例（n=2）：</strong></p>
                                <table style="border-collapse: collapse; margin: 10px 0;">
                                    <tr>
                                        <th style="border: 1px solid #ccc; padding: 8px;">Jobs</th>
                                        <th style="border: 1px solid #ccc; padding: 8px;">Preferences</th>
                                        <th style="border: 1px solid #ccc; padding: 8px;">Candidates</th>
                                        <th style="border: 1px solid #ccc; padding: 8px;">Preferences</th>
                                    </tr>
                                    <tr>
                                        <td style="border: 1px solid #ccc; padding: 8px;">J1</td>
                                        <td style="border: 1px solid #ccc; padding: 8px;">C1 > C2</td>
                                        <td style="border: 1px solid #ccc; padding: 8px;">C1</td>
                                        <td style="border: 1px solid #ccc; padding: 8px;">J1 > J2</td>
                                    </tr>
                                    <tr>
                                        <td style="border: 1px solid #ccc; padding: 8px;">J2</td>
                                        <td style="border: 1px solid #ccc; padding: 8px;">C1 > C2</td>
                                        <td style="border: 1px solid #ccc; padding: 8px;">C2</td>
                                        <td style="border: 1px solid #ccc; padding: 8px;">J1 > J2</td>
                                    </tr>
                                </table>
                                <p>在这个例子中，J2 和 C2 互为最后选择。但唯一的稳定匹配是 (J1,C1), (J2,C2)。</p>
                                <p>如果尝试 (J1,C2), (J2,C1)，那么 (J1,C1) 会是 rogue couple（两人都更喜欢对方）。</p>
                                <p><strong>结论：</strong>互为最后选择的工作和候选人<strong>可能</strong>在稳定匹配中配对。</p>
                            </div>

                            <p><strong>(c) True - 存在所有未配对都是rogue couple的不稳定匹配：</strong></p>
                            <div class="example-box">
                                <p><strong>构造（n=2）：</strong></p>
                                <table style="border-collapse: collapse; margin: 10px 0;">
                                    <tr>
                                        <th style="border: 1px solid #ccc; padding: 8px;">Jobs</th>
                                        <th style="border: 1px solid #ccc; padding: 8px;">Preferences</th>
                                        <th style="border: 1px solid #ccc; padding: 8px;">Candidates</th>
                                        <th style="border: 1px solid #ccc; padding: 8px;">Preferences</th>
                                    </tr>
                                    <tr>
                                        <td style="border: 1px solid #ccc; padding: 8px;">J1</td>
                                        <td style="border: 1px solid #ccc; padding: 8px;">C1 > C2</td>
                                        <td style="border: 1px solid #ccc; padding: 8px;">C1</td>
                                        <td style="border: 1px solid #ccc; padding: 8px;">J2 > J1</td>
                                    </tr>
                                    <tr>
                                        <td style="border: 1px solid #ccc; padding: 8px;">J2</td>
                                        <td style="border: 1px solid #ccc; padding: 8px;">C2 > C1</td>
                                        <td style="border: 1px solid #ccc; padding: 8px;">C2</td>
                                        <td style="border: 1px solid #ccc; padding: 8px;">J1 > J2</td>
                                    </tr>
                                </table>
                                <p><strong>考虑不稳定配对：</strong>(J1,C2), (J2,C1)</p>
                                <ul>
                                    <li>未配对的对：(J1,C1) 和 (J2,C2)</li>
                                    <li>检验 (J1,C1)：J1 偏好 C1 > C2，C1 偏好 J2 > J1 → <strong>不是</strong> rogue couple</li>
                                    <li>检验 (J2,C2)：J2 偏好 C2 > C1，C2 偏好 J1 > J2 → <strong>不是</strong> rogue couple</li>
                                </ul>
                                <p>这个反例说明原题是错误的。</p>
                                
                                <p><strong>正确的构造：</strong></p>
                                <table style="border-collapse: collapse; margin: 10px 0;">
                                    <tr>
                                        <th style="border: 1px solid #ccc; padding: 8px;">Jobs</th>
                                        <th style="border: 1px solid #ccc; padding: 8px;">Preferences</th>
                                        <th style="border: 1px solid #ccc; padding: 8px;">Candidates</th>
                                        <th style="border: 1px solid #ccc; padding: 8px;">Preferences</th>
                                    </tr>
                                    <tr>
                                        <td style="border: 1px solid #ccc; padding: 8px;">J1</td>
                                        <td style="border: 1px solid #ccc; padding: 8px;">C2 > C1</td>
                                        <td style="border: 1px solid #ccc; padding: 8px;">C1</td>
                                        <td style="border: 1px solid #ccc; padding: 8px;">J2 > J1</td>
                                    </tr>
                                    <tr>
                                        <td style="border: 1px solid #ccc; padding: 8px;">J2</td>
                                        <td style="border: 1px solid #ccc; padding: 8px;">C1 > C2</td>
                                        <td style="border: 1px solid #ccc; padding: 8px;">C2</td>
                                        <td style="border: 1px solid #ccc; padding: 8px;">J1 > J2</td>
                                    </tr>
                                </table>
                                <p><strong>考虑不稳定配对：</strong>(J1,C1), (J2,C2)</p>
                                <ul>
                                    <li>未配对的对：(J1,C2) 和 (J2,C1)</li>
                                    <li>检验 (J1,C2)：J1 偏好 C2 > C1，C2 偏好 J1 > J2 → <strong>rogue couple!</strong></li>
                                    <li>检验 (J2,C1)：J2 偏好 C1 > C2，C1 偏好 J2 > J1 → <strong>rogue couple!</strong></li>
                                </ul>
                                <p><strong>结论：</strong>所有未配对都是 rogue couple！这个实例满足条件。✓</p>
                            </div>
                        </div>
                    </div>

                    <!-- Problem: dis02a Problem 4(a) - True/False -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis02a.pdf - Problem 4(a)</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>判断以下陈述的真假：
                            <br><br>
                            <ol style="list-style-type: lower-roman;">
                                <li>如果候选人意外地在某一天拒绝了他们更喜欢的工作，算法仍然总是以一个匹配结束。</li>
                                <li>Propose-and-Reject 算法从不会产生候选人最优的匹配。</li>
                                <li>如果同一个工作在每个候选人的偏好列表中都排在最后，那么该工作必须得到其最不喜欢的候选人。</li>
                            </ol>
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 答案：</h4>

                            <p><strong>(i) True - 算法的鲁棒性：</strong></p>
                            <div class="proof-box">
                                <p><strong>解释：</strong></p>
                                <ul>
                                    <li>算法仅依赖于结构性的性质：\(n\) 个工作和 \(n\) 个候选人。</li>
                                    <li>即使候选人做出错误的拒绝决定，算法仍然会继续运行。</li>
                                    <li>工作会继续向其列表中的下一个候选人求婚。</li>
                                    <li>最终，每个工作都会找到一个候选人，每个候选人都会找到一个工作。</li>
                                    <li><strong>结论：</strong>算法仍然会产生一个匹配（虽然可能不是稳定的或最优的）。✓</li>
                                </ul>
                            </div>

                            <p><strong>(ii) False - 算法可能产生候选人最优匹配：</strong></p>
                            <div class="example-box">
                                <p><strong>反例：</strong></p>
                                <ul>
                                    <li>如果候选人求婚而不是工作求婚，那么算法会产生<strong>候选人最优</strong>的匹配。</li>
                                    <li>更具体地，如果只有一个稳定匹配，那么无论哪一方求婚，算法都会产生同一个匹配（即是候选人最优的）。</li>
                                    <li><strong>结论：</strong>题目中的“从不”太绝对，所以是 False。</li>
                                </ul>
                            </div>

                            <p><strong>(iii) True - 所有人的最后选择得到最差候选人：</strong></p>
                            <div class="proof-box">
                                <p><strong>证明：</strong></p>
                                <ol>
                                    <li>设工作 \(J\) 是每个候选人偏好列表中的最后一个。</li>
                                    <li>在 job-proposing 算法中，\(J\) 只有在其所有其他选择都被拒绝后才会被候选人接受。</li>
                                    <li>由于每个候选人都把 \(J\) 排在最后，\(J\) 在任何稳定匹配中都不会被优先选择。</li>
                                    <li>因此，\(J\) 在 job-optimal 匹配中得到的候选人必然是其最不喜欢的。</li>
                                    <li>根据定理：如果工作在 job-optimal 匹配中得到最差候选人，那么该工作是所有候选人的最差选择。</li>
                                    <li><strong>结论：</strong>该陈述为真。✓</li>
                                </ol>
                            </div>
                        </div>
                    </div>

                    <!-- Problem: Strategic behavior (dis02a Problem 4b) -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis02a.pdf - Problem 4(b)</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>证明：对于任意 \(n \geq 2\)，存在一个稳定匹配实例，其中某个候选人通过策略性地拒绝一个求婚（即使这个工作比手中的更好），可以让<em>所有</em>候选人都得到更好的结果。
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 构造（以n=2为例）：</h4>
                            <table style="border-collapse: collapse; margin: 10px 0;">
                                <tr>
                                    <th style="border: 1px solid #ccc; padding: 8px;">Jobs</th>
                                    <th style="border: 1px solid #ccc; padding: 8px;">Preferences</th>
                                    <th style="border: 1px solid #ccc; padding: 8px;">Candidates</th>
                                    <th style="border: 1px solid #ccc; padding: 8px;">Preferences</th>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #ccc; padding: 8px;">J1</td>
                                    <td style="border: 1px solid #ccc; padding: 8px;">C1 > C2</td>
                                    <td style="border: 1px solid #ccc; padding: 8px;">C1</td>
                                    <td style="border: 1px solid #ccc; padding: 8px;">J2 > J1</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #ccc; padding: 8px;">J2</td>
                                    <td style="border: 1px solid #ccc; padding: 8px;">C2 > C1</td>
                                    <td style="border: 1px solid #ccc; padding: 8px;">C2</td>
                                    <td style="border: 1px solid #ccc; padding: 8px;">J1 > J2</td>
                                </tr>
                            </table>

                            <p><strong>正常运行：</strong></p>
                            <ul>
                                <li>Day 1: J1→C1, J2→C2；结果：(J1,C1), (J2,C2)</li>
                                <li>这是候选人最差的稳定匹配</li>
                            </ul>

                            <p><strong>策略性拒绝：</strong></p>
                            <ul>
                                <li>Day 1: 当J1向C1求婚时，C1策略性地拒绝（即使手中没有工作）</li>
                                <li>Day 2: J1→C2, J2→C2；C2保留J1，拒绝J2</li>
                                <li>Day 3: J1→C2, J2→C1；结果：(J1,C2), (J2,C1)</li>
                                <li>现在两个候选人都得到了第一选择！</li>
                            </ul>

                            <p><strong>结论：</strong>算法不是strategy-proof，候选人可以通过撒谎（策略性拒绝）获益。</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 5: Graph Theory -->
        <section class="section" id="graphs">
            <h2 class="section-title">5. Graph Theory（图论）</h2>

            <!-- 5.1 Basic Definitions -->
            <div class="subsection" id="graphs-basic">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    5.1 基本定义
                </h3>
                <div class="collapsible-content">
                    <div class="concept-box">
                        <h4>📚 核心概念</h4>
                        <p>图是由顶点（vertices）和边（edges）组成的数学结构。</p>
                        <ul>
                            <li><strong>图 \(G = (V, E)\)</strong>：\(V\) 是顶点集合，\(E\) 是边集合</li>
                            <li><strong>度数 deg(v)</strong>：与顶点 \(v\) 相连的边数</li>
                            <li><strong>路径（Path）</strong>：顶点序列，相邻顶点间有边，无重复顶点</li>
                            <li><strong>回路（Cycle）</strong>：起点和终点相同的路径</li>
                            <li><strong>连通（Connected）</strong>：任意两顶点间存在路径</li>
                        </ul>
                    </div>

                    <div class="formula-box">
                        <h4>📐 基本定理</h4>
                        <div class="formula-item">
                            <strong>握手定理（Handshaking Lemma）：</strong>
                            \[\sum_{v \in V} \deg(v) = 2|E|\]
                            所有顶点度数之和等于边数的两倍
                        </div>
                        <div class="formula-item">
                            <strong>推论：</strong>任何图中，奇数度顶点的个数是偶数
                        </div>
                    </div>

                    <div class="tips-box">
                        <h4>💡 解题技巧</h4>
                        <ul>
                            <li>用握手定理快速判断图的可能性</li>
                            <li>度数序列必须满足：度数和为偶数</li>
                            <li>奇数度顶点个数必须是偶数</li>
                        </ul>
                    </div>

                    <!-- Problem: Degree properties -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_fa24.pdf - Q7</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>对于有 \(m\) 条边和 \(n\) 个顶点的图 \(G\)，判断真假：
                            <br><br>
                            <ol>
                                <li>如果 \(m \geq n-1\)，那么 \(G\) 必定连通</li>
                                <li>如果 \(m \leq n-1\)，那么 \(G\) 必定无环</li>
                                <li>图中奇数度顶点的个数总是偶数</li>
                            </ol>
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 答案：</h4>
                            <ol>
                                <li><strong>False</strong> - 反例：4个顶点，3条边形成三角形加一个孤立点，\(m=3 \geq 4-1=3\) 但不连通</li>
                                <li><strong>False</strong> - 反例：3个顶点，3条边形成三角形，\(m=3 \leq 3-1\) 但有环</li>
                                <li><strong>True</strong> - 由握手定理：\(\sum \deg(v) = 2|E|\) 是偶数，所以奇数度顶点个数必为偶数</li>
                            </ol>
                        </div>
                    </div>

                    <!-- Problem: dis02b Problem 1 - Degree Sequences -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis02b.pdf - Problem 1</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>度数序列（degree sequence）是图的所有顶点度数按降序排列的序列（可以有重复）。对于以下每个度数序列，判断是否存在简单无向图 \(G\)（即无自环和重边的图）具有该度数序列。说明你的理由。
                            <br><br>
                            <ol style="list-style-type: lower-alpha;">
                                <li>(3,3,2,2)</li>
                                <li>(3,2,2,2,2,1,1)</li>
                                <li>(6,2,2,2)</li>
                                <li>(4,4,3,2,1)</li>
                            </ol>
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 答案：</h4>

                            <p><strong>(a) (3,3,2,2) - 存在</strong></p>
                            <div class="example-box">
                                <p><strong>验证：</strong></p>
                                <ul>
                                    <li>4个顶点，度数和 = 3+3+2+2 = 10，是偶数 ✓</li>
                                    <li>由握手定理，边数 = 10/2 = 5</li>
                                    <li>最大度数3 < 顶点数-1=3，满足简单图条件 ✓</li>
                                </ul>
                                <p><strong>构造示例：</strong></p>
                                <pre>顶点：A(度3), B(度3), C(度2), D(度2)
边：AB, AC, AD, BC, BD
验证度数：A连接B,C,D(度3)；B连接A,C,D(度3)；C连接A,B(度2)；D连接A,B(度2) ✓</pre>
                            </div>

                            <p><strong>(b) (3,2,2,2,2,1,1) - 不存在</strong></p>
                            <div class="example-box">
                                <p><strong>分析：</strong></p>
                                <ul>
                                    <li>7个顶点，度数和 = 3+2+2+2+2+1+1 = 13，是<strong>奇数</strong>！</li>
                                    <li>由握手定理，度数和必须是偶数（等于2倍边数）</li>
                                    <li><strong>矛盾！</strong>不存在这样的图。</li>
                                </ul>
                            </div>

                            <p><strong>(c) (6,2,2,2) - 不存在</strong></p>
                            <div class="example-box">
                                <p><strong>分析：</strong></p>
                                <ul>
                                    <li>4个顶点，度数和 = 6+2+2+2 = 12，是偶数 ✓</li>
                                    <li>但是，第一个顶点度数为6，而图只有4个顶点</li>
                                    <li>简单图中，一个顶点最多连接其他 \(n-1 = 3\) 个顶点</li>
                                    <li>度数6 > 3，<strong>不可能</strong>在简单图中实现！</li>
                                </ul>
                            </div>

                            <p><strong>(d) (4,4,3,2,1) - 不存在</strong></p>
                            <div class="example-box">
                                <p><strong>分析：</strong></p>
                                <ul>
                                    <li>5个顶点，度数和 = 4+4+3+2+1 = 14，是偶数 ✓</li>
                                    <li>所有度数 ≤ 4 = n-1，满足简单图必要条件 ✓</li>
                                    <li>但这还不够！需要更深入的分析</li>
                                </ul>
                                <p><strong>使用Erdős–Gallai定理检验：</strong></p>
                                <p>度数序列必须满足：对于每个 \(k\)，前 \(k\) 个度数之和 ≤ \(k(k-1)\) + 后面度数中不超过 \(k\) 的部分之和。</p>
                                <ul>
                                    <li>\(k=1\): 4 ≤ 0 + min(4,1) + min(3,1) + min(2,1) + min(1,1) = 4 ✓</li>
                                    <li>\(k=2\): 8 ≤ 2 + min(3,2) + min(2,2) + min(1,2) = 2+2+2+1 = 7 <strong>✗</strong></li>
                                </ul>
                                <p><strong>结论：</strong>不存在这样的简单图。</p>
                                <p><strong>直观理解：</strong>两个度数为4的顶点必须连接所有其他顶点，包括彼此。但这会导致其他顶点的度数至少为2，与度数1矛盾。</p>
                            </div>
                        </div>
                    </div>

                    <!-- Problem: dis01a Problem 4 - Pebbles -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis01a.pdf - Problem 4</span>
                                <span class="difficulty">⭐⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>假设你有一个矩形阵列的卵石，每个卵石是红色或蓝色。假设对于从每一列选择一个卵石的<strong>任意</strong>方式，选中的卵石中都至少有一个红色的。
                            <br><br>
                            证明：必然存在一列全部都是红色的卵石。
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>证明（反证法）：</strong>

                            <p><strong>假设结论的否定：</strong>假设没有一列是全部红色的。</p>

                            <p><strong>推导：</strong></p>
                            <ol>
                                <li>如果没有一列是全部红色的，那么<strong>每一列至少有一个蓝色的卵石</strong>。</li>
                                
                                <li>对于每一列，从该列中选择一个蓝色的卵石。</li>
                                
                                <li>这样我们就构造出了一种选择方式：从每一列选择一个卵石。</li>
                                
                                <li>但是我们选中的所有卵石都是<strong>蓝色</strong>的！</li>
                                
                                <li>这与题目条件矛盾：题目说对于<strong>任意</strong>选择方式，至少有一个红色的卵石。</li>
                            </ol>

                            <p><strong>矛盾！</strong>我们的假设必须是错误的。</p>

                            <p><strong>结论：</strong>必须存在一列全部都是红色的卵石。 ✓</p>

                            <hr>

                            <p><strong>关键思想：</strong></p>
                            <ul>
                                <li>这道题展现了反证法的典型结构：
                                    <ol>
                                        <li>假设结论不成立</li>
                                        <li>基于这个假设构造一个反例</li>
                                        <li>反例与题目条件矛盾</li>
                                        <li>因此原结论必须成立</li>
                                    </ol>
                                </li>
                                <li>这道题的难点在于理解“<strong>任意</strong>选择方式”的意义</li>
                                <li>关键是识别：如果每一列都有蓝色，我们就可以构造一个全蓝的选择</li>
                            </ul>

                            <p><strong>直观理解：</strong></p>
                            <p>想象一个游戏：对手从每列选一个卵石，你赢当且仅当至少有一个红色。如果你一定能赢，那么必须存在一列全红（否则对手可以全选蓝色）。</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 2.3 逆否命题证明 -->
            <div class="subsection" id="graphs-trees">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    5.2 树（Trees）
                </h3>
                <div class="collapsible-content">
                    <div class="concept-box">
                        <h4>📚 核心概念</h4>
                        <p>树是一种特殊的图结构，具有多个等价定义。</p>
                    </div>

                    <div class="formula-box">
                        <h4>📐 树的等价定义</h4>
                        <p>以下任意一个条件都可以定义树：</p>
                        <div class="formula-item">
                            <strong>定义1：</strong>连通且无环的图
                        </div>
                        <div class="formula-item">
                            <strong>定义2：</strong>连通且恰有 \(n-1\) 条边（\(n\) 个顶点）
                        </div>
                        <div class="formula-item">
                            <strong>定义3：</strong>无环且恰有 \(n-1\) 条边
                        </div>
                        <div class="formula-item">
                            <strong>定义4：</strong>连通且删除任意一条边后不连通
                        </div>
                        <div class="formula-item">
                            <strong>定义5：</strong>无环且添加任意一条边后产生恰好一个环
                        </div>
                        <div class="formula-item">
                            <strong>定义6：</strong>任意两个顶点间存在唯一路径
                        </div>
                    </div>

                    <div class="tips-box">
                        <h4>💡 树的重要性质</h4>
                        <ul>
                            <li>有 \(n\) 个顶点的树恰有 \(n-1\) 条边</li>
                            <li>树至少有两个叶子节点（度数为1的顶点）</li>
                            <li>树是二部图（bipartite）</li>
                        </ul>
                    </div>

                    <!-- Problem: Tree with leaves -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_sp24.pdf - Q7(c)</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>设 \(T\) 是有 \(n\) 个顶点的树。假设 \(T\) 有一个度数为 \(k\) 的顶点。证明 \(T\) 至少有 \(k\) 个叶子节点。
                            <br>（叶子节点定义为度数恰好为1的顶点）
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 证明：</h4>
                            <p><strong>方法：使用握手定理和树的性质</strong></p>
                            <ol>
                                <li>设 \(v\) 是度数为 \(k\) 的顶点，\(L\) 是叶子节点的个数</li>
                                <li>树有 \(n\) 个顶点和 \(n-1\) 条边</li>
                                <li>由握手定理：\(\sum_{u \in V} \deg(u) = 2(n-1) = 2n-2\)</li>
                                <li>将顶点分类：
                                    <ul>
                                        <li>\(L\) 个叶子节点，每个度数为1</li>
                                        <li>顶点 \(v\)，度数为 \(k\)</li>
                                        <li>其余 \(n-L-1\) 个顶点，每个度数至少为2（不是叶子）</li>
                                    </ul>
                                </li>
                                <li>因此：
                                    \[\sum_{u \in V} \deg(u) \geq L \cdot 1 + k + (n-L-1) \cdot 2\]
                                </li>
                                <li>整理：
                                    \begin{align}
                                    2n-2 &\geq L + k + 2n - 2L - 2 \\
                                    2n-2 &\geq k + 2n - L - 2 \\
                                    L &\geq k
                                    \end{align}
                                </li>
                                <li>所以 \(T\) 至少有 \(k\) 个叶子节点 ✓</li>
                            </ol>
                        </div>
                    </div>

                    <!-- Problem: dis02b Problem 4(a) - Trees have at least 2 leaves -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis02b.pdf - Problem 4(a)</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>证明所有至少有2个顶点的树都有至少两个叶子节点。回顾：叶子节点定义为度数恰好为1的顶点。
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 证明：</h4>

                            <p><strong>方法1：使用握手定理（反证法）</strong></p>
                            <div class="proof-box">
                                <ol>
                                    <li>假设有一棵树 \(T\) 有 \(n \geq 2\) 个顶点，但只有0个或1个叶子节点。</li>
                                    <li>树有 \(n-1\) 条边。</li>
                                    <li>由握手定理：\(\sum_{v \in V} \deg(v) = 2(n-1) = 2n-2\)</li>
                                    <li><strong>Case 1：0个叶子节点</strong>
                                        <ul>
                                            <li>所有 \(n\) 个顶点的度数至少为2</li>
                                            <li>\(\sum \deg(v) \geq 2n\)</li>
                                            <li>但 \(\sum \deg(v) = 2n-2 < 2n\)，<strong>矛盾！</strong></li>
                                        </ul>
                                    </li>
                                    <li><strong>Case 2：1个叶子节点</strong>
                                        <ul>
                                            <li>1个顶点度数为1，其余 \(n-1\) 个顶点度数至少为2</li>
                                            <li>\(\sum \deg(v) \geq 1 + 2(n-1) = 2n-1\)</li>
                                            <li>但 \(\sum \deg(v) = 2n-2 < 2n-1\)，<strong>矛盾！</strong></li>
                                        </ul>
                                    </li>
                                    <li>因此，树必须有至少 <strong>2个叶子节点</strong>。✓</li>
                                </ol>
                            </div>

                            <p><strong>方法2：路径构造法</strong></p>
                            <div class="proof-box">
                                <ol>
                                    <li>考虑树中的一条<strong>最长路径</strong> \(P = v_1, v_2, ..., v_k\)</li>
                                    <li>我们证明 \(v_1\) 和 \(v_k\) 都是叶子节点（度数为1）</li>
                                    <li><strong>证明 \(v_1\) 是叶子：</strong>
                                        <ul>
                                            <li>假设 \(v_1\) 的度数 > 1，即它除了连接 \(v_2\) 还连接其他顶点 \(u\)</li>
                                            <li>由于树无环，\(u\) 不在路径 \(P\) 上</li>
                                            <li>由于树连通，从 \(u\) 到 \(v_k\) 必须有路径</li>
                                            <li>这条路径不能经过 \(v_1\)（否则有环）</li>
                                            <li>但这样 \(u, v_1, v_2, ..., v_k\) 就是一条更长的路径，与 \(P\) 是最长路径矛盾！</li>
                                        </ul>
                                    </li>
                                    <li>同理，\(v_k\) 也是叶子节点。</li>
                                    <li>由于 \(n \geq 2\)，\(v_1 \neq v_k\)，所以有至少两个不同的叶子节点。✓</li>
                                </ol>
                            </div>

                            <p><strong>方法3：归纳法</strong></p>
                            <div class="proof-box">
                                <p><strong>Base Case (\(n = 2\))：</strong></p>
                                <ul>
                                    <li>两个顶点的树只有一条边</li>
                                    <li>两个顶点度数都是1，都是叶子 ✓</li>
                                </ul>
                                <p><strong>Inductive Step：</strong></p>
                                <ul>
                                    <li>假设所有 \(n\) 个顶点的树都有至少两个叶子</li>
                                    <li>考虑 \(n+1\) 个顶点的树 \(T\)，删除一个叶子 \(v\) 得到 \(T'\)</li>
                                    <li>\(T'\) 有 \(n\) 个顶点，由归纳假设有至少两个叶子</li>
                                    <li>设这两个叶子为 \(w_1, w_2\)</li>
                                    <li>如果 \(v\) 的邻居不是 \(w_1\) 或 \(w_2\)，那么 \(T\) 中 \(w_1, w_2, v\) 都是叶子（至少3个）</li>
                                    <li>如果 \(v\) 的邻居是 \(w_1\)，那么在 \(T\) 中 \(w_1\) 不是叶子，但 \(w_2, v\) 仍是叶子（至少2个）</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <!-- Problem: Bipartite tree -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis02b.pdf - Problem 4(b)</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>证明所有至少有2个顶点的树都是二部图。
                            <br>（二部图：顶点可以分成两组，所有边都连接两组之间的顶点）
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 证明（归纳法）：</h4>

                            <p><strong>Base Case (\(n = 2\))：</strong></p>
                            <ul>
                                <li>两个顶点的树只有一条边</li>
                                <li>可以分成两组：\(A = \{v_1\}\), \(B = \{v_2\}\)</li>
                                <li>唯一的边连接两组 ✓</li>
                            </ul>

                            <p><strong>Inductive Hypothesis：</strong></p>
                            <ul>
                                <li>假设所有有 \(n\) 个顶点的树都是二部图（\(n \geq 2\)）</li>
                            </ul>

                            <p><strong>Inductive Step：</strong></p>
                            <ul>
                                <li>考虑有 \(n+1\) 个顶点的树 \(T\)</li>
                                <li>树至少有一个叶子节点，设为 \(v\)（度数为1）</li>
                                <li>删除 \(v\) 和与它相连的边，得到树 \(T'\)，有 \(n\) 个顶点</li>
                                <li>由归纳假设，\(T'\) 是二部图，设两组为 \(A\) 和 \(B\)</li>
                                <li>设 \(v\) 的邻居为 \(u\)，不失一般性假设 \(u \in A\)</li>
                                <li>将 \(v\) 加入组 \(B\)</li>
                                <li>唯一连接 \(v\) 的边 \((u,v)\) 连接 \(A\) 和 \(B\)</li>
                                <li>所以 \(T\) 也是二部图 ✓</li>
                            </ul>

                            <p><strong>结论：</strong>由数学归纳法，所有树都是二部图。</p>
                        </div>
                    </div>

                    <!-- Problem: dis02b Problem 2 - Build-Up Error -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis02b.pdf - Problem 2</span>
                                <span class="difficulty">⭐⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>以下“证明”有什么错误？除了找到反例，还需解释这种方法的根本错误，以及为什么它展示了 build-up error 的危险。
                            <br><br>
                            <p><strong>错误断言：</strong>如果无向图中的每个顶点（\(|V| \geq 2\)）的度数至少为1，那么图是连通的。</p>
                            <br>
                            <p><strong>“证明”：</strong>我们对顶点数 \(n \geq 2\) 使用归纳法。</p>
                            <ul>
                                <li><strong>基础情况：</strong>唯一的有效图有两个由一条边连接的顶点。这个图是连通的，所以基础情况为真。</li>
                                <li><strong>归纳假设：</strong>假设对某个 \(n \geq 2\) 断言为真。</li>
                                <li><strong>归纳步骤：</strong>我们证明对 \(n+1\) 也为真。考虑一个有 \(n\) 个顶点的无向图，其中每个顶点的度数至少为1。由归纳假设，这个图是连通的。现在再添加一个顶点 \(x\) 得到 \(n+1\) 个顶点的图。我们只需检查从 \(x\) 到每个其他顶点 \(z\) 都有路径。由于 \(x\) 的度数至少为1，所以从 \(x\) 到某个其他顶点有一条边；称其为 \(y\)。因此，我们可以通过将边 \(\{x,y\}\) 与从 \(y\) 到 \(z\) 的路径相连来获得从 \(x\) 到 \(z\) 的路径。这证明了对 \(n+1\) 的断言。</li>
                            </ul>
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 解答：</h4>

                            <p><strong>反例：</strong></p>
                            <div class="example-box">
                                <p>考虑以下图：两个独立的边：</p>
                                <pre>顶点：{A, B, C, D}
边：{AB, CD}
度数：A:1, B:1, C:1, D:1</pre>
                                <ul>
                                    <li>所有顶点度数至少为1 ✓</li>
                                    <li>但图<strong>不连通</strong>！A和B一组，C和D一组，两组间没有连接</li>
                                </ul>
                            </div>

                            <p><strong>错误分析：</strong></p>
                            <div class="proof-box">
                                <p><strong>1. Build-Up Error（构建错误）：</strong></p>
                                <ul>
                                    <li>这个证明犯了经典的 <strong>build-up error</strong></li>
                                    <li>在归纳步骤中，证明假设“从一个满足条件的 \(n\) 个顶点的图”开始，然后添加第 \(n+1\) 个顶点</li>
                                    <li>但是，<strong>关键问题</strong>：当我们添加新顶点时，我们不知道它会连接到<strong>哪个</strong>顶点</li>
                                    <li>如果新顶点只连接到一个孤立的部分，这个方法就无法保证连通性</li>
                                </ul>

                                <p><strong>2. 正确的归纳结构：</strong></p>
                                <ul>
                                    <li>对于这个问题，正确的方法应该是 <strong>strong induction 或 shrinking</strong></li>
                                    <li><strong>Shrinking 方法</strong>：从 \(n+1\) 个顶点的图开始，<strong>删除</strong>一个顶点，然后利用归纳假设</li>
                                    <li>但这个问题仍然无法证明，因为断言本身就是<strong>错误的</strong>！</li>
                                </ul>

                                <p><strong>3. 为什么断言错误：</strong></p>
                                <ul>
                                    <li>每个顶点度数至少为1 只是说每个顶点至少有一条边</li>
                                    <li>但不保证这些边会形成一个连通的网络</li>
                                    <li>可能有多个独立的连通分量（connected components）</li>
                                </ul>

                                <p><strong>4. Build-Up Error 的危险：</strong></p>
                                <ul>
                                    <li>当我们“构建”一个更大的对象时，很难控制我们添加的部分如何与现有部分交互</li>
                                    <li>这可能会导致我们无法保证所需的性质</li>
                                    <li><strong>更安全的方法</strong>：从更大的对象开始，然后<strong>删除</strong>部分，这样我们能更好地控制结构</li>
                                </ul>
                            </div>

                            <p><strong>正确的断言：</strong></p>
                            <div class="tips-box">
                                <p>如果每个顶点的度数至少为2，那么图包含一个环（但不一定连通）。</p>
                                <p>如果图连通且每个顶点的度数至少为2，那么图包含一个环。</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 5.3 Eulerian Tours -->
            <div class="subsection" id="graphs-euler">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    5.3 欧拉回路（Eulerian Tours）
                </h3>
                <div class="collapsible-content">
                    <div class="concept-box">
                        <h4>📚 核心概念</h4>
                        <p>欧拉回路是经过图中每条边恰好一次的回路。</p>
                        <ul>
                            <li><strong>欧拉回路（Eulerian Tour）</strong>：起点=终点，经过每条边恰好一次</li>
                            <li><strong>欧拉路径（Eulerian Path）</strong>：起点≠终点，经过每条边恰好一次</li>
                        </ul>
                    </div>

                    <div class="formula-box">
                        <h4>📐 欧拉回路存在定理</h4>
                        <div class="formula-item">
                            <strong>定理：</strong>连通图有欧拉回路 ⟺ 所有顶点的度数都是偶数
                        </div>
                        <div class="formula-item">
                            <strong>推论：</strong>连通图有欧拉路径 ⟺ 恰有0个或2个奇数度顶点
                            <ul>
                                <li>0个奇数度顶点：存在欧拉回路</li>
                                <li>2个奇数度顶点：存在欧拉路径（起点和终点是这两个奇数度顶点）</li>
                            </ul>
                        </div>
                    </div>

                    <div class="tips-box">
                        <h4>💡 判断技巧</h4>
                        <ul>
                            <li>先检查连通性</li>
                            <li>再数奇数度顶点的个数</li>
                            <li>记住：偶数度→回路，2个奇数度→路径，其他→不存在</li>
                        </ul>
                    </div>

                    <!-- Problem: Eulerian tour existence -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_sp24.pdf - Q7(a)</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>对于给定的图，需要添加哪一条边使其包含欧拉回路？
                            <br><br>
                            <div style="text-align: center; margin: 20px 0;">
                                <svg width="250" height="200" style="border: 1px solid #ddd;">
                                    <circle cx="50" cy="50" r="20" fill="lightblue" stroke="black" stroke-width="2"/>
                                    <text x="50" y="55" text-anchor="middle" font-size="16">a</text>

                                    <circle cx="125" cy="30" r="20" fill="lightblue" stroke="black" stroke-width="2"/>
                                    <text x="125" y="35" text-anchor="middle" font-size="16">b</text>

                                    <circle cx="200" cy="50" r="20" fill="lightblue" stroke="black" stroke-width="2"/>
                                    <text x="200" y="55" text-anchor="middle" font-size="16">c</text>

                                    <circle cx="50" cy="150" r="20" fill="lightblue" stroke="black" stroke-width="2"/>
                                    <text x="50" y="155" text-anchor="middle" font-size="16">f</text>

                                    <circle cx="125" cy="120" r="20" fill="lightblue" stroke="black" stroke-width="2"/>
                                    <text x="125" y="125" text-anchor="middle" font-size="16">d</text>

                                    <circle cx="200" cy="150" r="20" fill="lightblue" stroke="black" stroke-width="2"/>
                                    <text x="200" y="155" text-anchor="middle" font-size="16">e</text>

                                    <line x1="70" y1="50" x2="105" y2="30" stroke="black" stroke-width="2"/>
                                    <line x1="145" y1="30" x2="180" y2="50" stroke="black" stroke-width="2"/>
                                    <line x1="50" y1="70" x2="50" y2="130" stroke="black" stroke-width="2"/>
                                    <line x1="70" y1="150" x2="105" y2="120" stroke="black" stroke-width="2"/>
                                    <line x1="145" y1="120" x2="180" y2="150" stroke="black" stroke-width="2"/>
                                    <line x1="200" y1="70" x2="200" y2="130" stroke="black" stroke-width="2"/>
                                    <line x1="125" y1="50" x2="125" y2="100" stroke="black" stroke-width="2"/>
                                </svg>
                            </div>
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 解答：</h4>
                            <ol>
                                <li><strong>分析当前度数：</strong>
                                    <ul>
                                        <li>deg(a) = 2（偶数）</li>
                                        <li>deg(b) = 2（偶数）</li>
                                        <li>deg(c) = 2（偶数）</li>
                                        <li>deg(d) = 3（奇数）</li>
                                        <li>deg(e) = 2（偶数）</li>
                                        <li>deg(f) = 2（偶数）</li>
                                    </ul>
                                </li>
                                <li>只有顶点d的度数是奇数，但需要所有度数都是偶数</li>
                                <li>等等，重新数：图中有两个奇数度顶点</li>
                                <li><strong>需要连接两个奇数度顶点</strong>使它们都变成偶数度</li>
                                <li><strong>答案：</strong>添加连接两个奇数度顶点的边</li>
                            </ol>
                        </div>
                    </div>

                    <!-- Problem: dis02b Problem 3 - Eulerian Tour and Walk -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis02b.pdf - Problem 3</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>考虑以下图：
                            <br><br>
                            <pre>顶点：1, 2, 3, 4, 5, 6, 7
边的描述：
  - 1连接2, 3, 4
  - 2连接1, 3, 4, 5
  - 3连接1, 2, 4
  - 4连接1, 2, 3, 5, 6
  - 5连接2, 4, 6, 7
  - 6连接4, 5, 7
  - 7连接5, 6</pre>
                            <br>
                            <ol style="list-style-type: lower-alpha;">
                                <li>图中是否存在欧拉回路？如果不存在，给出理由。如果存在，给出一个示例。</li>
                                <li>图中是否存在欧拉路径？（欧拉路径是经过每条边恰好一次的路径）如果不存在，给出理由。如果存在，给出一个示例。</li>
                                <li>无向图中存在欧拉路径的条件是什么？简要说明你的答案。</li>
                            </ol>
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 解答：</h4>

                            <p><strong>首先分析度数：</strong></p>
                            <div class="example-box">
                                <ul>
                                    <li>deg(1) = 3 （奇数）</li>
                                    <li>deg(2) = 4 （偶数）</li>
                                    <li>deg(3) = 3 （奇数）</li>
                                    <li>deg(4) = 5 （奇数）</li>
                                    <li>deg(5) = 4 （偶数）</li>
                                    <li>deg(6) = 3 （奇数）</li>
                                    <li>deg(7) = 2 （偶数）</li>
                                </ul>
                                <p><strong>奇数度顶点：</strong>1, 3, 4, 6 （共4个）</p>
                            </div>

                            <p><strong>(a) 是否存在欧拉回路？ - 不存在</strong></p>
                            <div class="proof-box">
                                <p><strong>理由：</strong></p>
                                <ul>
                                    <li>欧拉回路存在的充要条件：图连通且<strong>所有顶点度数都是偶数</strong></li>
                                    <li>这个图有 <strong>4个奇数度顶点</strong>：1, 3, 4, 6</li>
                                    <li>因此<strong>不存在</strong>欧拉回路。</li>
                                </ul>
                            </div>

                            <p><strong>(b) 是否存在欧拉路径？ - 不存在</strong></p>
                            <div class="proof-box">
                                <p><strong>理由：</strong></p>
                                <ul>
                                    <li>欧拉路径存在的充要条件：图连通且<strong>恰有0个或2个奇数度顶点</strong></li>
                                    <li>0个奇数度顶点 ⇒ 存在欧拉回路</li>
                                    <li>2个奇数度顶点 ⇒ 存在欧拉路径（起点和终点是这两个奇数度顶点）</li>
                                    <li>这个图有 <strong>4个奇数度顶点</strong></li>
                                    <li>因此<strong>不存在</strong>欧拉路径。</li>
                                </ul>
                            </div>

                            <p><strong>(c) 欧拉路径存在的条件：</strong></p>
                            <div class="formula-box">
                                <p><strong>定理：</strong></p>
                                <p>连通的无向图存在欧拉路径当且仅当：</p>
                                <ul>
                                    <li><strong>图是连通的</strong>，且</li>
                                    <li><strong>恰有0个或2个奇数度顶点</strong></li>
                                </ul>
                                <br>
                                <p><strong>详细分类：</strong></p>
                                <ul>
                                    <li><strong>0个奇数度顶点</strong> ⇒ 存在欧拉<strong>回路</strong>（起点=终点）</li>
                                    <li><strong>2个奇数度顶点</strong> ⇒ 存在欧拉<strong>路径</strong>（不是回路）
                                        <ul>
                                            <li>起点和终点必须是这两个奇数度顶点</li>
                                        </ul>
                                    </li>
                                    <li><strong>其他情况</strong>(奇数度顶点 > 2) ⇒ 不存在欧拉路径</li>
                                </ul>
                                <br>
                                <p><strong>直观理解：</strong></p>
                                <ul>
                                    <li>每次经过一个顶点时，我们使用2条边（一进一出）</li>
                                    <li>所以中间顶点的度数必须是偶数</li>
                                    <li>只有起点和终点可以是奇数度（只出/只进）</li>
                                    <li>如果起点=终点（回路），那么所有顶点都是偶数度</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 5.4 Planar Graphs -->
            <div class="subsection" id="graphs-planar">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    5.4 平面图（Planar Graphs）
                </h3>
                <div class="collapsible-content">
                    <div class="concept-box">
                        <h4>📚 核心概念</h4>
                        <p>平面图是可以在平面上画出且边不相交的图。</p>
                        <ul>
                            <li><strong>面（Face）</strong>：平面图中被边围成的区域（包括外部无限大的区域）</li>
                            <li><strong>面的大小</strong>：围成该面的边数</li>
                        </ul>
                    </div>

                    <div class="formula-box">
                        <h4>📐 欧拉公式</h4>
                        <div class="formula-item">
                            <strong>欧拉公式（Euler's Formula）：</strong>
                            \[v - e + f = 2\]
                            其中 \(v\) = 顶点数，\(e\) = 边数，\(f\) = 面数
                        </div>
                        <div class="formula-item">
                            <strong>边数上界：</strong>对于简单连通平面图：
                            \[e \leq 3v - 6\]
                        </div>
                        <div class="formula-item">
                            <strong>无三角形的平面图：</strong>如果图的girth（最短环长度）≥ 4：
                            \[e \leq 2v - 4\]
                        </div>
                    </div>

                    <div class="tips-box">
                        <h4>💡 判断平面图技巧</h4>
                        <ul>
                            <li>检查 \(e \leq 3v - 6\) 是否成立</li>
                            <li>\(K_5\) 和 \(K_{3,3}\) 不是平面图</li>
                            <li>使用Kuratowski定理：包含 \(K_5\) 或 \(K_{3,3}\) 的子图则不是平面图</li>
                        </ul>
                    </div>

                    <!-- Problem: Planar graph with girth -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_sp24.pdf - Q7(d)</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>图 \(G\) 的girth是指 \(G\) 中最短环的边数（如果无环则girth = ∞）。
                            <br>假设 \(G\) 连通，有 \(n = 80\) 个顶点，\(e = 135\) 条边，girth = 5。
                            <br>判断 \(G\) 是否为平面图？给出详细解释。
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 解答：</h4>

                            <p><strong>步骤1：使用欧拉公式</strong></p>
                            <ul>
                                <li>假设 \(G\) 是平面图</li>
                                <li>由欧拉公式：\(v - e + f = 2\)</li>
                                <li>代入：\(80 - 135 + f = 2\)</li>
                                <li>得：\(f = 57\)</li>
                            </ul>

                            <p><strong>步骤2：考虑面的大小限制</strong></p>
                            <ul>
                                <li>因为girth = 5，所以每个面至少由5条边围成</li>
                                <li>每条边最多被2个面共享</li>
                                <li>因此：\(5f \leq 2e\)（每个面至少5条边，每条边被计算2次）</li>
                                <li>代入：\(5 \times 57 \leq 2 \times 135\)</li>
                                <li>计算：\(285 \leq 270\)</li>
                                <li><strong>矛盾！</strong></li>
                            </ul>

                            <p><strong>结论：</strong>\(G\) 不是平面图 ✓</p>
                        </div>
                    </div>

                    <!-- Problem: Face size -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_fa24.pdf - Q8.1</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>考虑简单连通平面图，有 \(e\) 条边和 \(v > 2\) 个顶点。
                            <br>证明：如果 \(e < 3v - 6\)，那么存在一个大小至少为4的面。
                            <br>（提示：在简单平面图中，每个面大小至少为3）
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 证明（反证法）：</h4>

                            <ol>
                                <li><strong>假设：</strong>所有面的大小都恰好为3</li>
                                <li>由欧拉公式：\(v - e + f = 2\)，所以 \(f = 2 - v + e\)</li>
                                <li>因为每个面有3条边，每条边被2个面共享：
                                    \[3f = 2e\]
                                </li>
                                <li>代入 \(f = 2 - v + e\)：
                                    \[3(2 - v + e) = 2e\]
                                </li>
                                <li>展开：
                                    \[6 - 3v + 3e = 2e\]
                                </li>
                                <li>整理：
                                    \[e = 3v - 6\]
                                </li>
                                <li>但题目给定 \(e < 3v - 6\)，<strong>矛盾！</strong></li>
                                <li>因此假设错误，必定存在大小 ≥ 4 的面 ✓</li>
                            </ol>
                        </div>
                    </div>

                    <!-- Problem: dis03a Problem 1 - Always, Sometimes, or Never -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis03a.pdf - Problem 1</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>在以下每个部分中，你获得了关于图 \(G\) 的一些信息。仅使用当前部分的信息，判断 \(G\) 是<strong>总是</strong>平面图、<strong>总是</strong>非平面图，还是<strong>可能两者之一</strong>。如果你认为总是平面或总是非平面，请证明。如果可能两者之一，请给出平面和非平面的例子。
                            <br><br>
                            <ol style="list-style-type: lower-alpha;">
                                <li>\(G\) 可以用 4 种颜色进行顶点染色。</li>
                                <li>\(G\) 需要 7 种颜色才能进行顶点染色。</li>
                                <li>\(e \leq 3v-6\)，其中 \(e\) 是 \(G\) 的边数，\(v\) 是 \(G\) 的顶点数。</li>
                                <li>\(G\) 是连通的，且每个顶点的度数至多为 2。</li>
                                <li>每个顶点的度数至多为 2。</li>
                            </ol>
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 答案：</h4>

                            <p><strong>(a) 可以用4色染色 - 可能两者之一</strong></p>
                            <div class="example-box">
                                <p><strong>分析：</strong></p>
                                <ul>
                                    <li>四色定理说：所有平面图都可以用4色染色</li>
                                    <li>但不是所有4色可染色的图都是平面图</li>
                                </ul>
                                <p><strong>平面例子：</strong>任何树（2-colorable，因此也是4-colorable）</p>
                                <p><strong>非平面例子：</strong>\(K_{3,3}\) （完全二部图，2-colorable但不是平面图）</p>
                            </div>

                            <p><strong>(b) 需要7色染色 - 总是非平面</strong></p>
                            <div class="proof-box">
                                <p><strong>证明：</strong></p>
                                <ul>
                                    <li>由四色定理，所有平面图都可以用4色染色</li>
                                    <li>如果 \(G\) 需要7色，那么它不能用4色染色</li>
                                    <li>因此 \(G\) <strong>不是平面图</strong> ✓</li>
                                </ul>
                                <p><strong>例子：</strong>\(K_7\) （完全图，有7个顶点，需要7色）</p>
                            </div>

                            <p><strong>(c) \(e \leq 3v-6\) - 可能两者之一</strong></p>
                            <div class="example-box">
                                <p><strong>分析：</strong></p>
                                <ul>
                                    <li>这是平面图的<strong>必要条件</strong>，但不是充分条件</li>
                                    <li>满足 \(e \leq 3v-6\) 的图可能是平面的，也可能不是</li>
                                </ul>
                                <p><strong>平面例子：</strong>\(K_4\) （\(v=4, e=6, 6 \leq 3 \times 4 - 6 = 6\) ✓）</p>
                                <p><strong>非平面例子：</strong>\(K_{3,3}\) （\(v=6, e=9, 9 \leq 3 \times 6 - 6 = 12\) ✓，但不是平面图）</p>
                            </div>

                            <p><strong>(d) 连通且每个顶点度数至多为2 - 总是平面</strong></p>
                            <div class="proof-box">
                                <p><strong>证明：</strong></p>
                                <ul>
                                    <li>如果连通且每个顶点度数至多为2，那么 \(G\) 是一条<strong>路径</strong>或一个<strong>环</strong></li>
                                    <li>路径和环都可以在平面上画出且无边交叉</li>
                                    <li>因此总是平面图 ✓</li>
                                </ul>
                            </div>

                            <p><strong>(e) 每个顶点度数至多为2 - 总是平面</strong></p>
                            <div class="proof-box">
                                <p><strong>证明：</strong></p>
                                <ul>
                                    <li>如果每个顶点度数至多为2，那么 \(G\) 是<strong>一些路径和环的不相交并集</strong></li>
                                    <li>（不一定连通，可能有多个连通分量）</li>
                                    <li>每条路径和每个环都是平面的</li>
                                    <li>多个平面图的不相交并集仍是平面的（可以分开画）</li>
                                    <li>因此总是平面图 ✓</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <!-- Problem: dis03a Problem 2 - Short Answers -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis03a.pdf - Problem 2</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>在以下每个部分中，给出数字/公式和简短说明。
                            <br><br>
                            <ol style="list-style-type: lower-alpha;">
                                <li>一个连通的平面简单图比顶点数多5条边。它朋多少个面？</li>
                                <li>从 \(K_6\) 中需要删除多少条边才能得到一棵树？</li>
                                <li>欧拉公式 \(v-e+f=2\) 要求平面图是连通的。对于有 \(k\) 个连通分量的平面图，类似的公式是什么？</li>
                            </ol>
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 答案：</h4>

                            <p><strong>(a) 边数比顶点数多5，有多少面？</strong></p>
                            <div class="proof-box">
                                <p><strong>解：</strong></p>
                                <ul>
                                    <li>设顶点数为 \(v\)，边数为 \(e\)，面数为 \(f\)</li>
                                    <li>条件：\(e = v + 5\)</li>
                                    <li>由欧拉公式：\(v - e + f = 2\)</li>
                                    <li>代入 \(e = v + 5\)：\(v - (v+5) + f = 2\)</li>
                                    <li>整理：\(f = 7\)</li>
                                </ul>
                                <p><strong>答案：</strong>\(f = 7\) 个面</p>
                            </div>

                            <p><strong>(b) 从 \(K_6\) 删除多少边得到树？</strong></p>
                            <div class="proof-box">
                                <p><strong>解：</strong></p>
                                <ul>
                                    <li>\(K_6\) 有 \(v = 6\) 个顶点</li>
                                    <li>\(K_6\) 的边数：\(e = \binom{6}{2} = 15\)</li>
                                    <li>有 \(v\) 个顶点的树有 \(v-1\) 条边</li>
                                    <li>6个顶点的树有 \(6-1 = 5\) 条边</li>
                                    <li>需要删除：\(15 - 5 = 10\) 条边</li>
                                </ul>
                                <p><strong>答案：</strong>需要删除 10 条边</p>
                            </div>

                            <p><strong>(c) 有 \(k\) 个连通分量的平面图的欧拉公式？</strong></p>
                            <div class="proof-box">
                                <p><strong>推导：</strong></p>
                                <ul>
                                    <li>对于连通的平面图：\(v - e + f = 2\)</li>
                                    <li>如果有 \(k\) 个连通分量，每个分量满足：\(v_i - e_i + f_i = 2\)</li>
                                    <li>求和：\(\sum_{i=1}^{k} (v_i - e_i + f_i) = 2k\)</li>
                                    <li>即：\((\sum v_i) - (\sum e_i) + (\sum f_i) = 2k\)</li>
                                    <li>但注意：<strong>外部面被计算了 \(k\) 次</strong></li>
                                    <li>实际面数：\(f = (\sum f_i) - (k-1)\)</li>
                                    <li>因此：\(v - e + f = v - e + (\sum f_i) - (k-1) = 2k - (k-1) = k + 1\)</li>
                                </ul>
                                <p><strong>答案：</strong>\(v - e + f = k + 1\)</p>
                                <p><strong>验证：</strong></p>
                                <ul>
                                    <li>\(k=1\)：\(v - e + f = 2\) ✓ （标准欧拉公式）</li>
                                    <li>\(k=2\)：\(v - e + f = 3\) （两个连通分量，共享一个外部面）</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 5.5 Graph Coloring -->
            <div class="subsection" id="graphs-coloring">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    5.5 图染色（Graph Coloring）
                </h3>
                <div class="collapsible-content">
                    <div class="concept-box">
                        <h4>📚 核心概念</h4>
                        <p>给图的顶点或边分配颜色，使相邻元素颜色不同。</p>
                        <ul>
                            <li><strong>顶点染色</strong>：相邻顶点颜色不同</li>
                            <li><strong>边染色</strong>：共享顶点的边颜色不同</li>
                            <li><strong>色数 χ(G)</strong>：给图 \(G\) 染色所需的最少颜色数</li>
                        </ul>
                    </div>

                    <div class="formula-box">
                        <h4>📐 染色定理</h4>
                        <div class="formula-item">
                            <strong>二部图：</strong>图是二部图 ⟺ 色数 ≤ 2 ⟺ 无奇数长度环
                        </div>
                        <div class="formula-item">
                            <strong>边染色：</strong>最大度数为 \(d\) 的图可以用 \(d\) 或 \(d+1\) 种颜色边染色
                        </div>
                        <div class="formula-item">
                            <strong>四色定理：</strong>任何平面图都可以用4种颜色顶点染色
                        </div>
                    </div>

                    <div class="tips-box">
                        <h4>💡 解题技巧</h4>
                        <ul>
                            <li>环 \(C_n\)：奇数长度需要3色，偶数长度需要2色</li>
                            <li>完全图 \(K_n\)：需要 \(n\) 种颜色</li>
                            <li>树：总是2-colorable（二部图）</li>
                        </ul>
                    </div>

                    <!-- Problem: Edge coloring -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_fa24.pdf - Q7.3-7.4</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>
                            <ol>
                                <li>一个 \(d\) 维超立方体可以用多少种颜色进行边染色？（给出紧确界）</li>
                                <li>一个奇数长度的环可以用多少种颜色进行边染色？（给出紧确界）</li>
                            </ol>
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 答案：</h4>

                            <p><strong>(1) \(d\) 维超立方体：\(d\) 种颜色</strong></p>
                            <ul>
                                <li>超立方体是 \(d\)-regular图（每个顶点度数为 \(d\)）</li>
                                <li>所以至少需要 \(d\) 种颜色</li>
                                <li>可以构造：按照边的"维度"染色，第 \(i\) 维的边用颜色 \(i\)</li>
                                <li>因此恰好需要 \(d\) 种颜色</li>
                            </ul>

                            <p><strong>(2) 奇数长度环：3种颜色</strong></p>
                            <ul>
                                <li>奇数长度环 \(C_{2k+1}\) 有顶点度数为2</li>
                                <li>至少需要2种颜色</li>
                                <li>但2种颜色不够：沿环走一圈，颜色交替，奇数长度导致最后一条边与第一条边颜色冲突</li>
                                <li>3种颜色足够：用颜色1,2,1,2,...,1,2,3</li>
                                <li>因此恰好需要3种颜色</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Problem: dis03a Problem 3 - Graph Coloring -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis03a.pdf - Problem 3</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>证明最大度数至多为 \(k\) 的图是 \((k+1)\)-colorable。
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 证明（归纳法）：</h4>

                            <p><strong>对顶点数 \(n\) 进行归纳：</strong></p>

                            <div class="proof-box">
                                <p><strong>Base Case (\(n = 1\))：</strong></p>
                                <ul>
                                    <li>一个顶点的图只需要1种颜色</li>
                                    <li>由于 \(k \geq 0\)，\(1 \leq k+1\) ✓</li>
                                </ul>

                                <p><strong>Inductive Hypothesis：</strong></p>
                                <ul>
                                    <li>假设对于所有有 \(n\) 个顶点且最大度数至多为 \(k\) 的图，都是 \((k+1)\)-colorable。</li>
                                </ul>

                                <p><strong>Inductive Step：</strong></p>
                                <ol>
                                    <li>考虑一个有 \(n+1\) 个顶点且最大度数至多为 \(k\) 的图 \(G\)。</li>
                                    <li>从 \(G\) 中删除一个顶点 \(v\)，得到图 \(G'\)。</li>
                                    <li>\(G'\) 有 \(n\) 个顶点，最大度数至多为 \(k\)（删除顶点不会增加度数）。</li>
                                    <li>由归纳假设，\(G'\) 可以用 \(k+1\) 种颜色染色。</li>
                                    <li>现在需要给顶点 \(v\) 分配颜色：
                                        <ul>
                                            <li>顶点 \(v\) 的度数至多为 \(k\)</li>
                                            <li>所以 \(v\) 至多有 \(k\) 个邻居</li>
                                            <li>这 \(k\) 个邻居最多使用 \(k\) 种颜色</li>
                                            <li>我们有 \(k+1\) 种颜色可用</li>
                                            <li>因此至少有<strong>1种颜色</strong>未被邻居使用</li>
                                            <li>给 \(v\) 分配这个未使用的颜色</li>
                                        </ul>
                                    </li>
                                    <li>现在 \(G\) 中所有顶点都被染色，且相邻顶点颜色不同。</li>
                                    <li>因此 \(G\) 是 \((k+1)\)-colorable ✓</li>
                                </ol>

                                <p><strong>结论：</strong></p>
                                <p>由数学归纳法，所有最大度数至多为 \(k\) 的图都是 \((k+1)\)-colorable。</p>
                            </div>

                            <p><strong>关键观察：</strong></p>
                            <div class="tips-box">
                                <ul>
                                    <li>这个证明使用了<strong>贪心算法</strong>的思想：逐个给顶点染色</li>
                                    <li>关键是：如果顶点度数 ≤ \(k\)，那么在 \(k+1\) 种颜色中总有一种可用</li>
                                    <li>这个界是<strong>紧的</strong>：完全图 \(K_{k+1}\) 需要恰好 \(k+1\) 种颜色</li>
                                </ul>
                            </div>

                            <p><strong>另一种证明方法（直接构造）：</strong></p>
                            <div class="proof-box">
                                <ol>
                                    <li>将顶点按任意顺序排列：\(v_1, v_2, ..., v_n\)</li>
                                    <li>依次给每个顶点染色：
                                        <ul>
                                            <li>当给 \(v_i\) 染色时，它的邻居中至多有 \(k\) 个已被染色</li>
                                            <li>这些邻居最多使用 \(k\) 种颜色</li>
                                            <li>在 \(k+1\) 种颜色中选择一个未被邻居使用的颜色 ✓</li>
                                        </ul>
                                    </li>
                                </ol>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 5.6 Hypercubes -->
            <div class="subsection" id="graphs-hypercube">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    5.6 超立方体（Hypercubes）
                </h3>
                <div class="collapsible-content">
                    <div class="concept-box">
                        <h4>📚 核心概念</h4>
                        <p>\(d\) 维超立方体是一个特殊的图结构。</p>
                        <ul>
                            <li><strong>顶点</strong>：所有长度为 \(d\) 的二进制串</li>
                            <li><strong>边</strong>：两个串恰好有1位不同时连边</li>
                        </ul>
                    </div>

                    <div class="formula-box">
                        <h4>📐 超立方体性质</h4>
                        <div class="formula-item">
                            <strong>顶点数：</strong>\(n = 2^d\)
                        </div>
                        <div class="formula-item">
                            <strong>边数：</strong>\(m = d \cdot 2^{d-1}\)
                            <br>（每个顶点度数为 \(d\)，总度数 = \(d \cdot 2^d\)，边数 = 度数和/2）
                        </div>
                        <div class="formula-item">
                            <strong>性质：</strong>
                            <ul>
                                <li>\(d\)-regular：每个顶点度数都是 \(d\)</li>
                                <li>二部图：按照二进制串中1的个数奇偶性分组</li>
                                <li>高度对称</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Problem: Hypercube edges -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_fa24.pdf - Q7(d)</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>如果 \(G\) 是超立方体，那么 \(m\) 用 \(n\) 表示是多少？
                            <br>（可以使用 \(\log_2 n\)）
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 解答：</h4>
                            <ul>
                                <li>设超立方体维度为 \(d\)</li>
                                <li>顶点数：\(n = 2^d\)，所以 \(d = \log_2 n\)</li>
                                <li>边数：\(m = d \cdot 2^{d-1} = d \cdot \frac{n}{2}\)</li>
                                <li>代入 \(d = \log_2 n\)：
                                    \[m = \frac{n \log_2 n}{2}\]
                                </li>
                                <li><strong>答案：</strong>\(m = \frac{n \log_2 n}{2}\)</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Problem: dis03a Problem 4 - Hypercubes -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis03a.pdf - Problem 4</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>\(n\) 维超立方体 \(G = (V,E)\) 的顶点集由 \(V = \{0,1\}^n\) 给出（即所有 \(n\) 位二进制串）。当且仅当顶点 \(x\) 和 \(y\) 恰好在一个位上不同时，它们之间有一条边。
                            <br><br>
                            <ol style="list-style-type: lower-alpha;">
                                <li>画出 1、2、3 维超立方体，并使用对应的二进制串标记顶点。</li>
                                <li>证明：\(n\) 维超立方体的边可以用 \(n\) 种颜色染色，使得共享一个顶点的边没有相同的颜色。</li>
                                <li>证明：对于任意 \(n \geq 1\)，\(n\) 维超立方体是二部图。</li>
                            </ol>
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 答案：</h4>

                            <p><strong>(a) 画出 1、2、3 维超立方体：</strong></p>
                            <div class="example-box">
                                <p><strong>1维超立方体：</strong>两个顶点连一条边</p>
                                <pre>0 -------- 1</pre>
                                
                                <p><strong>2维超立方体：</strong>正方形</p>
                                <pre>00 -------- 10
 |          |
 |          |
01 -------- 11</pre>
                                
                                <p><strong>3维超立方体：</strong>正方体</p>
                                <pre>    000 -------- 100
     /|          /|
    / |         / |
  001-|------101 |
   |  010-----|--110
   | /        | /
   |/         |/
  011 ------ 111</pre>
                            </div>

                            <p><strong>(b) 边可以用 \(n\) 种颜色染色：</strong></p>
                            <div class="proof-box">
                                <p><strong>证明：</strong></p>
                                <ol>
                                    <li>对于每条边 \((x,y)\)，\(x\) 和 \(y\) 恰好在一个位上不同。</li>
                                    <li>设它们在第 \(i\) 位不同（\(1 \leq i \leq n\)）。</li>
                                    <li>给这条边分配颜色 \(i\)。</li>
                                    <li><strong>验证无冲突：</strong>
                                        <ul>
                                            <li>考虑任意顶点 \(v\)</li>
                                            <li>与 \(v\) 相连的边对应于 \(v\) 的 \(n\) 个位置中每个的翻转</li>
                                            <li>每条边对应不同的位置，因此有不同的颜色</li>
                                            <li>所以与 \(v\) 相连的 \(n\) 条边有 \(n\) 种不同的颜色 ✓</li>
                                        </ul>
                                    </li>
                                </ol>
                                <p><strong>结论：</strong>\(n\) 种颜色足够，且是最少的（因为度数为 \(n\)）。</p>
                            </div>

                            <p><strong>(c) \(n\) 维超立方体是二部图：</strong></p>
                            <div class="proof-box">
                                <p><strong>证明：</strong></p>
                                <ol>
                                    <li>将顶点分成两组：
                                        <ul>
                                            <li>\(A = \{x \in \{0,1\}^n : x \text{ 中1的个数是偶数}\}\)</li>
                                            <li>\(B = \{x \in \{0,1\}^n : x \text{ 中1的个数是奇数}\}\)</li>
                                        </ul>
                                    </li>
                                    <li>需要证明：每条边连接 \(A\) 和 \(B\) 中的顶点。</li>
                                    <li>考虑任意边 \((x,y)\)：
                                        <ul>
                                            <li>\(x\) 和 \(y\) 恰好在一个位上不同</li>
                                            <li>设在第 \(i\) 位不同</li>
                                            <li>如果 \(x[i] = 0, y[i] = 1\)，那么 \(y\) 中1的个数比 \(x\) 多1</li>
                                            <li>如果 \(x[i] = 1, y[i] = 0\)，那么 \(y\) 中1的个数比 \(x\) 少1</li>
                                            <li>在两种情况下，\(x\) 和 \(y\) 中1的个数奇偶性<strong>不同</strong></li>
                                            <li>因此 \(x \in A, y \in B\) 或 \(x \in B, y \in A\) ✓</li>
                                        </ul>
                                    </li>
                                </ol>
                                <p><strong>结论：</strong>所有边都连接两组之间，所以是二部图。</p>
                            </div>
                        </div>
                    </div>

                    <!-- Problem: dis07a Problem 3 - Graph Complement -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis07a.pdf - Problem 3</span>
                                <span class="difficulty">⭐⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>设 \(G = (V,E)\) 是一个无自环的不连通图。证明其补图 \(\overline{G} = (V,\overline{E})\) 是连通的。
                            <br>（回顾：补图定义为：对于 \(u,v \in V\)，\((u,v) \in \overline{E}\) 当且仅当 \((u,v) \notin E\)）
                        </div>
                        <div class="problem-actions">
                            <button class="btn btn-primary" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <h4>✅ 证明：</h4>

                            <div class="proof-box">
                                <p><strong>设置：</strong></p>
                                <ul>
                                    <li>由于 \(G\) 不连通，它至少有2个连通分量。</li>
                                    <li>设这些连通分量为 \(C_1, C_2, ..., C_k\)，其中 \(k \geq 2\)。</li>
                                </ul>

                                <p><strong>要证：</strong>对于 \(\overline{G}\) 中任意两个顶点 \(u, v\)，存在在 \(\overline{G}\) 中从 \(u\) 到 \(v\) 的路径。</li>

                                <p><strong>分情况讨论：</strong></p>
                                
                                <p><strong>Case 1：\(u\) 和 \(v\) 在 \(G\) 的<em>不同</em>连通分量中</strong></p>
                                <ul>
                                    <li>设 \(u \in C_i, v \in C_j\)，其中 \(i \neq j\)</li>
                                    <li>由于它们在不同的连通分量中，在 \(G\) 中 \((u,v) \notin E\)</li>
                                    <li>因此在 \(\overline{G}\) 中 \((u,v) \in \overline{E}\)</li>
                                    <li>所以在 \(\overline{G}\) 中存在直接连接 \(u\) 和 \(v\) 的边 ✓</li>
                                </ul>

                                <p><strong>Case 2：\(u\) 和 \(v\) 在 \(G\) 的<em>同一</em>连通分量中</strong></p>
                                <ul>
                                    <li>设 \(u, v \in C_i\)</li>
                                    <li>由于 \(k \geq 2\)，存在另一个连通分量 \(C_j\)  \((j \neq i)\)</li>
                                    <li>从 \(C_j\) 中选择任意顶点 \(w\)</li>
                                    <li>由于 \(u \in C_i, w \in C_j\) 且 \(i \neq j\)，在 \(G\) 中 \((u,w) \notin E\)</li>
                                    <li>因此在 \(\overline{G}\) 中 \((u,w) \in \overline{E}\)</li>
                                    <li>同理，在 \(\overline{G}\) 中 \((w,v) \in \overline{E}\)</li>
                                    <li>因此在 \(\overline{G}\) 中存在路径 \(u \to w \to v\) ✓</li>
                                </ul>

                                <p><strong>结论：</strong></p>
                                <p>在两种情况下，\(\overline{G}\) 中任意两个顶点之间都有路径，因此 \(\overline{G}\) 是连通的。</p>
                            </div>

                            <p><strong>关键思想：</strong></p>
                            <div class="tips-box">
                                <ul>
                                    <li>不连通图有多个连通分量</li>
                                    <li>在补图中，不同连通分量之间的顶点<strong>都相连</strong></li>
                                    <li>这些“跨分量”的连接使得补图连通</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 6: Modular Arithmetic -->
        <section class="section" id="section6">
            <h2 class="section-title">6. Modular Arithmetic (模运算)</h2>

            <!-- 6.1 基本运算与性质 -->
            <div class="subsection" id="section6-1">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    6.1 基本运算与性质 (Basic Operations and Properties)
                </h3>
                <div class="collapsible-content">
                    <div class="concept-box">
                        <h4>📚 核心概念</h4>
                        <p><strong>模运算定义：</strong>对于整数 \(a, b, n\)（其中 \(n > 0\)），如果 \(n \mid (a - b)\)，即 \(a - b = kn\) 对某个整数 \(k\) 成立，则称 \(a\) 与 \(b\) 在模 \(n\) 下同余，记作 \(a \equiv b \pmod{n}\)。</p>
                        <p><strong>基本性质：</strong></p>
                        <ul>
                            <li><strong>自反性：</strong>\(a \equiv a \pmod{n}\)</li>
                            <li><strong>对称性：</strong>若 \(a \equiv b \pmod{n}\)，则 \(b \equiv a \pmod{n}\)</li>
                            <li><strong>传递性：</strong>若 \(a \equiv b \pmod{n}\) 且 \(b \equiv c \pmod{n}\)，则 \(a \equiv c \pmod{n}\)</li>
                            <li><strong>加法性质：</strong>若 \(a \equiv b \pmod{n}\) 且 \(c \equiv d \pmod{n}\)，则 \(a + c \equiv b + d \pmod{n}\)</li>
                            <li><strong>乘法性质：</strong>若 \(a \equiv b \pmod{n}\) 且 \(c \equiv d \pmod{n}\)，则 \(ac \equiv bd \pmod{n}\)</li>
                        </ul>
                    </div>

                    <div class="formula-box">
                        <h4>📐 重要公式</h4>
                        <div class="formula-item">
                            <strong>模运算基本公式：</strong>
                            \[a \bmod n = r \text{ 当且仅当 } a = qn + r \text{，其中 } 0 \leq r < n\]
                        </div>
                        <div class="formula-item">
                            <strong>模加法：</strong>
                            \[(a + b) \bmod n = [(a \bmod n) + (b \bmod n)] \bmod n\]
                        </div>
                        <div class="formula-item">
                            <strong>模乘法：</strong>
                            \[(a \cdot b) \bmod n = [(a \bmod n) \cdot (b \bmod n)] \bmod n\]
                        </div>
                        <div class="formula-item">
                            <strong>模幂运算：</strong>
                            \[a^k \bmod n = [(a \bmod n)^k] \bmod n\]
                        </div>
                    </div>

                    <div class="tips-box">
                        <h4>💡 解题技巧</h4>
                        <ul>
                            <li>计算大数的模运算时，可以在每一步运算后都取模，避免数字过大</li>
                            <li>模幂运算可以使用快速幂算法（重复平方法）提高效率</li>
                            <li>注意模运算不满足除法性质：\(\frac{a}{b} \bmod n \neq \frac{a \bmod n}{b \bmod n}\)</li>
                            <li>模运算结果范围始终在 \([0, n-1]\) 之间</li>
                        </ul>
                    </div>

                    <!-- Problem 1: 模幂运算 -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_fa24.pdf - Q11.1</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>计算 \(7^{26} \pmod{10}\)。
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>
                            <p>使用快速幂方法和模运算性质：</p>
                            <p><strong>步骤1：</strong>找规律。先计算 \(7\) 的几个幂次：</p>
                            \[\begin{align}
                            7^1 &\equiv 7 \pmod{10} \\
                            7^2 &\equiv 49 \equiv 9 \pmod{10} \\
                            7^3 &\equiv 7 \cdot 9 \equiv 63 \equiv 3 \pmod{10} \\
                            7^4 &\equiv 7 \cdot 3 \equiv 21 \equiv 1 \pmod{10}
                            \end{align}\]

                            <p><strong>步骤2：</strong>发现周期。\(7^4 \equiv 1 \pmod{10}\)，所以周期为 4。</p>

                            <p><strong>步骤3：</strong>利用周期性计算：</p>
                            \[\begin{align}
                            26 &= 4 \times 6 + 2 \\
                            7^{26} &= (7^4)^6 \cdot 7^2 \\
                            &\equiv 1^6 \cdot 7^2 \pmod{10} \\
                            &\equiv 7^2 \pmod{10} \\
                            &\equiv 49 \equiv 9 \pmod{10}
                            \end{align}\]

                            <p><strong>答案：</strong>\(7^{26} \equiv 9 \pmod{10}\)</p>
                        </div>
                    </div>

                    <!-- Problem 2: 模逆元 -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_fa24.pdf - Q11.2</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>求 \(7\) 在模 \(68\) 下的乘法逆元。
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>
                            <p>我们需要找到 \(x\) 使得 \(7x \equiv 1 \pmod{68}\)。</p>

                            <p><strong>方法：使用扩展欧几里得算法</strong></p>

                            <p><strong>步骤1：</strong>应用欧几里得算法求 \(\gcd(7, 68)\)：</p>
                            \[\begin{align}
                            68 &= 7 \times 9 + 5 \\
                            7 &= 5 \times 1 + 2 \\
                            5 &= 2 \times 2 + 1 \\
                            2 &= 1 \times 2 + 0
                            \end{align}\]
                            <p>所以 \(\gcd(7, 68) = 1\)，逆元存在。</p>

                            <p><strong>步骤2：</strong>回代求解（从下往上）：</p>
                            \[\begin{align}
                            1 &= 5 - 2 \times 2 \\
                            &= 5 - (7 - 5 \times 1) \times 2 \\
                            &= 5 - 7 \times 2 + 5 \times 2 \\
                            &= 5 \times 3 - 7 \times 2 \\
                            &= (68 - 7 \times 9) \times 3 - 7 \times 2 \\
                            &= 68 \times 3 - 7 \times 27 - 7 \times 2 \\
                            &= 68 \times 3 - 7 \times 29
                            \end{align}\]

                            <p><strong>步骤3：</strong>得到：\(7 \times (-29) \equiv 1 \pmod{68}\)</p>
                            <p>将 \(-29\) 转换为正数：\(-29 + 68 = 39\)</p>

                            <p><strong>验证：</strong>\(7 \times 39 = 273 = 68 \times 4 + 1 \equiv 1 \pmod{68}\) ✓</p>

                            <p><strong>答案：</strong>\(7^{-1} \equiv 39 \pmod{68}\)</p>
                        </div>
                    </div>

                    <!-- Problem 3: Party Tricks (a) -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis03b.pdf - Problem 1(a)</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>求 \(113^{142}\) 的最后一位数字。
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>
                            <p>求最后一位数字等价于计算 \(113^{142} \pmod{10}\)。</p>
                            
                            <p><strong>步骤1：</strong>简化底数</p>
                            \[113 \equiv 3 \pmod{10}\]
                            
                            <p><strong>步骤2：</strong>找 3 的幂次规律</p>
                            \[\begin{align}
                            3^1 &\equiv 3 \pmod{10} \\
                            3^2 &\equiv 9 \pmod{10} \\
                            3^3 &\equiv 27 \equiv 7 \pmod{10} \\
                            3^4 &\equiv 21 \equiv 1 \pmod{10}
                            \end{align}\]
                            
                            <p><strong>步骤3：</strong>利用周期性（周期为 4）</p>
                            \[\begin{align}
                            142 &= 4 \times 35 + 2 \\
                            113^{142} &\equiv 3^{142} \equiv (3^4)^{35} \cdot 3^2 \\
                            &\equiv 1^{35} \cdot 9 \equiv 9 \pmod{10}
                            \end{align}\]
                            
                            <p><strong>答案：</strong>最后一位数字是 9</p>
                        </div>
                    </div>

                    <!-- Problem 4: Party Tricks (b) -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis03b.pdf - Problem 1(b)</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>求 \(9^{9999}\) 的最后一位数字。
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>
                            <p>计算 \(9^{9999} \pmod{10}\)。</p>
                            
                            <p><strong>步骤1：</strong>找 9 的幂次规律</p>
                            \[\begin{align}
                            9^1 &\equiv 9 \pmod{10} \\
                            9^2 &\equiv 81 \equiv 1 \pmod{10}
                            \end{align}\]
                            
                            <p><strong>步骤2：</strong>利用周期性（周期为 2）</p>
                            \[\begin{align}
                            9999 &= 2 \times 4999 + 1 \\
                            9^{9999} &= (9^2)^{4999} \cdot 9 \\
                            &\equiv 1^{4999} \cdot 9 \equiv 9 \pmod{10}
                            \end{align}\]
                            
                            <p><strong>答案：</strong>最后一位数字是 9</p>
                        </div>
                    </div>

                    <!-- Problem 5: Party Tricks (c) -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis03b.pdf - Problem 1(c)</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>求 \(3^{641}\) 的最后一位数字。
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>
                            <p>计算 \(3^{641} \pmod{10}\)。</p>
                            
                            <p><strong>步骤1：</strong>回顾 3 的幂次规律（周期为 4）</p>
                            \[3^4 \equiv 1 \pmod{10}\]
                            
                            <p><strong>步骤2：</strong>分解指数</p>
                            \[\begin{align}
                            641 &= 4 \times 160 + 1 \\
                            3^{641} &= (3^4)^{160} \cdot 3 \\
                            &\equiv 1^{160} \cdot 3 \equiv 3 \pmod{10}
                            \end{align}\]
                            
                            <p><strong>答案：</strong>最后一位数字是 3</p>
                        </div>
                    </div>

                    <!-- Problem 6: Modular Potpourri (a) -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis03b.pdf - Problem 2(a)</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>证明或反驳：存在整数 \(x\) 使得 \(x \equiv 3 \pmod{16}\) 且 \(x \equiv 4 \pmod{6}\)。
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>
                            <p><strong>命题为真。</strong>通过构造法证明存在性。</p>
                            
                            <p><strong>方法：</strong>从第一个条件出发寻找满足第二个条件的解。</p>
                            
                            <p>由 \(x \equiv 3 \pmod{16}\)，可写作 \(x = 16k + 3\) 对某个整数 \(k\)。</p>
                            
                            <p>代入第二个条件：</p>
                            \[\begin{align}
                            16k + 3 &\equiv 4 \pmod{6} \\
                            16k &\equiv 1 \pmod{6} \\
                            4k &\equiv 1 \pmod{6} \quad (\text{因为 } 16 \equiv 4 \pmod{6})
                            \end{align}\]
                            
                            <p>尝试 \(k = 1\)：\(4 \cdot 1 = 4 \not\equiv 1 \pmod{6}\)</p>
                            <p>尝试 \(k = 2\)：\(4 \cdot 2 = 8 \equiv 2 \pmod{6}\)</p>
                            <p>尝试 \(k = 4\)：\(4 \cdot 4 = 16 \equiv 4 \pmod{6}\)</p>
                            <p>尝试 \(k = 5\)：\(4 \cdot 5 = 20 \equiv 2 \pmod{6}\)</p>
                            <p>尝试 \(k = 7\)：\(4 \cdot 7 = 28 \equiv 4 \pmod{6}\)</p>
                            
                            <p>实际上，由于 \(\gcd(4, 6) = 2\) 且 \(2 \nmid 1\)，方程 \(4k \equiv 1 \pmod{6}\) 无解。</p>
                            
                            <p><strong>重新分析：</strong></p>
                            <p>从 \(x \equiv 4 \pmod{6}\) 出发，\(x = 6m + 4\)。代入第一个条件：</p>
                            \[6m + 4 \equiv 3 \pmod{16}\]
                            \[6m \equiv -1 \equiv 15 \pmod{16}\]
                            
                            <p>尝试 \(m = 1\)：\(x = 10\)，检验：\(10 \equiv 10 \pmod{16}\) ✗</p>
                            <p>尝试 \(m = 3\)：\(x = 22\)，检验：\(22 \equiv 6 \pmod{16}\) ✗</p>
                            <p>尝试 \(m = 5\)：\(x = 34\)，检验：\(34 \equiv 2 \pmod{16}\) ✗</p>
                            <p>尝试 \(m = 11\)：\(x = 70\)，检验：\(70 = 4 \times 16 + 6 \equiv 6 \pmod{16}\) ✗</p>
                            <p>尝试 \(m = 13\)：\(x = 82\)，检验：\(82 = 5 \times 16 + 2 \equiv 2 \pmod{16}\) ✗</p>
                            <p>尝试 \(m = 15\)：\(x = 94\)，检验：\(94 = 5 \times 16 + 14 \equiv 14 \pmod{16}\) ✗</p>
                            <p>尝试 \(m = 17\)：\(x = 106\)，检验：\(106 = 6 \times 16 + 10 \equiv 10 \pmod{16}\) ✗</p>
                            <p>尝试 \(m = 19\)：\(x = 118\)，检验：\(118 = 7 \times 16 + 6 \equiv 6 \pmod{16}\) ✗</p>
                            <p>尝试 \(m = 21\)：\(x = 130\)，检验：\(130 = 8 \times 16 + 2 \equiv 2 \pmod{16}\) ✗</p>
                            <p>尝试 \(m = 27\)：\(x = 166\)，检验：\(166 = 10 \times 16 + 6 \equiv 6 \pmod{16}\) ✗</p>
                            <p>尝试 \(m = 29\)：\(x = 178\)，检验：\(178 = 11 \times 16 + 2 \equiv 2 \pmod{16}\) ✗</p>
                            <p>尝试 \(m = 33\)：\(x = 202\)，检验：\(202 = 12 \times 16 + 10 \equiv 10 \pmod{16}\) ✗</p>
                            
                            <p>观察 \(6m \bmod 16\) 的规律：\(6m\) 可取值 \(0, 6, 12, 2, 8, 14, 4, 10, 0, ...\)（周期为 8）</p>
                            <p>由于 15 不在这个集合中，方程无解。</p>
                            
                            <p><strong>结论：</strong>不存在这样的 \(x\)。命题为假。</p>
                        </div>
                    </div>

                    <!-- Problem 7: Modular Potpourri (b) -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis03b.pdf - Problem 2(b)</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>证明或反驳：\(2x \equiv 4 \pmod{12} \Leftrightarrow x \equiv 2 \pmod{12}\)。
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>
                            <p><strong>命题为假。</strong>只有一个方向成立。</p>
                            
                            <p><strong>方向1（→）：</strong>若 \(x \equiv 2 \pmod{12}\)，则</p>
                            \[2x \equiv 2 \cdot 2 \equiv 4 \pmod{12}\]
                            <p>这个方向成立。✓</p>
                            
                            <p><strong>方向2（←）：</strong>若 \(2x \equiv 4 \pmod{12}\)</p>
                            <p>这等价于 \(2x = 4 + 12k\) 对某个整数 \(k\)，即 \(x = 2 + 6k\)。</p>
                            
                            <p><strong>反例：</strong></p>
                            <ul>
                                <li>当 \(k = 0\)：\(x = 2\)，满足 \(x \equiv 2 \pmod{12}\) ✓</li>
                                <li>当 \(k = 1\)：\(x = 8\)，但 \(8 \not\equiv 2 \pmod{12}\) ✗</li>
                            </ul>
                            
                            <p><strong>验证反例：</strong>\(2 \cdot 8 = 16 \equiv 4 \pmod{12}\) ✓</p>
                            
                            <p><strong>结论：</strong>命题不成立。正确的说法应该是：</p>
                            \[2x \equiv 4 \pmod{12} \Leftrightarrow x \equiv 2 \pmod{6}\]
                        </div>
                    </div>

                    <!-- Problem 8: Modular Potpourri (c) -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis03b.pdf - Problem 2(c)</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>证明或反驳：\(2x \equiv 4 \pmod{12} \Leftrightarrow x \equiv 2 \pmod{6}\)。
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>
                            <p><strong>命题为真。</strong></p>
                            
                            <p><strong>方向1（→）：</strong>若 \(2x \equiv 4 \pmod{12}\)</p>
                            <p>则 \(12 \mid (2x - 4)\)，即 \(12 \mid 2(x - 2)\)，所以 \(6 \mid (x - 2)\)。</p>
                            <p>因此 \(x \equiv 2 \pmod{6}\)。✓</p>
                            
                            <p><strong>方向2（←）：</strong>若 \(x \equiv 2 \pmod{6}\)</p>
                            <p>则 \(x = 2 + 6k\) 对某个整数 \(k\)。</p>
                            <p>因此：</p>
                            \[2x = 2(2 + 6k) = 4 + 12k \equiv 4 \pmod{12}\]
                            <p>所以 \(2x \equiv 4 \pmod{12}\)。✓</p>
                            
                            <p><strong>结论：</strong>两个方向都成立，命题为真。</p>
                            
                            <p><strong>一般规律：</strong>对于方程 \(ax \equiv b \pmod{n}\)，若 \(d = \gcd(a, n)\)，则：</p>
                            <ul>
                                <li>若 \(d \nmid b\)，则无解</li>
                                <li>若 \(d \mid b\)，则等价于 \(x \equiv \frac{b}{d} \pmod{\frac{n}{d}}\)</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Problem 9: Modular Inverses (a) -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis03b.pdf - Problem 3(a)</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>3 是否是 5 在模 14 下的逆元？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>
                            <p>需要检验是否 \(5 \cdot 3 \equiv 1 \pmod{14}\)。</p>
                            
                            <p>计算：\(5 \cdot 3 = 15 = 14 + 1 \equiv 1 \pmod{14}\) ✓</p>
                            
                            <p><strong>答案：</strong>是，3 是 5 在模 14 下的逆元。</p>
                        </div>
                    </div>

                    <!-- Problem 10: Modular Inverses (b) -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis03b.pdf - Problem 3(b)</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>3 是否是 5 在模 10 下的逆元？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>
                            <p>需要检验是否 \(5 \cdot 3 \equiv 1 \pmod{10}\)。</p>
                            
                            <p>计算：\(5 \cdot 3 = 15 \equiv 5 \pmod{10}\) ✗</p>
                            
                            <p><strong>答案：</strong>不是，3 不是 5 在模 10 下的逆元。</p>
                            
                            <p><strong>注释：</strong>实际上，5 在模 10 下根本没有逆元，因为 \(\gcd(5, 10) = 5 \neq 1\)。</p>
                        </div>
                    </div>

                    <!-- Problem 11: Modular Inverses (c) -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis03b.pdf - Problem 3(c)</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>对所有 \(n \in \mathbb{N}\)，\(3 + 14n\) 是否是 5 在模 14 下的逆元？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>
                            <p>需要检验对所有自然数 \(n\) 是否 \(5 \cdot (3 + 14n) \equiv 1 \pmod{14}\)。</p>
                            
                            <p>计算：</p>
                            \[\begin{align}
                            5 \cdot (3 + 14n) &= 15 + 70n \\
                            &= (14 + 1) + 70n \\
                            &\equiv 1 + 70n \pmod{14}
                            \end{align}\]
                            
                            <p>现在需要判断 \(70n \equiv 0 \pmod{14}\) 对所有 \(n\) 是否成立：</p>
                            <p>\(70n = 14 \cdot 5n \equiv 0 \pmod{14}\) ✓</p>
                            
                            <p>因此：\(5 \cdot (3 + 14n) \equiv 1 \pmod{14}\) 对所有 \(n \in \mathbb{N}\) 成立。</p>
                            
                            <p><strong>答案：</strong>是，对所有自然数 \(n\)，\(3 + 14n\) 都是 5 在模 14 下的逆元。</p>
                            
                            <p><strong>关键结论：</strong>模逆元在其模同余类下是唯一的，即 \(x\) 和 \(x + m\) 在模 \(m\) 下是相同的逆元。</p>
                        </div>
                    </div>

                    <!-- Problem 12: Modular Inverses (d) -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis03b.pdf - Problem 3(d)</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>4 在模 8 下是否有逆元？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>
                            <p>逆元存在的充要条件是 \(\gcd(a, m) = 1\)。</p>
                            
                            <p>计算：\(\gcd(4, 8) = 4 \neq 1\)</p>
                            
                            <p><strong>答案：</strong>否，4 在模 8 下没有逆元。</p>
                            
                            <p><strong>验证：</strong>检查所有可能的值：</p>
                            <ul>
                                <li>\(4 \cdot 0 = 0 \equiv 0 \pmod{8}\)</li>
                                <li>\(4 \cdot 1 = 4 \equiv 4 \pmod{8}\)</li>
                                <li>\(4 \cdot 2 = 8 \equiv 0 \pmod{8}\)</li>
                                <li>\(4 \cdot 3 = 12 \equiv 4 \pmod{8}\)</li>
                                <li>\(4 \cdot 4 = 16 \equiv 0 \pmod{8}\)</li>
                                <li>\(4 \cdot 5 = 20 \equiv 4 \pmod{8}\)</li>
                                <li>\(4 \cdot 6 = 24 \equiv 0 \pmod{8}\)</li>
                                <li>\(4 \cdot 7 = 28 \equiv 4 \pmod{8}\)</li>
                            </ul>
                            <p>没有任何值使得 \(4x \equiv 1 \pmod{8}\)。</p>
                        </div>
                    </div>

                    <!-- Problem 13: Modular Inverses (e) -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis03b.pdf - Problem 3(e)</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>若 \(x, x' \in \mathbb{Z}\) 都是 \(a\) 在模 \(m\) 下的逆元，是否可能 \(x \not\equiv x' \pmod{m}\)？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>
                            <p><strong>答案：否。</strong>在模 \(m\) 意义下，逆元是唯一的。</p>
                            
                            <p><strong>证明：</strong></p>
                            <p>假设 \(x\) 和 \(x'\) 都是 \(a\) 在模 \(m\) 下的逆元，即：</p>
                            \[ax \equiv 1 \pmod{m} \quad \text{且} \quad ax' \equiv 1 \pmod{m}\]
                            
                            <p>从第一个等式：\(ax \equiv 1 \pmod{m}\)</p>
                            <p>两边同时乘以 \(x'\)：</p>
                            \[x' \cdot ax \equiv x' \cdot 1 \pmod{m}\]
                            \[x' \cdot ax \equiv x' \pmod{m}\]
                            
                            <p>由于乘法交换律：</p>
                            \[ax' \cdot x \equiv x' \pmod{m}\]
                            
                            <p>由第二个等式 \(ax' \equiv 1 \pmod{m}\)，代入得：</p>
                            \[1 \cdot x \equiv x' \pmod{m}\]
                            \[x \equiv x' \pmod{m}\]
                            
                            <p><strong>结论：</strong>若 \(x\) 和 \(x'\) 都是 \(a\) 的逆元，则必有 \(x \equiv x' \pmod{m}\)。</p>
                        </div>
                    </div>

                    <!-- Problem 14: How Many Solutions (a) -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis07a.pdf - Problem 5(a)</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>对于质数 \(p\)，考虑方程 \(ax \equiv b \pmod{p}\)，其中 \(a, b, x \in \{0, 1, \ldots, p-1\}\)。有多少对 \((a, b)\) 使得方程有唯一解？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>
                            <p>方程 \(ax \equiv b \pmod{p}\) 有唯一解当且仅当 \(\gcd(a, p) = 1\)。</p>
                            
                            <p>由于 \(p\) 是质数，\(\gcd(a, p) = 1\) 当且仅当 \(a \neq 0\)。</p>
                            
                            <p>当 \(a \neq 0\) 时，\(a\) 有 \(p - 1\) 种选择（\(1, 2, \ldots, p-1\)）。</p>
                            <p>对于每个这样的 \(a\)，\(b\) 可以是任意值，有 \(p\) 种选择（\(0, 1, \ldots, p-1\)）。</p>
                            
                            <p><strong>答案：</strong>\((p-1) \times p = p(p-1)\) 对</p>
                        </div>
                    </div>

                    <!-- Problem 15: How Many Solutions (b) -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis07a.pdf - Problem 5(b)</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>对于质数 \(p\)，有多少对 \((a, b)\) 使得方程 \(ax \equiv b \pmod{p}\) 无解？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>
                            <p>方程 \(ax \equiv b \pmod{p}\) 无解当且仅当 \(\gcd(a, p) \nmid b\)。</p>
                            
                            <p>情况分析：</p>
                            <ul>
                                <li>若 \(a \neq 0\)：\(\gcd(a, p) = 1\)（因为 \(p\) 是质数），总能整除任何 \(b\)，所以有解。</li>
                                <li>若 \(a = 0\)：方程变为 \(0 \equiv b \pmod{p}\)，只有当 \(b = 0\) 时有解。</li>
                            </ul>
                            
                            <p>因此，无解的情况只有：\(a = 0\) 且 \(b \neq 0\)。</p>
                            
                            <p>这种情况下，\(b\) 有 \(p - 1\) 种选择。</p>
                            
                            <p><strong>答案：</strong>\(p - 1\) 对</p>
                        </div>
                    </div>

                    <!-- Problem 16: How Many Solutions (c) -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis07a.pdf - Problem 5(c)</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>对于质数 \(p\)，有多少对 \((a, b)\) 使得方程 \(ax \equiv b \pmod{p}\) 有 \(p\) 个解？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>
                            <p>方程有 \(p\) 个解意味着对所有 \(x \in \{0, 1, \ldots, p-1\}\) 都满足方程。</p>
                            
                            <p>这只在 \(a = 0\) 且 \(b = 0\) 时发生，因为此时方程变为 \(0 \equiv 0 \pmod{p}\)，恒成立。</p>
                            
                            <p><strong>答案：</strong>1 对（即 \((a, b) = (0, 0)\)）</p>
                        </div>
                    </div>

                    <!-- Problem 17: How Many Solutions (d) -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis07a.pdf - Problem 5(d)</span>
                                <span class="difficulty">⭐⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>对于不同的质数 \(p, q\)，考虑方程 \(ax \equiv b \pmod{pq}\)。若 \(\gcd(a, pq) = p\)，证明存在解当且仅当 \(b \equiv 0 \pmod{p}\)。
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>觨答：</strong>
                            
                            <p><strong>证明（⇒）：</strong>假设存在解 \(x\) 使得 \(ax \equiv b \pmod{pq}\)。</p>
                            
                            <p>这意味着 \(pq \mid (ax - b)\)，即 \(ax - b = kpq\) 对某个整数 \(k\)。</p>
                            
                            <p>由于 \(\gcd(a, pq) = p\)，可以写成 \(a = pm\)，其中 \(\gcd(m, q) = 1\)。</p>
                            
                            <p>代入：\(pmx - b = kpq\)，即 \(b = pmx - kpq = p(mx - kq)\)。</p>
                            
                            <p>因此 \(p \mid b\)，即 \(b \equiv 0 \pmod{p}\)。✓</p>
                            
                            <p><strong>证明（⇐）：</strong>假设 \(b \equiv 0 \pmod{p}\)，即 \(b = pn\) 对某个整数 \(n\)。</p>
                            
                            <p>方程变为：\(pmx \equiv pn \pmod{pq}\)。</p>
                            
                            <p>两边除以 \(p\)：\(mx \equiv n \pmod{q}\)。</p>
                            
                            <p>由于 \(\gcd(m, q) = 1\)，\(m\) 在模 \(q\) 下有逆元，因此这个方程有解。</p>
                            
                            <p>设解为 \(x_0\)，则 \(x_0\) 也是原方程 \(ax \equiv b \pmod{pq}\) 的解。✓</p>
                            
                            <p><strong>结论：</strong>当 \(\gcd(a, pq) = p\) 时，方程有解当且仅当 \(p \mid b\)。</p>
                        </div>
                    </div>

                    <!-- Problem 18: How Many Solutions (e) -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis07a.pdf - Problem 5(e)</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>若 \(\gcd(a, pq) = p\) 且存在解 \(x\)，证明恰有 \(p\) 个解。
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>
                            <p>设 \(x_0\) 是一个解，即 \(ax_0 \equiv b \pmod{pq}\)。</p>
                            
                            <p><strong>生成其他解：</strong>考虑 \(x_0 + q, x_0 + 2q, \ldots, x_0 + (p-1)q\)。</p>
                            
                            <p>对于 \(x = x_0 + kq\)（其中 \(k = 0, 1, \ldots, p-1\)）：</p>
                            \[\begin{align}
                            a(x_0 + kq) &= ax_0 + akq \\
                            &\equiv ax_0 + pmkq \pmod{pq} \quad (\text{因为 } a = pm) \\
                            &\equiv ax_0 \pmod{pq} \quad (\text{因为 } mkq \cdot p = mkpq \equiv 0 \pmod{pq}) \\
                            &\equiv b \pmod{pq}
                            \end{align}\]
                            
                            <p>因此 \(x_0, x_0 + q, x_0 + 2q, \ldots, x_0 + (p-1)q\) 都是解。</p>
                            
                            <p><strong>在 \([0, pq-1]\) 范围内：</strong>这 \(p\) 个解在模 \(pq\) 意义下互不相同。</p>
                            
                            <p><strong>唯一性：</strong>不存在其他解。若 \(x'\) 是另一个解，则：</p>
                            \[ax' \equiv ax_0 \pmod{pq}\]
                            \[a(x' - x_0) \equiv 0 \pmod{pq}\]
                            \[pm(x' - x_0) \equiv 0 \pmod{pq}\]
                            \[m(x' - x_0) \equiv 0 \pmod{q}\]
                            
                            <p>由于 \(\gcd(m, q) = 1\)，必有 \(x' - x_0 \equiv 0 \pmod{q}\)，即 \(x' = x_0 + kq\) 对某个 \(k\)。</p>
                            
                            <p><strong>答案：</strong>恰有 \(p\) 个解。</p>
                        </div>
                    </div>

                    <!-- Problem 19: How Many Solutions (f) -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis07a.pdf - Problem 5(f)</span>
                                <span class="difficulty">⭐⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>对于不同的质数 \(p, q\)，有多少对 \((a, b)\) 使得方程 \(ax \equiv b \pmod{pq}\) 恰有 \(p\) 个解？（其中 \(a, b \in \{0, 1, \ldots, pq-1\}\)）
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>
                            <p>根据前面的分析，恰有 \(p\) 个解当且仅当：</p>
                            <ol>
                                <li>\(\gcd(a, pq) = p\)</li>
                                <li>\(p \mid b\)</li>
                            </ol>
                            
                            <p><strong>计算满足条件的 \(a\) 的个数：</strong></p>
                            <p>\(\gcd(a, pq) = p\) 意味着 \(a = pm\)，其中 \(\gcd(m, q) = 1\) 且 \(1 \leq m \leq q-1\)。</p>
                            <p>由于 \(q\) 是质数，\(\gcd(m, q) = 1\) 对所有 \(m \in \{1, 2, \ldots, q-1\}\) 成立。</p>
                            <p>因此有 \(q - 1\) 个这样的 \(a\)。</p>
                            
                            <p><strong>计算满足条件的 \(b\) 的个数：</strong></p>
                            <p>\(p \mid b\) 且 \(b \in \{0, 1, \ldots, pq-1\}\)。</p>
                            <p>\(b\) 可以是 \(0, p, 2p, \ldots, (q-1)p\)，共 \(q\) 个值。</p>
                            
                            <p><strong>答案：</strong>\((q-1) \times q = q(q-1)\) 对</p>
                            
                            <p><strong>注意：</strong>由对称性，也有 \(p(p-1)\) 对使得恰有 \(q\) 个解（对应 \(\gcd(a, pq) = q\) 的情况）。</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 6.2 GCD 和扩展欧几里得算法 -->
            <div class="subsection" id="section6-2">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    6.2 GCD 和扩展欧几里得算法 (GCD and Extended Euclidean Algorithm)
                </h3>
                <div class="collapsible-content">
                    <div class="concept-box">
                        <h4>📚 核心概念</h4>
                        <p><strong>最大公约数（GCD）：</strong>两个整数 \(a\) 和 \(b\) 的最大公约数是能同时整除 \(a\) 和 \(b\) 的最大正整数，记作 \(\gcd(a, b)\)。</p>

                        <p><strong>欧几里得算法：</strong>基于性质 \(\gcd(a, b) = \gcd(b, a \bmod b)\)，递归计算直到余数为 0。</p>

                        <p><strong>贝祖定理（Bézout's Identity）：</strong>对于整数 \(a, b\)，存在整数 \(x, y\) 使得：</p>
                        \[ax + by = \gcd(a, b)\]

                        <p><strong>扩展欧几里得算法：</strong>不仅计算 \(\gcd(a, b)\)，还求出贝祖等式中的系数 \(x, y\)。</p>
                    </div>

                    <div class="formula-box">
                        <h4>📐 重要公式</h4>
                        <div class="formula-item">
                            <strong>欧几里得算法递归公式：</strong>
                            \[\gcd(a, b) = \begin{cases}
                            a & \text{如果 } b = 0 \\
                            \gcd(b, a \bmod b) & \text{如果 } b \neq 0
                            \end{cases}\]
                        </div>
                        <div class="formula-item">
                            <strong>扩展欧几里得算法：</strong>
                            <p>若 \(ax + by = \gcd(a, b)\)，且 \(\gcd(b, a \bmod b) = bx' + (a \bmod b)y'\)，则：</p>
                            \[\begin{cases}
                            x = y' \\
                            y = x' - \lfloor a/b \rfloor \cdot y'
                            \end{cases}\]
                        </div>
                        <div class="formula-item">
                            <strong>模逆元存在条件：</strong>
                            <p>\(a\) 在模 \(n\) 下有乘法逆元当且仅当 \(\gcd(a, n) = 1\)</p>
                        </div>
                    </div>

                    <div class="tips-box">
                        <h4>💡 解题技巧</h4>
                        <ul>
                            <li>欧几里得算法效率很高，时间复杂度为 \(O(\log \min(a, b))\)</li>
                            <li>扩展欧几里得算法在求模逆元、解线性同余方程时非常有用</li>
                            <li>计算过程中保持 \(ax + by = \gcd(a, b)\) 的不变式</li>
                            <li>可以用表格法追踪扩展欧几里得算法的计算过程</li>
                        </ul>
                    </div>

                    <!-- Problem 1: GCD 与整除性质 -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_fa24.pdf - Q9.1</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>考虑命题：对于整数 \(a, x, y\)，如果 \(\gcd(x, y) = 1\) 且 \(a \mid xy\)，则 \(a \mid x\) 或 \(a \mid y\)。
                            <br><br>
                            (a) 判断命题真假<br>
                            (b) 给出证明或反例
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>(a) 答案：False（假）</strong></p>

                            <p><strong>(b) 反例：</strong></p>
                            <p>取 \(a = 6\)，\(x = 2\)，\(y = 3\)。</p>

                            <p><strong>验证：</strong></p>
                            <ul>
                                <li>\(\gcd(2, 3) = 1\) ✓</li>
                                <li>\(xy = 2 \times 3 = 6\)，所以 \(a \mid xy\)（因为 \(6 \mid 6\)）✓</li>
                                <li>但是 \(6 \nmid 2\)（因为 \(2 < 6\)）</li>
                                <li>且 \(6 \nmid 3\)（因为 \(3 < 6\)）</li>
                            </ul>

                            <p>因此，存在满足前提条件但不满足结论的情况，命题为假。</p>

                            <p><strong>注意：</strong>如果将命题改为"如果 \(\gcd(a, x) = 1\) 且 \(a \mid xy\)，则 \(a \mid y\)"，这个命题就是真的（欧几里得引理）。</p>
                        </div>
                    </div>

                    <!-- Problem 2: 扩展欧几里得算法应用 -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_fa24.pdf - Q11.3</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>对于整数 \(x \neq y\) 和 \(m, n\) 其中 \(\gcd(m, n) = d\)，如果 \(x \equiv y \pmod{n}\) 且 \(x \equiv y \pmod{m}\)，则 \(|x - y| \geq\) ___。
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>分析：</strong></p>
                            <p>条件告诉我们：</p>
                            <ul>
                                <li>\(x \equiv y \pmod{n}\) 意味着 \(n \mid (x - y)\)</li>
                                <li>\(x \equiv y \pmod{m}\) 意味着 \(m \mid (x - y)\)</li>
                            </ul>

                            <p>如果 \(n \mid (x - y)\) 且 \(m \mid (x - y)\)，则 \(\text{lcm}(m, n) \mid (x - y)\)。</p>

                            <p><strong>关键公式：</strong></p>
                            \[\text{lcm}(m, n) = \frac{m \cdot n}{\gcd(m, n)} = \frac{mn}{d}\]

                            <p><strong>结论：</strong></p>
                            <p>因为 \(\text{lcm}(m, n) \mid (x - y)\) 且 \(x \neq y\)，所以：</p>
                            \[|x - y| \geq \text{lcm}(m, n) = \frac{mn}{d}\]

                            <p><strong>答案：</strong>\(|x - y| \geq \dfrac{mn}{d}\) 或 \(|x - y| \geq \text{lcm}(m, n)\)</p>
                        </div>
                    </div>

                    <!-- Problem 3: Extended Euclid (a) -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis04a.pdf - Problem 1(a)</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>假设我们已经找到 \(a\) 和 \(b\) 使得 \(54a + 17b = 1\)。有了这个知识，\(17^{-1} \pmod{54}\) 是多少？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>
                            <p>由 \(54a + 17b = 1\)，我们可以写为：</p>
                            \[17b = 1 - 54a\]
                            
                            <p>两边模 54：</p>
                            \[17b \equiv 1 \pmod{54}\]
                            
                            <p>这正是逆元的定义！因此 \(b\) 就是 17 在模 54 下的逆元。</p>
                            
                            <p><strong>答案：</strong>\(17^{-1} \equiv b \pmod{54}\)</p>
                            
                            <p><strong>注释：</strong>扩展欧几里得算法找到的系数 \(b\) 直接给出了逆元。</p>
                        </div>
                    </div>

                    <!-- Problem 4: Extended Euclid - Recursive Method -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis04a.pdf - Problem 1(b-c)</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>使用递归方法计算 \(\gcd(54, 17)\)，并表示为 \(54\) 和 \(17\) 的线性组合。求 \(17^{-1} \pmod{54}\)。
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>
                            
                            <p><strong>步骤1：欧几里得算法前向过程</strong></p>
                            \[\begin{align}
                            \gcd(54, 17) &= \gcd(17, 3) &\quad 3 &= 54 - 3 \times 17 \\
                            &= \gcd(3, 2) &\quad 2 &= 17 - 5 \times 3 \\
                            &= \gcd(2, 1) &\quad 1 &= 3 - 1 \times 2 \\
                            &= \gcd(1, 0) \\
                            &= 1
                            \end{align}\]
                            
                            <p><strong>步骤2：回代过程（从下往上）</strong></p>
                            <p>目标：填充 \(1 = \_ \times 54 + \_ \times 17\)</p>
                            
                            <p>从 \(1 = 3 - 1 \times 2\) 开始：</p>
                            \[\begin{align}
                            1 &= 3 - 1 \times 2 \\
                            &= 3 - 1 \times (17 - 5 \times 3) &\quad (\text{替换 } 2 = 17 - 5 \times 3) \\
                            &= 3 - 17 + 5 \times 3 \\
                            &= 6 \times 3 - 1 \times 17 \\
                            &= 6 \times (54 - 3 \times 17) - 1 \times 17 &\quad (\text{替换 } 3 = 54 - 3 \times 17) \\
                            &= 6 \times 54 - 18 \times 17 - 1 \times 17 \\
                            &= 6 \times 54 - 19 \times 17
                            \end{align}\]
                            
                            <p><strong>结果：</strong>\(1 = 6 \times 54 + (-19) \times 17\)</p>
                            
                            <p><strong>求逆元：</strong></p>
                            <p>由 \(17 \times (-19) \equiv 1 \pmod{54}\)</p>
                            <p>转换为正数：\(-19 + 54 = 35\)</p>
                            
                            <p><strong>答案：</strong>\(17^{-1} \equiv 35 \pmod{54}\)</p>
                            
                            <p><strong>验证：</strong>\(17 \times 35 = 595 = 54 \times 11 + 1 \equiv 1 \pmod{54}\) ✓</p>
                        </div>
                    </div>

                    <!-- Problem 5: Extended Euclid - Iterative Method -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis04a.pdf - Problem 1(d)</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>使用迭代方法计算 \(\gcd(54, 17)\) 并表示为线性组合。验证结果与递归方法一致。
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>
                            
                            <p><strong>迭代方法：</strong>维护方程，每步将当前值表示为 54 和 17 的线性组合。</p>
                            
                            <p><strong>初始化：</strong></p>
                            \[\begin{align}
                            E_1: \quad 54 &= 1 \times 54 + 0 \times 17 \\
                            E_2: \quad 17 &= 0 \times 54 + 1 \times 17
                            \end{align}\]
                            
                            <p><strong>迭代过程：</strong></p>
                            <p>\(E_3 = E_1 - 3 \times E_2\) （因为 \(54 = 3 \times 17 + 3\)）：</p>
                            \[3 = 54 - 3 \times 17 = 1 \times 54 + (-3) \times 17\]
                            
                            <p>\(E_4 = E_2 - 5 \times E_3\) （因为 \(17 = 5 \times 3 + 2\)）：</p>
                            \[\begin{align}
                            2 &= 17 - 5 \times 3 \\
                            &= (0 \times 54 + 1 \times 17) - 5 \times (1 \times 54 + (-3) \times 17) \\
                            &= -5 \times 54 + 16 \times 17
                            \end{align}\]
                            
                            <p>\(E_5 = E_3 - 1 \times E_4\) （因为 \(3 = 1 \times 2 + 1\)）：</p>
                            \[\begin{align}
                            1 &= 3 - 1 \times 2 \\
                            &= (1 \times 54 + (-3) \times 17) - 1 \times (-5 \times 54 + 16 \times 17) \\
                            &= (1 - (-5)) \times 54 + (-3 - 16) \times 17 \\
                            &= 6 \times 54 + (-19) \times 17
                            \end{align}\]
                            
                            <p><strong>结果：</strong>\(1 = 6 \times 54 + (-19) \times 17\)</p>
                            
                            <p><strong>逆元：</strong>\(17^{-1} \equiv -19 \equiv 35 \pmod{54}\)</p>
                            
                            <p><strong>验证：</strong>与递归方法结果一致！✓</p>
                        </div>
                    </div>

                    <!-- Problem 6: Extended Euclid - Another Example -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis04a.pdf - Problem 1(e)</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>计算 \(\gcd(17, 39)\)，并将其表示为 17 和 39 的线性组合。\(17\) 在模 39 下是否有逆元？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>
                            
                            <p><strong>步骤1：计算 GCD</strong></p>
                            \[\begin{align}
                            \gcd(39, 17) &= \gcd(17, 5) &\quad 5 &= 39 - 2 \times 17 \\
                            &= \gcd(5, 2) &\quad 2 &= 17 - 3 \times 5 \\
                            &= \gcd(2, 1) &\quad 1 &= 5 - 2 \times 2 \\
                            &= \gcd(1, 0) \\
                            &= 1
                            \end{align}\]
                            
                            <p><strong>步骤2：回代表示为线性组合</strong></p>
                            \[\begin{align}
                            1 &= 5 - 2 \times 2 \\
                            &= 5 - 2 \times (17 - 3 \times 5) \\
                            &= 5 - 2 \times 17 + 6 \times 5 \\
                            &= 7 \times 5 - 2 \times 17 \\
                            &= 7 \times (39 - 2 \times 17) - 2 \times 17 \\
                            &= 7 \times 39 - 14 \times 17 - 2 \times 17 \\
                            &= 7 \times 39 + (-16) \times 17
                            \end{align}\]
                            
                            <p><strong>结果：</strong>\(1 = (-16) \times 17 + 7 \times 39\)</p>
                            
                            <p><strong>逆元问题：</strong></p>
                            <p>由于 \(\gcd(17, 39) = 1\)，17 在模 39 下<strong>有逆元</strong>。</p>
                            
                            <p>由 \(17 \times (-16) \equiv 1 \pmod{39}\)</p>
                            <p>转换为正数：\(-16 + 39 = 23\)</p>
                            
                            <p><strong>答案：</strong>是，\(17^{-1} \equiv 23 \pmod{39}\)</p>
                            
                            <p><strong>验证：</strong>\(17 \times 23 = 391 = 39 \times 10 + 1 \equiv 1 \pmod{39}\) ✓</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 6.3 费马小定理 -->
            <div class="subsection" id="section6-3">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    6.3 费马小定理 (Fermat's Little Theorem)
                </h3>
                <div class="collapsible-content">
                    <div class="concept-box">
                        <h4>📚 核心概念</h4>
                        <p><strong>费马小定理：</strong>如果 \(p\) 是素数，\(a\) 是不被 \(p\) 整除的整数（即 \(\gcd(a, p) = 1\)），则：</p>
                        \[a^{p-1} \equiv 1 \pmod{p}\]

                        <p><strong>推论形式：</strong>对于任意整数 \(a\) 和素数 \(p\)：</p>
                        \[a^p \equiv a \pmod{p}\]

                        <p><strong>应用：</strong></p>
                        <ul>
                            <li>计算大数的模幂运算</li>
                            <li>求模逆元：\(a^{-1} \equiv a^{p-2} \pmod{p}\)（当 \(p\) 为素数且 \(\gcd(a, p) = 1\) 时）</li>
                            <li>素性测试（费马测试）</li>
                        </ul>
                    </div>

                    <div class="formula-box">
                        <h4>📐 重要公式</h4>
                        <div class="formula-item">
                            <strong>费马小定理：</strong>
                            \[a^{p-1} \equiv 1 \pmod{p} \quad (\text{当 } p \text{ 是素数且 } p \nmid a)\]
                        </div>
                        <div class="formula-item">
                            <strong>模逆元计算：</strong>
                            \[a^{-1} \equiv a^{p-2} \pmod{p}\]
                        </div>
                        <div class="formula-item">
                            <strong>欧拉定理（费马小定理的推广）：</strong>
                            <p>如果 \(\gcd(a, n) = 1\)，则：</p>
                            \[a^{\phi(n)} \equiv 1 \pmod{n}\]
                            <p>其中 \(\phi(n)\) 是欧拉函数，表示小于 \(n\) 且与 \(n\) 互质的正整数个数。</p>
                        </div>
                    </div>

                    <div class="tips-box">
                        <h4>💡 解题技巧</h4>
                        <ul>
                            <li>费马小定理只适用于素数模数，使用前先确认模数是否为素数</li>
                            <li>计算 \(a^k \bmod p\) 时，可以先将指数 \(k\) 模 \(p-1\)：\(a^k \equiv a^{k \bmod (p-1)} \pmod{p}\)</li>
                            <li>对于合数模数，需要使用欧拉定理</li>
                            <li>费马小定理是 RSA 加密算法的数学基础之一</li>
                        </ul>
                    </div>

                    <!-- Problem 1: 费马小定理应用 -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_fa24.pdf - Q9.2(b)</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>设 \(N = pqr\)，其中 \(p, q, r\) 是不同的素数。如果 \(\gcd(x, N) = 1\)，求 \(x^{(p-1)(q-1)(r-1)} \pmod{N}\)。
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>方法：分别考虑模 \(p\)、模 \(q\)、模 \(r\)，然后用中国剩余定理。</strong></p>

                            <p><strong>步骤1：</strong>计算 \(x^{(p-1)(q-1)(r-1)} \pmod{p}\)</p>
                            <p>因为 \(\gcd(x, N) = 1\)，所以 \(\gcd(x, p) = 1\)（\(p \nmid x\)）。</p>
                            <p>由费马小定理：\(x^{p-1} \equiv 1 \pmod{p}\)</p>
                            <p>因此：</p>
                            \[\begin{align}
                            x^{(p-1)(q-1)(r-1)} &= \left(x^{p-1}\right)^{(q-1)(r-1)} \\
                            &\equiv 1^{(q-1)(r-1)} \pmod{p} \\
                            &\equiv 1 \pmod{p}
                            \end{align}\]

                            <p><strong>步骤2：</strong>同理，计算模 \(q\) 和模 \(r\)：</p>
                            \[\begin{align}
                            x^{(p-1)(q-1)(r-1)} &\equiv 1 \pmod{q} \\
                            x^{(p-1)(q-1)(r-1)} &\equiv 1 \pmod{r}
                            \end{align}\]

                            <p><strong>步骤3：</strong>由中国剩余定理：</p>
                            <p>因为 \(p, q, r\) 两两互质，且</p>
                            \[x^{(p-1)(q-1)(r-1)} \equiv 1 \pmod{p}, \quad x^{(p-1)(q-1)(r-1)} \equiv 1 \pmod{q}, \quad x^{(p-1)(q-1)(r-1)} \equiv 1 \pmod{r}\]
                            <p>所以：</p>
                            \[x^{(p-1)(q-1)(r-1)} \equiv 1 \pmod{pqr} = 1 \pmod{N}\]

                            <p><strong>答案：</strong>\(x^{(p-1)(q-1)(r-1)} \equiv 1 \pmod{N}\)</p>
                        </div>
                    </div>

                    <!-- Problem 2: Order 的性质 -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_fa24.pdf - Q10</span>
                                <span class="difficulty">⭐⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>定义 \(\text{ord}_n(a) = m\) 为使得 \(a^m \equiv 1 \pmod{n}\) 的最小正整数 \(m\)。
                            <br><br>
                            (a) \(\text{ord}_5(3) =\) ?<br>
                            (b) 证明：\(a^m \equiv 1 \pmod{n}\) 当且仅当 \(\text{ord}_n(a) \mid m\)<br>
                            (c) 证明：如果 \(p\) 是素数且 \(p \nmid a\)，则 \(\text{ord}_p(a) \mid (p-1)\)
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>(a) 计算 \(\text{ord}_5(3)\)：</strong></p>
                            \[\begin{align}
                            3^1 &\equiv 3 \pmod{5} \\
                            3^2 &\equiv 9 \equiv 4 \pmod{5} \\
                            3^3 &\equiv 3 \cdot 4 \equiv 12 \equiv 2 \pmod{5} \\
                            3^4 &\equiv 3 \cdot 2 \equiv 6 \equiv 1 \pmod{5}
                            \end{align}\]
                            <p><strong>答案：</strong>\(\text{ord}_5(3) = 4\)</p>

                            <p><strong>(b) 证明 \(a^m \equiv 1 \pmod{n} \Leftrightarrow \text{ord}_n(a) \mid m\)：</strong></p>

                            <p><strong>(\(\Rightarrow\)) 必要性：</strong>假设 \(a^m \equiv 1 \pmod{n}\)，设 \(d = \text{ord}_n(a)\)。</p>
                            <p>用带余除法：\(m = qd + r\)，其中 \(0 \leq r < d\)。</p>
                            \[\begin{align}
                            a^m &= a^{qd + r} = (a^d)^q \cdot a^r \\
                            &\equiv 1^q \cdot a^r \pmod{n} \quad (\text{因为 } a^d \equiv 1) \\
                            &\equiv a^r \pmod{n}
                            \end{align}\]
                            <p>因为 \(a^m \equiv 1 \pmod{n}\)，所以 \(a^r \equiv 1 \pmod{n}\)。</p>
                            <p>但 \(d\) 是使 \(a^k \equiv 1 \pmod{n}\) 的最小正整数，且 \(0 \leq r < d\)，所以必须 \(r = 0\)。</p>
                            <p>因此 \(m = qd\)，即 \(d \mid m\)。</p>

                            <p><strong>(\(\Leftarrow\)) 充分性：</strong>如果 \(\text{ord}_n(a) \mid m\)，即 \(m = kd\)（其中 \(d = \text{ord}_n(a)\)），则：</p>
                            \[a^m = a^{kd} = (a^d)^k \equiv 1^k = 1 \pmod{n}\]

                            <p><strong>(c) 证明 \(\text{ord}_p(a) \mid (p-1)\)：</strong></p>
                            <p>由费马小定理，当 \(p\) 是素数且 \(p \nmid a\) 时：</p>
                            \[a^{p-1} \equiv 1 \pmod{p}\]
                            <p>由 (b) 的结论，\(a^{p-1} \equiv 1 \pmod{p}\) 意味着 \(\text{ord}_p(a) \mid (p-1)\)。</p>
                        </div>
                    </div>

                    <!-- Problem 3: 证明不存在整数 -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_fa24.pdf - Q10.4</span>
                                <span class="difficulty">⭐⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>证明不存在整数 \(n > 1\) 使得 \(n \mid (2^n - 1)\)。
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>证明：</strong>

                            <p>用反证法。假设存在 \(n > 1\) 使得 \(n \mid (2^n - 1)\)。</p>

                            <p><strong>情况1：\(n\) 是偶数</strong></p>
                            <p>如果 \(n\) 是偶数，则 \(2 \mid n\)。</p>
                            <p>但 \(2^n - 1\) 是奇数（2 的任何次方都是偶数，减 1 得奇数）。</p>
                            <p>所以 \(2 \nmid (2^n - 1)\)，矛盾（因为 \(n \mid (2^n - 1)\) 意味着 \(2 \mid (2^n - 1)\)）。</p>

                            <p><strong>情况2：\(n\) 是奇数</strong></p>
                            <p>设 \(n\) 有素因子 \(p\)（\(n > 1\) 必有素因子）。</p>
                            <p>因为 \(n\) 是奇数，所以 \(p\) 也是奇数素数（\(p \neq 2\)）。</p>

                            <p>因为 \(p \mid n\) 且 \(n \mid (2^n - 1)\)，所以 \(p \mid (2^n - 1)\)，即：</p>
                            \[2^n \equiv 1 \pmod{p}\]

                            <p>设 \(d = \text{ord}_p(2)\)（2 在模 \(p\) 下的阶）。由上一题的结论，\(d \mid n\)。</p>

                            <p>另外，由费马小定理：\(2^{p-1} \equiv 1 \pmod{p}\)，所以 \(d \mid (p-1)\)。</p>

                            <p>因为 \(d \mid n\) 且 \(d \mid (p-1)\)，所以 \(d \mid \gcd(n, p-1)\)。</p>

                            <p>因为 \(p \mid n\)，可以写 \(n = kp\)（其中 \(k \geq 1\)）。</p>
                            \[\begin{align}
                            \gcd(n, p-1) &= \gcd(kp, p-1) \\
                            &= \gcd(kp, p-1)
                            \end{align}\]

                            <p>因为 \(\gcd(p, p-1) = 1\)（连续整数互质），所以：</p>
                            \[\gcd(kp, p-1) = \gcd(k, p-1)\]

                            <p>现在，因为 \(p \mid n\)，我们有 \(n \geq p\)。</p>
                            <p>如果 \(n = p\)，则 \(d \mid \gcd(p, p-1) = 1\)，所以 \(d = 1\)。</p>
                            <p>这意味着 \(2^1 \equiv 1 \pmod{p}\)，即 \(p \mid 1\)，矛盾。</p>

                            <p>如果 \(n > p\)，则 \(k > 1\)，所以 \(n = kp > p\)。</p>
                            <p>因为 \(d \mid n\) 且 \(d \mid (p-1)\)，且 \(p-1 < p < n\)，所以 \(d < n\)。</p>
                            <p>但 \(2^n \equiv 1 \pmod{p}\) 且 \(d = \text{ord}_p(2)\)，所以 \(d \mid n\)。</p>

                            <p>关键观察：\(d \mid (p-1) < p \leq n\)，所以 \(d < n\)。</p>
                            <p>但 \(2^d \equiv 1 \pmod{p}\) 且 \(2^n \equiv 1 \pmod{p}\)，结合 \(n = kp\) 和 \(d < p\)：</p>
                            <p>这导致矛盾，因为 \(d\) 必须整除 \(n\) 和 \(p-1\)，但它们的最大公约数小于 \(n\)。</p>

                            <p><strong>结论：</strong>不存在 \(n > 1\) 使得 \(n \mid (2^n - 1)\)。</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 6.4 中国剩余定理 -->
            <div class="subsection" id="section6-4">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    6.4 中国剩余定理 (Chinese Remainder Theorem)
                </h3>
                <div class="collapsible-content">
                    <div class="concept-box">
                        <h4>📚 核心概念</h4>
                        <p><strong>中国剩余定理（CRT）：</strong>设 \(n_1, n_2, \ldots, n_k\) 是两两互质的正整数，则对于任意整数 \(a_1, a_2, \ldots, a_k\)，同余方程组：</p>
                        \[\begin{cases}
                        x \equiv a_1 \pmod{n_1} \\
                        x \equiv a_2 \pmod{n_2} \\
                        \vdots \\
                        x \equiv a_k \pmod{n_k}
                        \end{cases}\]
                        <p>在模 \(N = n_1 n_2 \cdots n_k\) 下有唯一解。</p>

                        <p><strong>解的构造：</strong>设 \(N_i = N / n_i\)，\(M_i = N_i^{-1} \pmod{n_i}\)，则解为：</p>
                        \[x \equiv \sum_{i=1}^{k} a_i N_i M_i \pmod{N}\]
                    </div>

                    <div class="formula-box">
                        <h4>📐 重要公式</h4>
                        <div class="formula-item">
                            <strong>CRT 通用解法：</strong>
                            <p>1. 计算 \(N = n_1 n_2 \cdots n_k\)</p>
                            <p>2. 对每个 \(i\)，计算 \(N_i = N / n_i\)</p>
                            <p>3. 求 \(M_i\) 使得 \(N_i M_i \equiv 1 \pmod{n_i}\)</p>
                            <p>4. 解为 \(x = \sum_{i=1}^{k} a_i N_i M_i \pmod{N}\)</p>
                        </div>
                        <div class="formula-item">
                            <strong>线性同余方程求解：</strong>
                            <p>\(ax \equiv b \pmod{n}\) 有解当且仅当 \(\gcd(a, n) \mid b\)</p>
                            <p>解的个数为 \(\gcd(a, n)\)</p>
                        </div>
                    </div>

                    <div class="tips-box">
                        <h4>💡 解题技巧</h4>
                        <ul>
                            <li>CRT 要求模数两两互质，使用前先验证这个条件</li>
                            <li>\(M_i\) 是 \(N_i\) 在模 \(n_i\) 下的乘法逆元，可用扩展欧几里得算法求</li>
                            <li>最终答案在 \([0, N-1]\) 范围内，需要对 \(N\) 取模</li>
                            <li>对于非互质情况，需要先判断是否有解，再转化为互质情况</li>
                        </ul>
                    </div>

                    <!-- Problem 1: 水果沙拉问题 -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_sp24.pdf - Q8(b)</span>
                                <span class="difficulty">⭐⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>Nathan 想做他最喜欢的热带三重奏水果沙拉，需要荔枝（L）、芒果（M）和百香果（P）。超市很少备这些水果：
                            <ul>
                                <li>荔枝每 5 天出现一次，最后一次是 3 天前</li>
                                <li>芒果每 3 天出现一次，最后一次是 1 天前</li>
                                <li>百香果每 11 天出现一次，最后一次是 2 天前</li>
                            </ul>
                            沙拉必须在购买当天制作。Nathan 最早在多少天后能同时买到全部三种水果？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>建立同余方程组：</strong></p>
                            <p>设 \(x\) 天后能同时买到三种水果。需要满足：</p>
                            <ul>
                                <li>荔枝：上次是 3 天前，周期 5 天，所以 \(x \equiv 3 - 3 \equiv 2 \pmod{5}\)</li>
                                <li>芒果：上次是 1 天前，周期 3 天，所以 \(x \equiv 3 - 1 \equiv 2 \pmod{3}\)</li>
                                <li>百香果：上次是 2 天前，周期 11 天，所以 \(x \equiv 11 - 2 \equiv 9 \pmod{11}\)</li>
                            </ul>

                            <p>实际上，更直接的理解：</p>
                            <ul>
                                <li>荔枝在第 2, 7, 12, 17, 22, ... 天出现</li>
                                <li>芒果在第 2, 5, 8, 11, 14, 17, 20, 23, ... 天出现</li>
                                <li>百香果在第 9, 20, 31, ... 天出现</li>
                            </ul>

                            <p>所以方程组为：</p>
                            \[\begin{cases}
                            x \equiv 2 \pmod{5} \\
                            x \equiv 2 \pmod{3} \\
                            x \equiv 9 \pmod{11}
                            \end{cases}\]

                            <p><strong>应用中国剩余定理：</strong></p>

                            <p><strong>步骤1：</strong>验证 \(\gcd(5, 3) = \gcd(5, 11) = \gcd(3, 11) = 1\) ✓</p>

                            <p><strong>步骤2：</strong>计算 \(N = 5 \times 3 \times 11 = 165\)</p>

                            <p><strong>步骤3：</strong>先合并前两个方程：</p>
                            <p>\(x \equiv 2 \pmod{5}\) 且 \(x \equiv 2 \pmod{3}\)</p>
                            <p>因为两边都是 2，所以 \(x \equiv 2 \pmod{15}\)（\(\text{lcm}(5,3) = 15\)）</p>

                            <p><strong>步骤4：</strong>现在求解：</p>
                            \[\begin{cases}
                            x \equiv 2 \pmod{15} \\
                            x \equiv 9 \pmod{11}
                            \end{cases}\]

                            <p>设 \(N_1 = 11\)，\(N_2 = 15\)。</p>

                            <p>求 \(M_1\) 使得 \(11M_1 \equiv 1 \pmod{15}\)：</p>
                            <p>\(11 \equiv -4 \pmod{15}\)，所以 \(-4M_1 \equiv 1 \pmod{15}\)</p>
                            <p>\(M_1 \equiv -4^{-1} \equiv 11 \pmod{15}\)（因为 \((-4) \times 11 = -44 = -45 + 1 \equiv 1 \pmod{15}\)）</p>

                            <p>求 \(M_2\) 使得 \(15M_2 \equiv 1 \pmod{11}\)：</p>
                            <p>\(15 \equiv 4 \pmod{11}\)，所以 \(4M_2 \equiv 1 \pmod{11}\)</p>
                            <p>\(M_2 \equiv 4^{-1} \equiv 3 \pmod{11}\)（因为 \(4 \times 3 = 12 \equiv 1 \pmod{11}\)）</p>

                            <p><strong>步骤5：</strong>计算解：</p>
                            \[\begin{align}
                            x &\equiv 2 \times 11 \times 11 + 9 \times 15 \times 3 \pmod{165} \\
                            &\equiv 242 + 405 \pmod{165} \\
                            &\equiv 647 \pmod{165} \\
                            &\equiv 647 - 3 \times 165 \pmod{165} \\
                            &\equiv 647 - 495 \pmod{165} \\
                            &\equiv 152 \pmod{165}
                            \end{align}\]

                            <p><strong>验证：</strong></p>
                            <ul>
                                <li>\(152 = 30 \times 5 + 2 \equiv 2 \pmod{5}\) ✓</li>
                                <li>\(152 = 50 \times 3 + 2 \equiv 2 \pmod{3}\) ✓</li>
                                <li>\(152 = 13 \times 11 + 9 \equiv 9 \pmod{11}\) ✓</li>
                            </ul>

                            <p><strong>答案：</strong>Nathan 最早在 <strong>152 天</strong>后能同时买到全部三种水果。</p>
                        </div>
                    </div>

                    <!-- Problem 2: 线性同余方程 -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_fa24.pdf - Q11.4</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>求方程 \(10x \equiv 5 \pmod{505}\) 在 \(x \in \{0, 1, \ldots, 504\}\) 中有多少个解。
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>步骤1：</strong>计算 \(\gcd(10, 505)\)：</p>
                            <p>\(505 = 5 \times 101\)，\(10 = 2 \times 5\)</p>
                            <p>所以 \(\gcd(10, 505) = 5\)</p>

                            <p><strong>步骤2：</strong>检查是否有解：</p>
                            <p>方程 \(10x \equiv 5 \pmod{505}\) 有解当且仅当 \(\gcd(10, 505) \mid 5\)</p>
                            <p>因为 \(5 \mid 5\) ✓，所以有解。</p>

                            <p><strong>步骤3：</strong>简化方程：</p>
                            <p>将方程两边除以 \(\gcd(10, 505) = 5\)：</p>
                            \[\frac{10}{5}x \equiv \frac{5}{5} \pmod{\frac{505}{5}}\]
                            \[2x \equiv 1 \pmod{101}\]

                            <p><strong>步骤4：</strong>求解简化后的方程：</p>
                            <p>求 \(2^{-1} \pmod{101}\)：</p>
                            <p>用扩展欧几里得算法或观察：\(2 \times 51 = 102 = 101 + 1 \equiv 1 \pmod{101}\)</p>
                            <p>所以 \(2^{-1} \equiv 51 \pmod{101}\)</p>

                            <p>因此：\(x \equiv 51 \pmod{101}\)</p>

                            <p><strong>步骤5：</strong>在原范围内找所有解：</p>
                            <p>通解为 \(x = 51 + 101k\)，其中 \(k\) 是整数。</p>
                            <p>在 \([0, 504]\) 范围内：</p>
                            <ul>
                                <li>\(k = 0\): \(x = 51\)</li>
                                <li>\(k = 1\): \(x = 152\)</li>
                                <li>\(k = 2\): \(x = 253\)</li>
                                <li>\(k = 3\): \(x = 354\)</li>
                                <li>\(k = 4\): \(x = 455\)</li>
                                <li>\(k = 5\): \(x = 556 > 504\)</li>
                            </ul>

                            <p><strong>理论解释：</strong>线性同余方程 \(ax \equiv b \pmod{n}\) 的解数等于 \(\gcd(a, n)\)（当有解时）。</p>
                            <p>在本题中，\(\gcd(10, 505) = 5\)。</p>

                            <p><strong>答案：</strong>有 <strong>5</strong> 个解。</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 6.5 RSA 加密 -->
            <div class="subsection" id="section6-5">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    6.5 RSA 加密 (RSA Encryption)
                </h3>
                <div class="collapsible-content">
                    <div class="concept-box">
                        <h4>📚 核心概念</h4>
                        <p><strong>RSA 加密系统：</strong>一种非对称加密算法，基于大数因式分解的困难性。</p>

                        <p><strong>密钥生成：</strong></p>
                        <ol>
                            <li>选择两个大素数 \(p, q\)</li>
                            <li>计算 \(N = pq\)</li>
                            <li>计算欧拉函数 \(\phi(N) = (p-1)(q-1)\)</li>
                            <li>选择公钥指数 \(e\)，满足 \(\gcd(e, \phi(N)) = 1\)</li>
                            <li>计算私钥指数 \(d\)，使得 \(ed \equiv 1 \pmod{\phi(N)}\)</li>
                        </ol>

                        <p><strong>加密与解密：</strong></p>
                        <ul>
                            <li><strong>公钥：</strong>\((N, e)\)</li>
                            <li><strong>私钥：</strong>\((N, d)\)</li>
                            <li><strong>加密：</strong>\(c \equiv m^e \pmod{N}\)</li>
                            <li><strong>解密：</strong>\(m \equiv c^d \pmod{N}\)</li>
                        </ul>

                        <p><strong>正确性基础：</strong>由欧拉定理，如果 \(\gcd(m, N) = 1\)，则：</p>
                        \[m^{\phi(N)} \equiv 1 \pmod{N}\]
                        <p>因为 \(ed \equiv 1 \pmod{\phi(N)}\)，所以 \(ed = k\phi(N) + 1\)，因此：</p>
                        \[c^d = (m^e)^d = m^{ed} = m^{k\phi(N)+1} = (m^{\phi(N)})^k \cdot m \equiv m \pmod{N}\]
                    </div>

                    <div class="formula-box">
                        <h4>📐 重要公式</h4>
                        <div class="formula-item">
                            <strong>欧拉函数（对于两个素数的乘积）：</strong>
                            \[\phi(N) = \phi(pq) = (p-1)(q-1)\]
                        </div>
                        <div class="formula-item">
                            <strong>RSA 加密：</strong>
                            \[E(m) = m^e \pmod{N}\]
                        </div>
                        <div class="formula-item">
                            <strong>RSA 解密：</strong>
                            \[D(c) = c^d \pmod{N}\]
                        </div>
                        <div class="formula-item">
                            <strong>密钥关系：</strong>
                            \[ed \equiv 1 \pmod{(p-1)(q-1)}\]
                        </div>
                    </div>

                    <div class="tips-box">
                        <h4>💡 解题技巧</h4>
                        <ul>
                            <li>计算 \(d\) 时使用扩展欧几里得算法求 \(e\) 在模 \(\phi(N)\) 下的逆元</li>
                            <li>实际应用中 \(p, q\) 通常是几百位的大素数，但考试中会使用小数字</li>
                            <li>RSA 的安全性依赖于因式分解 \(N\) 的困难性</li>
                            <li>加密和解密操作是对称的：\(D(E(m)) = E(D(m)) = m\)</li>
                            <li>可以用中国剩余定理加速 RSA 解密运算</li>
                        </ul>
                    </div>

                    <!-- Problem 1: RSA 基本运算 -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_sp24.pdf - Q8(iv-vi)</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>Bob 实现 RSA 加密，使用素数 \(p = 7\)，\(q = 11\) 和 \(e = 11\)。
                            <br><br>
                            (iv) Bob 的公钥是什么？<br>
                            (v) 如果 Carol 想发送消息 \(x = 3\) 给 Bob，她应该发送什么加密值？<br>
                            (vi) 如果 Bob 收到 Carol 的加密消息 \(y = 47\)，Carol 的原始消息是什么？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>(iv) 计算公钥 \((N, e)\)：</strong></p>
                            \[N = pq = 7 \times 11 = 77\]
                            <p><strong>答案：</strong>公钥是 \((77, 11)\)</p>

                            <p><strong>(v) Carol 加密消息 \(x = 3\)：</strong></p>
                            <p>加密公式：\(c \equiv x^e \pmod{N}\)</p>
                            \[\begin{align}
                            c &\equiv 3^{11} \pmod{77}
                            \end{align}\]

                            <p>计算 \(3^{11} \bmod 77\) 使用快速幂：</p>
                            \[\begin{align}
                            3^1 &\equiv 3 \pmod{77} \\
                            3^2 &\equiv 9 \pmod{77} \\
                            3^4 &\equiv 81 \equiv 4 \pmod{77} \\
                            3^8 &\equiv 16 \pmod{77} \\
                            3^{11} &= 3^8 \cdot 3^2 \cdot 3^1 \\
                            &\equiv 16 \cdot 9 \cdot 3 \pmod{77} \\
                            &\equiv 432 \pmod{77} \\
                            &\equiv 432 - 5 \times 77 \pmod{77} \\
                            &\equiv 432 - 385 \pmod{77} \\
                            &\equiv 47 \pmod{77}
                            \end{align}\]

                            <p><strong>答案：</strong>Carol 应该发送 \(c = 47\)</p>

                            <p><strong>(vi) Bob 解密消息 \(y = 47\)：</strong></p>

                            <p><strong>步骤1：</strong>计算私钥 \(d\)：</p>
                            \[\phi(N) = (p-1)(q-1) = 6 \times 10 = 60\]
                            <p>需要求 \(d\) 使得 \(ed \equiv 1 \pmod{60}\)，即 \(11d \equiv 1 \pmod{60}\)</p>

                            <p>用扩展欧几里得算法：</p>
                            \[\begin{align}
                            60 &= 11 \times 5 + 5 \\
                            11 &= 5 \times 2 + 1
                            \end{align}\]
                            <p>回代：</p>
                            \[\begin{align}
                            1 &= 11 - 5 \times 2 \\
                            &= 11 - (60 - 11 \times 5) \times 2 \\
                            &= 11 - 60 \times 2 + 11 \times 10 \\
                            &= 11 \times 11 - 60 \times 2
                            \end{align}\]
                            <p>所以 \(d = 11\)</p>

                            <p><strong>步骤2：</strong>解密：</p>
                            \[m \equiv y^d \equiv 47^{11} \pmod{77}\]

                            <p>注意到 \(d = e = 11\)，且由 (v) 我们知道 \(3^{11} \equiv 47 \pmod{77}\)</p>
                            <p>所以 \(47^{11} \equiv 3 \pmod{77}\)</p>

                            <p><strong>答案：</strong>Carol 的原始消息是 \(m = 3\)</p>
                        </div>
                    </div>

                    <!-- Problem 2: RSA 性质 -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_fa24.pdf - Q11.5</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>考虑 RSA 加密系统，公钥 \((N, e)\)，私钥 \(d\)。加密 \(E(x) = x^e \pmod{N}\)，解密 \(D(y) = y^d \pmod{N}\)。
                            <br><br>
                            (a) 判断：\(D(E(x)) \equiv E(D(x)) \pmod{N}\) 对所有 \(x\) 成立吗？<br>
                            (b) 给出一个表达式来"解密"双重加密的 \(y \equiv E(E(x)) \pmod{N}\)（用 \(y\) 和可能的 \(E(\cdot)\)、\(D(\cdot)\) 表示）<br>
                            (c) 对于 \(a \equiv x^e \pmod{N}\) 和 \(b \equiv y^e \pmod{N}\)，\(D(ab) \pmod{N}\) 的值是什么？（答案可以用 \(x\) 和/或 \(y\) 表示）
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>(a) 判断 \(D(E(x)) \equiv E(D(x)) \pmod{N}\)：</strong></p>

                            <p>计算 \(D(E(x))\)：</p>
                            \[D(E(x)) = D(x^e) = (x^e)^d = x^{ed} \equiv x \pmod{N}\]

                            <p>计算 \(E(D(x))\)：</p>
                            \[E(D(x)) = E(x^d) = (x^d)^e = x^{de} = x^{ed} \equiv x \pmod{N}\]

                            <p>因为 \(ed \equiv 1 \pmod{\phi(N)}\)，由欧拉定理：</p>
                            \[x^{ed} = x^{k\phi(N)+1} = (x^{\phi(N)})^k \cdot x \equiv x \pmod{N}\]

                            <p><strong>答案：</strong>True（真）。对所有 \(x\)，都有 \(D(E(x)) \equiv E(D(x)) \equiv x \pmod{N}\)</p>

                            <p><strong>(b) 解密双重加密的 \(y \equiv E(E(x))\)：</strong></p>

                            <p>我们有：</p>
                            \[y \equiv E(E(x)) = E(x^e) = (x^e)^e = x^{e^2} \pmod{N}\]

                            <p>要恢复 \(x\)，需要计算 \(y^{d^2}\) 或 \(D(D(y))\)：</p>
                            \[D(D(y)) = D(y^d) = (y^d)^d = y^{d^2} = (x^{e^2})^{d^2} = x^{(ed)^2} \equiv x \pmod{N}\]

                            <p><strong>答案：</strong>\(D(D(y))\) 或等价地 \(y^{d^2} \pmod{N}\)</p>

                            <p><strong>(c) 计算 \(D(ab)\)：</strong></p>

                            <p>给定 \(a \equiv x^e \pmod{N}\) 和 \(b \equiv y^e \pmod{N}\)，计算：</p>
                            \[\begin{align}
                            D(ab) &= (ab)^d \pmod{N} \\
                            &= a^d b^d \pmod{N} \\
                            &= (x^e)^d (y^e)^d \pmod{N} \\
                            &= x^{ed} y^{ed} \pmod{N} \\
                            &\equiv x \cdot y \pmod{N}
                            \end{align}\]

                            <p><strong>答案：</strong>\(D(ab) \equiv xy \pmod{N}\)</p>

                            <p><strong>注意：</strong>这个性质说明 RSA 具有乘法同态性，这在某些密码学应用中很有用，但也可能成为安全隐患（chosen ciphertext attack）。</p>
                        </div>
                    </div>

                    <!-- Problem 3: 解多个同余方程 -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_fa24.pdf - Q9.2(a)</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>考虑 \(N = pqr\)，其中 \(p, q, r\) 是不同的素数。方程 \(qx \equiv 0 \pmod{N}\) 有多少个解？（解的范围为 \(x \in \{0, 1, \ldots, N-1\}\)）
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>分析：</strong>\(qx \equiv 0 \pmod{N}\) 意味着 \(N \mid qx\)，即 \(pqr \mid qx\)。</p>

                            <p>因为 \(q \mid qx\)，所以条件简化为 \(pr \mid x\)。</p>

                            <p><strong>详细推导：</strong></p>
                            \[qx \equiv 0 \pmod{pqr} \Leftrightarrow pqr \mid qx \Leftrightarrow pr \mid x\]

                            <p>在范围 \(\{0, 1, 2, \ldots, N-1\}\) 中，\(pr\) 的倍数有：</p>
                            \[0, pr, 2pr, 3pr, \ldots, (q-1)pr\]

                            <p><strong>计数：</strong></p>
                            <p>最大的倍数是 \((q-1)pr < qpr = N\)，所以符合条件的 \(x\) 有：</p>
                            \[0, pr, 2pr, \ldots, (q-1)pr\]
                            <p>共 \(q\) 个值（从 \(0 \cdot pr\) 到 \((q-1) \cdot pr\)）。</p>

                            <p><strong>验证：</strong>这 \(q\) 个解恰好填充了模 \(N = pqr\) 的整个范围。</p>

                            <p><strong>答案：</strong>有 \(\mathbf{pr}\) 个解。</p>

                            <p><strong>更正：</strong>实际上，\(x = 0, pr, 2pr, \ldots\) 在 \([0, N-1]\) 范围内，最大到 \(x = (q-1)pr < qpr = N\)。</p>
                            <p>所以解的个数是 \(\dfrac{N}{pr} = \dfrac{pqr}{pr} = q\)</p>

                            <p><strong>最终答案：</strong>\(\mathbf{pr}\)（或等价地 \(\dfrac{N}{q}\)）</p>
                        </div>
                    </div>
                </div>
            </div>

        </section>

        <!-- Section 7: Polynomials -->
        <section class="section" id="section7">
            <h2 class="section-title">7. Polynomials (多项式)</h2>

            <!-- 7.1 有限域与多项式基础 -->
            <div class="subsection" id="section7-1">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    7.1 有限域与多项式基础 (Finite Fields and Polynomial Basics)
                </h3>
                <div class="collapsible-content">
                    <div class="concept-box">
                        <h4>📚 核心概念</h4>
                        <p><strong>多项式定义：</strong>在有限域 \(\text{GF}(p)\) 上，一个 \(d\) 次多项式可以表示为：</p>
                        \[P(x) = a_d x^d + a_{d-1} x^{d-1} + \cdots + a_1 x + a_0\]
                        <p>其中 \(a_i \in \{0, 1, \ldots, p-1\}\)，\(a_d \neq 0\)。</p>

                        <p><strong>多项式的根：</strong>如果 \(P(r) \equiv 0 \pmod{p}\)，则 \(r\) 是多项式 \(P(x)\) 的根。</p>

                        <p><strong>关键性质：</strong></p>
                        <ul>
                            <li>在 \(\text{GF}(p)\) 上，度数为 \(d\) 的非零多项式最多有 \(d\) 个根</li>
                            <li>通过 \(d+1\) 个点可以唯一确定一个度数至多为 \(d\) 的多项式</li>
                            <li>两个度数至多为 \(d\) 的多项式如果在 \(d+1\) 个点上的值相同，则它们相同</li>
                        </ul>

                        <p><strong>多项式除法：</strong>给定多项式 \(P(x)\) 和 \(D(x)\)（\(D(x) \neq 0\)），存在唯一的商 \(Q(x)\) 和余数 \(R(x)\)，使得：</p>
                        \[P(x) = Q(x)D(x) + R(x)\]
                        <p>其中 \(\deg(R) < \deg(D)\) 或 \(R(x) = 0\)。</p>
                    </div>

                    <div class="formula-box">
                        <h4>📐 重要公式</h4>
                        <div class="formula-item">
                            <strong>多项式根的个数：</strong>
                            \[\text{度数为 } d \text{ 的多项式最多有 } d \text{ 个根}\]
                        </div>
                        <div class="formula-item">
                            <strong>唯一性定理：</strong>
                            <p>通过 \(d+1\) 个不同的点 \((x_0, y_0), (x_1, y_1), \ldots, (x_d, y_d)\) 可以唯一确定一个度数至多为 \(d\) 的多项式。</p>
                        </div>
                        <div class="formula-item">
                            <strong>因式分解：</strong>
                            <p>如果 \(r\) 是 \(P(x)\) 的根，则 \((x - r) \mid P(x)\)，即：</p>
                            \[P(x) = (x - r)Q(x)\]
                        </div>
                        <div class="formula-item">
                            <strong>度数为 \(d\) 的多项式个数：</strong>
                            <p>在 \(\text{GF}(p)\) 上，度数恰好为 \(d\) 的多项式有 \((p-1)p^d\) 个。</p>
                        </div>
                    </div>

                    <div class="tips-box">
                        <h4>💡 解题技巧</h4>
                        <ul>
                            <li>在有限域上，多项式运算都要模 \(p\) 进行</li>
                            <li>判断两个多项式是否相等，只需检查它们在 \(d+1\) 个点上的值</li>
                            <li>计算多项式个数时，注意区分"度数至多为 \(d\)"和"度数恰好为 \(d\)"</li>
                            <li>多项式除法中，余数的度数必须小于除数的度数</li>
                        </ul>
                    </div>

                    <!-- Problem 1: 多项式性质 -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_fa24.pdf - Q14</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>在 \(\text{GF}(p)\) 上：
                            <br><br>
                            (a) 度数恰好为 \(d\) 的多项式有多少个？<br>
                            (b) 度数恰好为 1 的多项式都有恰好 1 个根吗？<br>
                            (c) 给出一个二次多项式，它只在 \(x = 1\) 处有根。
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>(a) 度数恰好为 \(d\) 的多项式个数：</strong></p>
                            <p>度数恰好为 \(d\) 的多项式形式为：</p>
                            \[P(x) = a_d x^d + a_{d-1} x^{d-1} + \cdots + a_1 x + a_0\]
                            <p>其中 \(a_d \neq 0\)。</p>

                            <p><strong>计数：</strong></p>
                            <ul>
                                <li>\(a_d\) 有 \(p-1\) 种选择（\(1, 2, \ldots, p-1\)，不能为 0）</li>
                                <li>\(a_{d-1}, a_{d-2}, \ldots, a_1, a_0\) 各有 \(p\) 种选择（\(0, 1, \ldots, p-1\)）</li>
                                <li>共 \(d\) 个系数可以自由选择</li>
                            </ul>

                            <p><strong>答案：</strong>\((p-1) \cdot p^d\)</p>

                            <p><strong>(b) 度数恰好为 1 的多项式都有恰好 1 个根吗？</strong></p>
                            <p><strong>答案：True（真）</strong></p>

                            <p><strong>证明：</strong>度数为 1 的多项式形式为 \(P(x) = ax + b\)，其中 \(a \neq 0\)。</p>
                            <p>解方程 \(ax + b \equiv 0 \pmod{p}\)：</p>
                            \[x \equiv -a^{-1}b \pmod{p}\]
                            <p>因为 \(a \neq 0\) 且 \(p\) 是素数，所以 \(a^{-1}\) 存在且唯一。</p>
                            <p>因此方程有唯一解，即多项式有恰好 1 个根。</p>

                            <p><strong>(c) 给出只在 \(x = 1\) 处有根的二次多项式：</strong></p>
                            <p>我们需要一个形如 \(P(x) = (x-1)^2\) 的多项式（重根）。</p>

                            <p><strong>答案：</strong>\(P(x) = (x-1)^2 = x^2 - 2x + 1\)</p>

                            <p><strong>验证：</strong></p>
                            <ul>
                                <li>\(P(1) = 1 - 2 + 1 = 0\) ✓</li>
                                <li>对于 \(x \neq 1\)，\((x-1)^2 \not\equiv 0 \pmod{p}\)（当 \(p > 2\) 时）</li>
                            </ul>

                            <p><strong>注意：</strong>这是一个有重根的多项式。虽然它是二次多项式，但只有一个不同的根。</p>
                        </div>
                    </div>

                    <!-- Problem 2: 多项式除法 -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_fa24.pdf - Q12.4</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>给定多项式 \(P(x)\) 度数恰好为 \(d\)，\(D(x)\) 度数恰好为 \(d' < d\)。进行多项式除法得到 \(P(x) = Q(x)D(x) + R(x)\)，其中 \(R(x)\) 的度数尽可能小。
                            <br><br>
                            (a) \(Q(x)\) 的度数是多少？（用 \(d\) 和 \(d'\) 表示）<br>
                            (b) \(R(x)\) 的度数上界是多少？（用 \(d\) 和 \(d'\) 表示）
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>(a) \(Q(x)\) 的度数：</strong></p>

                            <p><strong>分析：</strong>因为 \(P(x) = Q(x)D(x) + R(x)\) 且 \(\deg(R) < \deg(D) = d'\)，所以：</p>
                            \[\deg(P) = \max(\deg(Q \cdot D), \deg(R))\]

                            <p>因为 \(\deg(R) < d' < d = \deg(P)\)，所以：</p>
                            \[\deg(P) = \deg(Q \cdot D) = \deg(Q) + \deg(D)\]

                            <p>因此：</p>
                            \[\begin{align}
                            \deg(Q) + d' &= d \\
                            \deg(Q) &= d - d'
                            \end{align}\]

                            <p><strong>答案：</strong>\(Q(x)\) 的度数恰好为 \(\mathbf{d - d'}\)</p>

                            <p><strong>(b) \(R(x)\) 的度数上界：</strong></p>

                            <p><strong>分析：</strong>多项式除法的定义要求余数 \(R(x)\) 的度数必须小于除数 \(D(x)\) 的度数。</p>

                            <p>因为 \(\deg(D) = d'\)，所以：</p>
                            \[\deg(R) < d'\]

                            <p>因此 \(R(x)\) 的度数至多为 \(d' - 1\)。</p>

                            <p><strong>答案：</strong>\(R(x)\) 的度数上界为 \(\mathbf{d' - 1}\)</p>

                            <p><strong>例子：</strong>如果 \(P(x) = x^5 + 2x^3 + 1\)（\(d = 5\)），\(D(x) = x^2 + 1\)（\(d' = 2\)），则：</p>
                            <ul>
                                <li>\(Q(x)\) 的度数为 \(5 - 2 = 3\)</li>
                                <li>\(R(x)\) 的度数至多为 \(2 - 1 = 1\)</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 7.2 拉格朗日插值 -->
            <div class="subsection" id="section7-2">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    7.2 拉格朗日插值 (Lagrange Interpolation)
                </h3>
                <div class="collapsible-content">
                    <div class="concept-box">
                        <h4>📚 核心概念</h4>
                        <p><strong>拉格朗日插值：</strong>给定 \(d+1\) 个点 \((x_0, y_0), (x_1, y_1), \ldots, (x_d, y_d)\)（其中 \(x_i\) 互不相同），可以构造唯一的度数至多为 \(d\) 的多项式 \(P(x)\)，使得 \(P(x_i) = y_i\)。</p>

                        <p><strong>拉格朗日基多项式：</strong>对于每个 \(i\)，定义：</p>
                        \[\Delta_i(x) = \prod_{j \neq i} \frac{x - x_j}{x_i - x_j}\]

                        <p><strong>关键性质：</strong></p>
                        \[\Delta_i(x_j) = \begin{cases}
                        1 & \text{如果 } i = j \\
                        0 & \text{如果 } i \neq j
                        \end{cases}\]

                        <p><strong>插值多项式：</strong></p>
                        \[P(x) = \sum_{i=0}^{d} y_i \Delta_i(x)\]
                    </div>

                    <div class="formula-box">
                        <h4>📐 重要公式</h4>
                        <div class="formula-item">
                            <strong>拉格朗日基多项式：</strong>
                            \[\Delta_i(x) = \frac{\prod_{j \neq i}(x - x_j)}{\prod_{j \neq i}(x_i - x_j)}\]
                        </div>
                        <div class="formula-item">
                            <strong>拉格朗日插值公式：</strong>
                            \[P(x) = \sum_{i=0}^{d} y_i \prod_{j \neq i} \frac{x - x_j}{x_i - x_j}\]
                        </div>
                        <div class="formula-item">
                            <strong>在 GF(p) 上的插值：</strong>
                            <p>所有运算都在模 \(p\) 下进行，除法用乘法逆元代替。</p>
                        </div>
                    </div>

                    <div class="tips-box">
                        <h4>💡 解题技巧</h4>
                        <ul>
                            <li>在 GF(p) 上，除法 \(\frac{a}{b}\) 要写成 \(a \cdot b^{-1} \pmod{p}\)</li>
                            <li>可以先计算每个 \(\Delta_i(x)\)，再用线性组合得到 \(P(x)\)</li>
                            <li>对于简单情况，可以直接设 \(P(x) = ax^2 + bx + c\) 并解方程组</li>
                            <li>验证答案时，将 \(x_i\) 代入 \(P(x)\) 检查是否得到 \(y_i\)</li>
                        </ul>
                    </div>

                    <!-- Problem 1: 拉格朗日插值实例 -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_fa24.pdf - Q12.1-12.2</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>在 \(\text{GF}(5)\) 上：
                            <br><br>
                            (a) 给出一个度数为 2 的多项式，通过点 \((0, 1)\)、\((1, 0)\) 和 \((3, 0)\)。<br>
                            (b) 考虑通过点 \((0, 0)\)、\((1, 1)\) 和 \((2, 4)\) 的度数为 2 的多项式。以标准形式 \(ax^2 + bx + c\) 表示，系数 \(a, b, c\) 是多少？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>(a) 通过 \((0, 1), (1, 0), (3, 0)\) 的多项式：</strong></p>

                            <p><strong>方法1：观察法</strong></p>
                            <p>注意到 \(x = 1\) 和 \(x = 3\) 都是根，所以多项式可以写成：</p>
                            \[P(x) = a(x - 1)(x - 3)\]

                            <p>利用 \(P(0) = 1\)：</p>
                            \[\begin{align}
                            a(0 - 1)(0 - 3) &\equiv 1 \pmod{5} \\
                            a \cdot (-1) \cdot (-3) &\equiv 1 \pmod{5} \\
                            3a &\equiv 1 \pmod{5} \\
                            a &\equiv 3^{-1} \equiv 2 \pmod{5}
                            \end{align}\]
                            <p>（因为 \(3 \times 2 = 6 \equiv 1 \pmod{5}\)）</p>

                            <p>所以：</p>
                            \[\begin{align}
                            P(x) &= 2(x - 1)(x - 3) \\
                            &= 2(x^2 - 4x + 3) \\
                            &= 2x^2 - 8x + 6 \\
                            &\equiv 2x^2 + 2x + 1 \pmod{5}
                            \end{align}\]

                            <p><strong>答案：</strong>\(P(x) = 2x^2 + 2x + 1\)</p>

                            <p><strong>验证：</strong></p>
                            <ul>
                                <li>\(P(0) = 0 + 0 + 1 = 1\) ✓</li>
                                <li>\(P(1) = 2 + 2 + 1 = 5 \equiv 0 \pmod{5}\) ✓</li>
                                <li>\(P(3) = 2(9) + 2(3) + 1 = 18 + 6 + 1 = 25 \equiv 0 \pmod{5}\) ✓</li>
                            </ul>

                            <p><strong>(b) 通过 \((0, 0), (1, 1), (2, 4)\) 的多项式：</strong></p>

                            <p><strong>方法：设 \(P(x) = ax^2 + bx + c\) 并解方程组</strong></p>

                            <p>利用三个点：</p>
                            \[\begin{cases}
                            P(0) = c = 0 \\
                            P(1) = a + b + c = 1 \\
                            P(2) = 4a + 2b + c = 4
                            \end{cases}\]

                            <p>从第一个方程：\(c = 0\)</p>

                            <p>代入后两个方程：</p>
                            \[\begin{cases}
                            a + b = 1 \\
                            4a + 2b = 4
                            \end{cases}\]

                            <p>从第一个方程：\(b = 1 - a\)</p>

                            <p>代入第二个方程：</p>
                            \[\begin{align}
                            4a + 2(1 - a) &\equiv 4 \pmod{5} \\
                            4a + 2 - 2a &\equiv 4 \pmod{5} \\
                            2a + 2 &\equiv 4 \pmod{5} \\
                            2a &\equiv 2 \pmod{5} \\
                            a &\equiv 1 \pmod{5}
                            \end{align}\]

                            <p>所以 \(a = 1\)，\(b = 1 - 1 = 0\)，\(c = 0\)。</p>

                            <p><strong>答案：</strong>\(a = 1, b = 0, c = 0\)</p>
                            <p>多项式为 \(P(x) = x^2\)</p>

                            <p><strong>验证：</strong></p>
                            <ul>
                                <li>\(P(0) = 0\) ✓</li>
                                <li>\(P(1) = 1\) ✓</li>
                                <li>\(P(2) = 4\) ✓</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Problem 2: 多项式个数 -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_fa24.pdf - Q12.3</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>给定 4 个点 \((x_1, y_1), (x_2, y_2), (x_3, y_3), (x_4, y_4)\)，在 \(\text{GF}(p)\)（\(p \geq 5\) 是素数）上，有多少个度数至多为 4 的多项式通过这 4 个点？（答案可能用 \(p\) 表示）
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>分析：</strong></p>
                            <p>我们有 4 个点，要求度数至多为 4 的多项式。</p>

                            <p>度数至多为 4 的多项式可以写成：</p>
                            \[P(x) = a_4 x^4 + a_3 x^3 + a_2 x^2 + a_1 x + a_0\]
                            <p>共有 5 个系数。</p>

                            <p><strong>关键观察：</strong></p>
                            <ul>
                                <li>4 个点给出 4 个约束条件</li>
                                <li>5 个系数减去 4 个约束，剩下 1 个自由度</li>
                            </ul>

                            <p><strong>详细分析：</strong></p>
                            <p>设 \(P(x)\) 是任意一个通过这 4 个点且度数至多为 3 的多项式（由唯一性，这样的多项式唯一存在）。</p>

                            <p>那么所有通过这 4 个点且度数至多为 4 的多项式可以表示为：</p>
                            \[Q(x) = P(x) + a_4 \cdot S(x)\]
                            <p>其中 \(S(x) = (x - x_1)(x - x_2)(x - x_3)(x - x_4)\) 是一个在 4 个点处都为 0 的多项式。</p>

                            <p>因为 \(S(x_i) = 0\) 对所有 \(i = 1, 2, 3, 4\)，所以：</p>
                            \[Q(x_i) = P(x_i) + a_4 \cdot 0 = P(x_i) = y_i\]

                            <p>\(a_4\) 可以取 \(\text{GF}(p)\) 中的任意值，共 \(p\) 种选择。</p>

                            <p><strong>答案：</strong>有 \(\mathbf{p}\) 个度数至多为 4 的多项式通过这 4 个点。</p>

                            <p><strong>一般规律：</strong>给定 \(k\) 个点，度数至多为 \(d\) 的多项式（\(d \geq k-1\)）有 \(p^{d-k+1}\) 个。</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 7.3 秘密共享 -->
            <div class="subsection" id="section7-3">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    7.3 秘密共享 (Secret Sharing)
                </h3>
                <div class="collapsible-content">
                    <div class="concept-box">
                        <h4>📚 核心概念</h4>
                        <p><strong>Shamir 秘密共享方案：</strong>将秘密 \(s\) 分享给 \(n\) 个人，使得任意 \(k\) 个人可以恢复秘密，但少于 \(k\) 个人无法获得任何信息。</p>

                        <p><strong>方案设计：</strong></p>
                        <ol>
                            <li>选择素数 \(p > s\) 和 \(p > n\)</li>
                            <li>构造度数为 \(k-1\) 的随机多项式 \(P(x)\)，使得 \(P(0) = s\)：
                                \[P(x) = s + a_1 x + a_2 x^2 + \cdots + a_{k-1} x^{k-1}\]
                                其中 \(a_1, \ldots, a_{k-1}\) 随机选择</li>
                            <li>给第 \(i\) 个人分配点 \((i, P(i))\)</li>
                            <li>任意 \(k\) 个人可以用拉格朗日插值恢复 \(P(x)\)，从而得到 \(s = P(0)\)</li>
                        </ol>

                        <p><strong>安全性：</strong>少于 \(k\) 个点无法唯一确定度数为 \(k-1\) 的多项式，因此无法得到秘密的任何信息。</p>
                    </div>

                    <div class="formula-box">
                        <h4>📐 重要公式</h4>
                        <div class="formula-item">
                            <strong>秘密共享方案参数：</strong>
                            <ul>
                                <li>秘密：\(s = P(0)\)</li>
                                <li>阈值：需要 \(k\) 个人</li>
                                <li>多项式度数：\(k - 1\)</li>
                                <li>总人数：\(n\) 个人</li>
                            </ul>
                        </div>
                        <div class="formula-item">
                            <strong>恢复秘密：</strong>
                            <p>给定 \(k\) 个点 \((x_1, y_1), \ldots, (x_k, y_k)\)，计算：</p>
                            \[s = P(0) = \sum_{i=1}^{k} y_i \prod_{j \neq i} \frac{0 - x_j}{x_i - x_j} = \sum_{i=1}^{k} y_i \prod_{j \neq i} \frac{-x_j}{x_i - x_j}\]
                        </div>
                    </div>

                    <div class="tips-box">
                        <h4>💡 解题技巧</h4>
                        <ul>
                            <li>\(k\) 个人恢复秘密 → 多项式度数为 \(k-1\)</li>
                            <li>多项式度数为 \(d\) → 需要 \(d+1\) 个点</li>
                            <li>多层秘密共享：可以嵌套使用秘密共享方案</li>
                            <li>模数 \(p\) 必须大于秘密值 \(s\) 和参与人数 \(n\)</li>
                        </ul>
                    </div>

                    <!-- Problem: UN Vault -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis05b.pdf - Q3</span>
                                <span class="difficulty">⭐⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>联合国金库可以用秘密组合 \(s \in \mathbb{Z}\) 打开。金库只能在以下两种情况下打开：
                            <br>
                            (i) 所有 193 个成员国都同意，或<br>
                            (ii) 至少 55 个国家加上秘书长同意。
                            <br><br>
                            (a) 设计一个方案，给秘书长和所有 193 个成员国分配私密信息，使得秘密组合 \(s\) 只能在上述两种情况下恢复。<br>
                            (b) 现在增加一个层级：每个国家有 12 个代表，必须所有 12 个代表都同意，该国才算同意。设计一个方案。
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>(a) 基本方案：</strong></p>

                            <p><strong>方案设计：</strong></p>
                            <ol>
                                <li><strong>第一层（国家层）：</strong>使用 \((194, 193)\)-秘密共享
                                    <ul>
                                        <li>构造度数为 192 的多项式 \(P(x)\)，使得 \(P(0) = s\)</li>
                                        <li>给每个成员国一个点：国家 \(i\) 得到 \((i, P(i))\)，\(i = 1, 2, \ldots, 193\)</li>
                                    </ul>
                                </li>
                                <li><strong>第二层（秘书长特权）：</strong>使用 \((56, 55)\)-秘密共享
                                    <ul>
                                        <li>构造度数为 54 的多项式 \(Q(x)\)，使得 \(Q(0) = s\)</li>
                                        <li>给秘书长和 55 个国家各一个点</li>
                                        <li>秘书长得到 \((0, Q(0)) = (0, s)\) 或一个特殊点</li>
                                        <li>前 55 个国家也各得到 \(Q(x)\) 上的一个点（但这会与第一层冲突）</li>
                                    </ul>
                                </li>
                            </ol>

                            <p><strong>更好的方案：</strong></p>
                            <ol>
                                <li>使用度数为 54 的多项式 \(P(x)\)，\(P(0) = s\)</li>
                                <li>给秘书长 55 个点：\((1, P(1)), (2, P(2)), \ldots, (55, P(55))\)</li>
                                <li>给国家 \(i\)（\(i = 1, 2, \ldots, 193\)）点 \((55 + i, P(55 + i))\)</li>
                            </ol>

                            <p><strong>验证：</strong></p>
                            <ul>
                                <li>55 个国家 + 秘书长：秘书长有 55 个点，加上任意 1 个国家的点，共 56 个点，可以恢复度数为 54 的多项式（需要 55 个点）✓</li>
                                <li>所有 193 个国家：193 个点足以恢复度数为 54 的多项式 ✓</li>
                                <li>少于 55 个国家（即使有秘书长）：最多 54 + 55 = 109 个点，但... 这实际上已经超过 55 个点了</li>
                            </ul>

                            <p><strong>正确方案：</strong></p>
                            <ul>
                                <li>使用度数为 192 的多项式 \(P_1(x)\)，\(P_1(0) = s\)，给每个国家一个点</li>
                                <li>使用度数为 54 的多项式 \(P_2(x)\)，\(P_2(0) = s\)，给秘书长 1 个点，给每个国家 1 个点</li>
                                <li>每个国家持有 \((P_1\) 上的点, \(P_2\) 上的点\())</li>
                                <li>秘书长持有 \(P_2\) 上的 1 个点</li>
                            </ul>

                            <p><strong>(b) 两层方案：</strong></p>

                            <p><strong>国家层：</strong>（与上面相同）</p>
                            <ul>
                                <li>度数为 192 和度数为 54 的两个多项式</li>
                            </ul>

                            <p><strong>代表层：</strong>对于每个国家 \(i\)：</p>
                            <ul>
                                <li>国家 \(i\) 在两个多项式上各有一个点：\((x_{i,1}, y_{i,1})\) 和 \((x_{i,2}, y_{i,2})\)</li>
                                <li>对于每个点，使用 \((12, 12)\)-秘密共享（度数为 11）</li>
                                <li>构造多项式 \(R_{i,1}(x)\) 使得 \(R_{i,1}(0) = y_{i,1}\)，给 12 个代表各一个点</li>
                                <li>构造多项式 \(R_{i,2}(x)\) 使得 \(R_{i,2}(0) = y_{i,2}\)，给 12 个代表各一个点</li>
                                <li>每个代表持有两个点</li>
                            </ul>

                            <p><strong>答案：</strong>使用嵌套的秘密共享方案，第一层处理国家间的关系，第二层处理国家内代表的关系。</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 7.4 纠错码 -->
            <div class="subsection" id="section7-4">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    7.4 纠错码 (Error Correcting Codes)
                </h3>
                <div class="collapsible-content">
                    <div class="concept-box">
                        <h4>📚 核心概念</h4>
                        <p><strong>纠错码基本思想：</strong>利用多项式的性质，在传输过程中检测和纠正错误。</p>

                        <p><strong>Reed-Solomon 码：</strong></p>
                        <ul>
                            <li><strong>编码：</strong>将 \(n\) 个消息符号 \(m_0, m_1, \ldots, m_{n-1}\) 编码为多项式 \(P(x)\) 的值</li>
                            <li><strong>传输：</strong>发送 \(P(0), P(1), \ldots, P(n+2k-1)\)（共 \(n+2k\) 个包）</li>
                            <li><strong>纠错能力：</strong>可以纠正至多 \(k\) 个一般错误，或恢复至多 \(k\) 个丢失包</li>
                        </ul>

                        <p><strong>Berlekamp-Welch 算法：</strong>用于纠正一般错误（值被修改）</p>
                        <ul>
                            <li>定义错误定位多项式 \(E(x) = \prod_{i \in \text{errors}} (x - i)\)</li>
                            <li>定义 \(Q(x) = P(x)E(x)\)</li>
                            <li>对于接收到的值 \(r_i\)：\(Q(i) = P(i)E(i) = r_i E(i)\)</li>
                            <li>求解 \(Q(x)\) 和 \(E(x)\)，然后计算 \(P(x) = Q(x) / E(x)\)</li>
                        </ul>
                    </div>

                    <div class="formula-box">
                        <h4>📐 重要公式</h4>
                        <div class="formula-item">
                            <strong>纠错码参数：</strong>
                            <ul>
                                <li>消息长度：\(n\) 个符号</li>
                                <li>多项式度数：\(d = n - 1\)</li>
                                <li>纠正 \(k\) 个错误：发送 \(n + 2k\) 个包</li>
                                <li>恢复 \(k\) 个丢失：发送 \(n + k\) 个包</li>
                            </ul>
                        </div>
                        <div class="formula-item">
                            <strong>Berlekamp-Welch 方程：</strong>
                            \[Q(i) = r_i E(i) \quad \text{对所有接收点 } i\]
                            <p>其中 \(\deg(E) = k\)，\(\deg(Q) = n - 1 + k\)</p>
                        </div>
                    </div>

                    <div class="tips-box">
                        <h4>💡 解题技巧</h4>
                        <ul>
                            <li>丢失包（erasure）：知道哪些包丢失，只需插值</li>
                            <li>一般错误（general error）：不知道哪些包错误，需要 Berlekamp-Welch</li>
                            <li>纠正 \(k\) 个一般错误需要 \(2k\) 个冗余包（因为需要定位错误）</li>
                            <li>检测错误：需要 \(d+1\) 个点来唯一确定度数为 \(d\) 的多项式</li>
                        </ul>
                    </div>

                    <!-- Problem: Treasure Hunt -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_sp24.pdf - Q9</span>
                                <span class="difficulty">⭐⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>学生们在岛上寻宝。宝藏位置 \((x, y)\) 满足 \(x = P(10) \bmod p\)，\(y = P(20) \bmod p\)，其中 \(P(x)\) 是度数为 2 的多项式，\(p > 20\) 是大素数。岛上散布着提示，每个提示包含整数 \(k\)（\(2 \leq k \leq p-1\)，\(k \neq 10, 20\)）和对应的 \(P(k)\) 值。
                            <br><br>
                            (a) 需要多少个提示才能确定宝藏的准确位置？<br>
                            (b) 找到一个提示后，有多少个可能的位置 \((x, y)\)？<br>
                            (c) 找到两个提示后，有多少个可能的位置？<br>
                            (d) 找到提示 \(P(0) = 5, P(1) = 5, P(3) = 11\)。求 \(P(x)\)。（\(p\) 未知但是大素数）<br>
                            (e) 已知 \(p = 89\)，用 (d) 的结果确定宝藏位置。<br>
                            (f) 如果一个提示可能错误，需要多少个提示才能判断是否有错误？<br>
                            (g) 有一个错误提示，需要多少个提示才能找到正确的多项式？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>(a) 需要多少个提示确定位置？</strong></p>
                            <p>度数为 2 的多项式需要 3 个点来唯一确定。</p>
                            <p><strong>答案：3 个提示</strong></p>

                            <p><strong>(b) 找到 1 个提示后，有多少可能位置？</strong></p>
                            <p>1 个提示给出 1 个点。度数至多为 2 的多项式通过 1 个点有无穷多个（在实数域），但在 GF(p) 上：</p>
                            <ul>
                                <li>度数至多为 2 的多项式有 \(p^3\) 个（3 个系数，每个有 \(p\) 种选择）</li>
                                <li>1 个点给出 1 个约束</li>
                                <li>剩余自由度：\(p^{3-1} = p^2\)</li>
                            </ul>
                            <p><strong>答案：\(p^2\) 个可能位置</strong></p>

                            <p><strong>(c) 找到 2 个提示后，有多少可能位置？</strong></p>
                            <p>2 个点给出 2 个约束，剩余自由度：\(p^{3-2} = p\)</p>
                            <p><strong>答案：\(p\) 个可能位置</strong></p>

                            <p><strong>(d) 求 \(P(x)\)，给定 \(P(0) = 5, P(1) = 5, P(3) = 11\)：</strong></p>

                            <p>设 \(P(x) = ax^2 + bx + c\)</p>

                            \[\begin{cases}
                            P(0) = c = 5 \\
                            P(1) = a + b + c = 5 \\
                            P(3) = 9a + 3b + c = 11
                            \end{cases}\]

                            <p>从第一个方程：\(c = 5\)</p>

                            <p>代入第二个方程：\(a + b + 5 = 5\)，所以 \(a + b = 0\)，即 \(b = -a\)</p>

                            <p>代入第三个方程：</p>
                            \[\begin{align}
                            9a + 3(-a) + 5 &= 11 \\
                            9a - 3a + 5 &= 11 \\
                            6a &= 6 \\
                            a &= 1
                            \end{align}\]

                            <p>所以 \(a = 1, b = -1 = 0, c = 5\)</p>

                            <p><strong>答案：</strong>\(P(x) = x^2 - x + 5\)</p>

                            <p><strong>验证：</strong></p>
                            <ul>
                                <li>\(P(0) = 0 - 0 + 5 = 5\) ✓</li>
                                <li>\(P(1) = 1 - 1 + 5 = 5\) ✓</li>
                                <li>\(P(3) = 9 - 3 + 5 = 11\) ✓</li>
                            </ul>

                            <p><strong>(e) 确定宝藏位置（\(p = 89\)）：</strong></p>

                            <p>使用 \(P(x) = x^2 - x + 5\)：</p>

                            \[\begin{align}
                            x &= P(10) = 100 - 10 + 5 = 95 \equiv 95 - 89 = 6 \pmod{89} \\
                            y &= P(20) = 400 - 20 + 5 = 385 \equiv 385 - 4 \times 89 = 385 - 356 = 29 \pmod{89}
                            \end{align}\]

                            <p><strong>答案：</strong>宝藏位置为 \((6, 29)\)</p>

                            <p><strong>(f) 判断是否有错误需要多少提示？</strong></p>
                            <p>要判断 1 个错误，需要至少 4 个提示：</p>
                            <ul>
                                <li>3 个点可以唯一确定度数为 2 的多项式</li>
                                <li>第 4 个点用于验证</li>
                                <li>如果第 4 个点不在多项式上，说明有错误</li>
                            </ul>
                            <p><strong>答案：4 个提示</strong></p>

                            <p><strong>(g) 纠正 1 个错误需要多少提示？</strong></p>
                            <p>使用 Berlekamp-Welch 算法纠正 \(k = 1\) 个错误：</p>
                            <ul>
                                <li>需要 \(n + 2k = 3 + 2 \times 1 = 5\) 个提示</li>
                                <li>\(E(x)\) 度数为 1（1 个错误）</li>
                                <li>\(Q(x) = P(x)E(x)\) 度数为 \(2 + 1 = 3\)</li>
                                <li>\(E(x)\) 有 2 个未知系数，\(Q(x)\) 有 4 个未知系数</li>
                                <li>共 6 个未知数，5 个方程... 实际上需要考虑 \(E(x)\) 的最高系数可以设为 1</li>
                                <li>实际未知数：5 个，需要 5 个方程</li>
                            </ul>
                            <p><strong>答案：5 个提示</strong></p>
                        </div>
                    </div>

                    <!-- Problem: Error Polynomial -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_fa24.pdf - Q13</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>考虑多项式 \(P(x) = 2x^2 + 3x + 3 \pmod{5}\)，发送 \(P(0), P(1), P(2), P(3), P(4)\)，但 \(P(1)\) 被损坏。
                            <br><br>
                            (a) 错误多项式 \(E(x) = x + b_0\)。\(b_0\) 是多少？<br>
                            (b) 定义 \(Q(x) = P(x)E(x) = q_d x^d + \cdots + q_1 x + q_0\)。<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;i. \(Q(x)\) 的度数 \(d\) 是多少？<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;ii. \(q_d\) 是多少？<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;iii. 用 \(b_0\) 表示 \(q_0\)。
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>(a) 求 \(b_0\)：</strong></p>

                            <p>错误多项式 \(E(x)\) 在错误位置为 0。因为 \(P(1)\) 被损坏，所以：</p>
                            \[E(1) = 0\]

                            \[\begin{align}
                            E(1) &= 1 + b_0 \equiv 0 \pmod{5} \\
                            b_0 &\equiv -1 \equiv 4 \pmod{5}
                            \end{align}\]

                            <p><strong>答案：</strong>\(b_0 = 4\)</p>

                            <p><strong>(b) 分析 \(Q(x) = P(x)E(x)\)：</strong></p>

                            <p><strong>(i) \(Q(x)\) 的度数：</strong></p>
                            \[\begin{align}
                            \deg(Q) &= \deg(P) + \deg(E) \\
                            &= 2 + 1 \\
                            &= 3
                            \end{align}\]
                            <p><strong>答案：</strong>\(d = 3\)</p>

                            <p><strong>(ii) \(q_d\) 的值：</strong></p>
                            <p>\(Q(x)\) 的最高次项来自 \(P(x)\) 和 \(E(x)\) 的最高次项相乘：</p>
                            \[\begin{align}
                            q_3 &= (\text{P的最高次系数}) \times (\text{E的最高次系数}) \\
                            &= 2 \times 1 \\
                            &= 2
                            \end{align}\]
                            <p><strong>答案：</strong>\(q_d = q_3 = 2\)</p>

                            <p><strong>(iii) 用 \(b_0\) 表示 \(q_0\)：</strong></p>
                            <p>\(Q(x) = P(x)E(x) = (2x^2 + 3x + 3)(x + b_0)\)</p>

                            <p>常数项 \(q_0\) 来自：</p>
                            \[q_0 = 3 \times b_0 = 3b_0\]

                            <p><strong>答案：</strong>\(q_0 = 3b_0\)</p>

                            <p><strong>完整展开验证：</strong></p>
                            \[\begin{align}
                            Q(x) &= (2x^2 + 3x + 3)(x + 4) \\
                            &= 2x^3 + 8x^2 + 3x^2 + 12x + 3x + 12 \\
                            &= 2x^3 + 11x^2 + 15x + 12 \\
                            &\equiv 2x^3 + x^2 + 0x + 2 \pmod{5}
                            \end{align}\]
                            <p>验证：\(q_0 = 12 \equiv 2 \pmod{5}\)，\(3b_0 = 3 \times 4 = 12 \equiv 2 \pmod{5}\) ✓</p>
                        </div>
                    </div>
                </div>
            </div>

        </section>

        <!-- ==================== Section 8: Counting ==================== -->
        <section class="section" id="counting">
            <h2 class="section-title">8. Counting (计数)</h2>

            <!-- 8.1 基本计数原理 -->
            <div class="subsection" id="section8-1">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    8.1 基本计数原理 (Basic Counting Principles)
                </h3>
                <div class="collapsible-content">
                    <div class="concept-box">
                        <h4>📚 核心概念</h4>

                        <p><strong>加法原理 (Sum Rule)：</strong>如果有 \(n\) 种方式做事情 A，\(m\) 种方式做事情 B，且两者不能同时发生，则有 \(n + m\) 种方式做 A 或 B。</p>

                        <p><strong>乘法原理 (Product Rule)：</strong>如果有 \(n\) 种方式做事情 A，每种方式后有 \(m\) 种方式做事情 B，则有 \(n \times m\) 种方式依次做 A 和 B。</p>

                        <p><strong>容斥原理 (Inclusion-Exclusion Principle)：</strong></p>
                        <ul>
                            <li>两个集合：\(|A \cup B| = |A| + |B| - |A \cap B|\)</li>
                            <li>三个集合：\(|A \cup B \cup C| = |A| + |B| + |C| - |A \cap B| - |A \cap C| - |B \cap C| + |A \cap B \cap C|\)</li>
                        </ul>

                        <p><strong>补集计数 (Complement Counting)：</strong>如果直接计数困难，可以计算补集：</p>
                        <ul>
                            <li>\(|\text{满足条件的}| = |\text{总数}| - |\text{不满足条件的}|\)</li>
                        </ul>
                    </div>

                    <div class="formula-box">
                        <h4>📐 重要公式</h4>
                        <div class="formula-item">
                            <strong>容斥原理（一般形式）：</strong>
                            \[|A_1 \cup A_2 \cup \cdots \cup A_n| = \sum_{i} |A_i| - \sum_{i<j} |A_i \cap A_j| + \sum_{i<j<k} |A_i \cap A_j \cap A_k| - \cdots\]
                        </div>
                    </div>

                    <div class="tips-box">
                        <h4>💡 解题技巧</h4>
                        <ul>
                            <li>选择加法还是乘法：问"或"用加法，问"然后"用乘法</li>
                            <li>使用补集：当"不满足条件"的情况更简单时</li>
                            <li>容斥原理：当有重叠情况时</li>
                            <li>分类讨论：按照不同情况分类，然后相加</li>
                        </ul>
                    </div>

                    <!-- Problem: Counting Passwords -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">Example</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>密码由 6 位数字组成。问：
                            <br><br>
                            (a) 有多少种不同的密码？<br>
                            (b) 有多少种密码不包含数字 0？<br>
                            (c) 有多少种密码至少包含一个 0？<br>
                            (d) 有多少种密码恰好包含一个 0？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>(a) 总共有多少种密码？</strong></p>
                            <p>每一位都有 10 种选择（0-9），共 6 位：</p>
                            \[10^6 = 1,000,000\]
                            <p><strong>答案：1,000,000 种</strong></p>

                            <p><strong>(b) 不包含 0 的密码数量？</strong></p>
                            <p>每一位都有 9 种选择（1-9），共 6 位：</p>
                            \[9^6 = 531,441\]
                            <p><strong>答案：531,441 种</strong></p>

                            <p><strong>(c) 至少包含一个 0 的密码数量？</strong></p>
                            <p>使用补集计数：</p>
                            \[\text{至少一个 0} = \text{总数} - \text{没有 0} = 10^6 - 9^6 = 1,000,000 - 531,441 = 468,559\]
                            <p><strong>答案：468,559 种</strong></p>

                            <p><strong>(d) 恰好包含一个 0 的密码数量？</strong></p>
                            <p>选择哪一位是 0：\(\binom{6}{1} = 6\) 种方式</p>
                            <p>其余 5 位不是 0：\(9^5\) 种方式</p>
                            \[6 \times 9^5 = 6 \times 59,049 = 354,294\]
                            <p><strong>答案：354,294 种</strong></p>
                        </div>
                    </div>

                    <!-- Problem: Derangements -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">Example</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>\(n\) 个人参加聚会，每人带一个礼物。随机分配礼物，问没有人得到自己礼物的概率是多少？（这叫做错位排列 Derangement）
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p>设 \(A_i\) 为第 \(i\) 个人得到自己礼物的事件。我们要求 \(P(\overline{A_1 \cup A_2 \cup \cdots \cup A_n})\)。</p>

                            <p><strong>使用容斥原理：</strong></p>
                            \[|A_1 \cup A_2 \cup \cdots \cup A_n| = \sum_{i} |A_i| - \sum_{i<j} |A_i \cap A_j| + \cdots\]

                            <p><strong>计算各项：</strong></p>
                            <ul>
                                <li>\(|A_i|\)：第 \(i\) 个人得到自己礼物，其余 \(n-1\) 个人随意排列：\((n-1)!\)</li>
                                <li>有 \(n\) 个这样的项，总和：\(n \cdot (n-1)! = n!\)</li>
                                <li>\(|A_i \cap A_j|\)：第 \(i\) 和第 \(j\) 个人都得到自己礼物：\((n-2)!\)</li>
                                <li>有 \(\binom{n}{2}\) 个这样的项，总和：\(\binom{n}{2} \cdot (n-2)! = \frac{n!}{2!}\)</li>
                                <li>一般地，\(k\) 个人得到自己礼物：\(\binom{n}{k} \cdot (n-k)! = \frac{n!}{k!}\)</li>
                            </ul>

                            <p><strong>容斥公式：</strong></p>
                            \[|A_1 \cup \cdots \cup A_n| = \frac{n!}{1!} - \frac{n!}{2!} + \frac{n!}{3!} - \cdots + (-1)^{n-1} \frac{n!}{n!}\]

                            <p><strong>错位排列数量：</strong></p>
                            \[\begin{align}
                            D_n &= n! - |A_1 \cup \cdots \cup A_n| \\
                            &= n! - \left(\frac{n!}{1!} - \frac{n!}{2!} + \frac{n!}{3!} - \cdots\right) \\
                            &= n! \left(1 - \frac{1}{1!} + \frac{1}{2!} - \frac{1}{3!} + \cdots + (-1)^n \frac{1}{n!}\right)
                            \end{align}\]

                            <p><strong>概率：</strong></p>
                            \[P(\text{错位排列}) = \frac{D_n}{n!} = \sum_{k=0}^{n} \frac{(-1)^k}{k!} \approx \frac{1}{e} \approx 0.368\]

                            <p><strong>答案：</strong>当 \(n\) 较大时，概率约为 \(\frac{1}{e} \approx 36.8\%\)</p>
                        </div>
                    </div>

                    <!-- Problem: Inclusion and Exclusion (dis06b) -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis06b.pdf - Problem 1</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>求小于 100 且与 100 互质的正整数个数。
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>分析：</strong>与 100 互质意味着 \(\gcd(n, 100) = 1\)。</p>

                            <p><strong>100 的质因数分解：</strong>\(100 = 2^2 \times 5^2\)</p>

                            <p>与 100 不互质的数是 2 或 5 的倍数。</p>

                            <p><strong>使用容斥原理：</strong></p>
                            <ul>
                                <li>设 \(A\) = 小于 100 的 2 的倍数集合</li>
                                <li>设 \(B\) = 小于 100 的 5 的倍数集合</li>
                                <li>我们要求 \(|\overline{A \cup B}|\)</li>
                            </ul>

                            <p><strong>计算各集合大小：</strong></p>
                            <ul>
                                <li>\(|A| = \lfloor \frac{99}{2} \rfloor = 49\)（2, 4, 6, ..., 98）</li>
                                <li>\(|B| = \lfloor \frac{99}{5} \rfloor = 19\)（5, 10, 15, ..., 95）</li>
                                <li>\(|A \cap B| = \lfloor \frac{99}{10} \rfloor = 9\)（10 的倍数：10, 20, ..., 90）</li>
                            </ul>

                            <p><strong>应用容斥原理：</strong></p>
                            \[|A \cup B| = |A| + |B| - |A \cap B| = 49 + 19 - 9 = 59\]

                            <p><strong>与 100 互质的数：</strong></p>
                            \[99 - |A \cup B| = 99 - 59 = 40\]

                            <p><strong>答案：40 个</strong></p>

                            <p><strong>验证：</strong>这也是欧拉函数 \(\phi(100)\) 的值。</p>
                            \[\phi(100) = 100 \times \left(1 - \frac{1}{2}\right) \times \left(1 - \frac{1}{5}\right) = 100 \times \frac{1}{2} \times \frac{4}{5} = 40\]
                        </div>
                    </div>

                    <!-- Problem: dis06a Problem 1(b) - US Phone Numbers -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis06a.pdf - Problem 1(b)</span>
                                <span class="difficulty">⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>美国电话号码由以下部分组成：
                            <ul>
                                <li>国家代码：总是 "+1"（固定）</li>
                                <li>地区码：3 位数字（任意）</li>
                                <li>电话前缀：3 位数字（任意）</li>
                                <li>线路号：4 位数字（任意）</li>
                            </ul>
                            有多少种不同的美国电话号码？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>分析：</strong>这是一个乘法原理问题，需要依次做决定。</p>

                            <p><strong>分解计算：</strong></p>
                            <ul>
                                <li><strong>国家代码：</strong>1 种选择（固定为 "+1"）</li>
                                <li><strong>地区码：</strong>3 位数字，每位有 10 种选择（0-9）：\(10^3 = 1,000\) 种</li>
                                <li><strong>电话前缀：</strong>3 位数字，每位有 10 种选择：\(10^3 = 1,000\) 种</li>
                                <li><strong>线路号：</strong>4 位数字，每位有 10 种选择：\(10^4 = 10,000\) 种</li>
                            </ul>

                            <p><strong>使用乘法原理：</strong></p>
                            \[\text{总数} = 1 \times 10^3 \times 10^3 \times 10^4 = 10^{10} = 10,000,000,000\]

                            <p><strong>答案：10,000,000,000 种（100 亿）</strong></p>

                            <p><strong>关键思想：</strong>当需要做一系列独立决定时，总的方法数是每个步骤方法数的乘积。</p>
                        </div>
                    </div>

                    <!-- Problem: dis06a Problem 3(c) - Password with Consecutive Zeros -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis06a.pdf - Problem 3(c)</span>
                                <span class="difficulty">⭐⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>The Count 想制作一个 10 位数字的密码保护他的手机。密码必须：
                            <ul>
                                <li>长度恰好是 10 位</li>
                                <li>只能包含数字 0 和 1</li>
                                <li>至少包含 5 个连续的 0</li>
                            </ul>
                            有多少种可能的密码？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>方法：补集计数</strong></p>

                            <p><strong>总数：</strong>10 位数字，每位可以是 0 或 1：</p>
                            \[2^{10} = 1,024\]

                            <p><strong>补集：</strong>不包含 5 个连续 0 的密码数量。</p>

                            <p><strong>计算补集（使用递推）：</strong></p>
                            <p>设 \(a_n\) 为长度为 \(n\) 且不包含 5 个连续 0 的二进制序列数量。</p>

                            <p><strong>递推关系：</strong>按照最后几位分类：</p>
                            <ul>
                                <li>最后一位是 1：前 \(n-1\) 位任意合法序列：\(a_{n-1}\)</li>
                                <li>最后一位是 0：前面不能有 4 个连续 0
                                    <ul>
                                        <li>最后两位是 10：\(a_{n-2}\)</li>
                                        <li>最后三位是 100：\(a_{n-3}\)</li>
                                        <li>最后四位是 1000：\(a_{n-4}\)</li>
                                        <li>最后五位是 10000：\(a_{n-5}\)</li>
                                    </ul>
                                </li>
                            </ul>

                            <p><strong>递推公式：</strong></p>
                            \[a_n = a_{n-1} + a_{n-2} + a_{n-3} + a_{n-4} + a_{n-5}\]

                            <p><strong>初始值：</strong></p>
                            <ul>
                                <li>\(a_1 = 2\) (0, 1)</li>
                                <li>\(a_2 = 4\) (00, 01, 10, 11)</li>
                                <li>\(a_3 = 8\) (所有 3 位二进制)</li>
                                <li>\(a_4 = 16\) (所有 4 位二进制)</li>
                                <li>\(a_5 = 31\) (除去 00000，其他都可以）</li>
                            </ul>

                            <p><strong>计算 \(a_6\) 到 \(a_{10}\)：</strong></p>
                            <ul>
                                <li>\(a_6 = 2 + 4 + 8 + 16 + 31 = 61\)</li>
                                <li>\(a_7 = 4 + 8 + 16 + 31 + 61 = 120\)</li>
                                <li>\(a_8 = 8 + 16 + 31 + 61 + 120 = 236\)</li>
                                <li>\(a_9 = 16 + 31 + 61 + 120 + 236 = 464\)</li>
                                <li>\(a_{10} = 31 + 61 + 120 + 236 + 464 = 912\)</li>
                            </ul>

                            <p><strong>至少包含 5 个连续 0 的密码：</strong></p>
                            \[2^{10} - a_{10} = 1,024 - 912 = 112\]

                            <p><strong>答案：112 种</strong></p>

                            <p><strong>关键思想：</strong></p>
                            <ul>
                                <li>对于"至少"类型的问题，考虑使用补集计数</li>
                                <li>对于有连续条件限制的问题，可以使用递推关系</li>
                                <li>递推关系的构造要按照"最后几位"分类，确保不重不漏</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 8.2 排列 -->
            <div class="subsection" id="section8-2">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    8.2 排列 (Permutations)
                </h3>
                <div class="collapsible-content">
                    <div class="concept-box">
                        <h4>📚 核心概念</h4>

                        <p><strong>排列：</strong>从 \(n\) 个不同元素中取出 \(k\) 个元素，按照一定顺序排列，顺序不同算作不同的排列。</p>

                        <p><strong>排列数公式：</strong></p>
                        \[P(n, k) = \frac{n!}{(n-k)!} = n \times (n-1) \times (n-2) \times \cdots \times (n-k+1)\]

                        <p><strong>特殊情况：</strong></p>
                        <ul>
                            <li><strong>全排列：</strong>\(P(n, n) = n!\)</li>
                            <li><strong>有重复元素的排列：</strong>如果有 \(n_1\) 个相同元素1，\(n_2\) 个相同元素2，...，\(n_k\) 个相同元素k，总共 \(n = n_1 + n_2 + \cdots + n_k\) 个元素，则排列数为：</li>
                        </ul>
                        \[\frac{n!}{n_1! \cdot n_2! \cdot \cdots \cdot n_k!}\]

                        <p><strong>圆形排列：</strong>\(n\) 个不同元素排成一个圆圈，旋转后相同的算作同一种排列：</p>
                        \[\frac{n!}{n} = (n-1)!\]
                    </div>

                    <div class="formula-box">
                        <h4>📐 重要公式</h4>
                        <div class="formula-item">
                            <strong>排列数：</strong>
                            \[P(n, k) = \frac{n!}{(n-k)!}\]
                        </div>
                        <div class="formula-item">
                            <strong>多重集排列（有重复元素）：</strong>
                            \[\frac{n!}{n_1! \cdot n_2! \cdot \cdots \cdot n_k!}\]
                        </div>
                        <div class="formula-item">
                            <strong>圆形排列：</strong>
                            \[(n-1)!\]
                        </div>
                    </div>

                    <div class="tips-box">
                        <h4>💡 解题技巧</h4>
                        <ul>
                            <li>区分排列和组合：顺序重要用排列，顺序不重要用组合</li>
                            <li>有重复元素：除以重复元素的阶乘</li>
                            <li>圆形排列：固定一个元素的位置，剩余元素排列</li>
                            <li>限制条件：可以先安排有限制的元素，再安排其他元素</li>
                        </ul>
                    </div>

                    <!-- Problem: Anagrams -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">Example</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>单词 "MISSISSIPPI" 有多少种不同的字母排列？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>分析字母频率：</strong></p>
                            <ul>
                                <li>M: 1 个</li>
                                <li>I: 4 个</li>
                                <li>S: 4 个</li>
                                <li>P: 2 个</li>
                                <li>总共：11 个字母</li>
                            </ul>

                            <p><strong>使用多重集排列公式：</strong></p>
                            \[\frac{11!}{1! \cdot 4! \cdot 4! \cdot 2!} = \frac{39,916,800}{1 \times 24 \times 24 \times 2} = \frac{39,916,800}{1,152} = 34,650\]

                            <p><strong>答案：34,650 种</strong></p>
                        </div>
                    </div>

                    <!-- Problem: Seating Arrangement -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">Example</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>5 个人坐在圆桌旁。
                            <br><br>
                            (a) 有多少种不同的坐法？<br>
                            (b) 如果 2 个特定的人必须坐在一起，有多少种坐法？<br>
                            (c) 如果 2 个特定的人不能坐在一起，有多少种坐法？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>(a) 圆形排列，总坐法数：</strong></p>
                            \[(5-1)! = 4! = 24\]
                            <p><strong>答案：24 种</strong></p>

                            <p><strong>(b) 两人必须坐在一起：</strong></p>
                            <p>将两人看作一个整体，有 4 个"元素"围圆桌：\((4-1)! = 3! = 6\)</p>
                            <p>两人内部可以交换位置：\(2! = 2\)</p>
                            \[6 \times 2 = 12\]
                            <p><strong>答案：12 种</strong></p>

                            <p><strong>(c) 两人不能坐在一起：</strong></p>
                            <p>使用补集计数：</p>
                            \[\text{不相邻} = \text{总数} - \text{相邻} = 24 - 12 = 12\]
                            <p><strong>答案：12 种</strong></p>
                        </div>
                    </div>

                    <!-- Problem: Password Permutations -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">Example</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>从 10 个不同字母中选 5 个排成密码，有多少种不同的密码？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>这是一个排列问题：</strong>从 10 个元素中选 5 个，顺序重要</p>
                            \[P(10, 5) = \frac{10!}{(10-5)!} = \frac{10!}{5!} = 10 \times 9 \times 8 \times 7 \times 6 = 30,240\]

                            <p><strong>答案：30,240 种</strong></p>
                        </div>
                    </div>

                    <!-- Problem: dis06a Problem 1(c) - Anagrams -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis06a.pdf - Problem 1(c)</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>单词 "COUNT" 和 "BERKELEY" 各有多少种字母重新排列（anagram）？
                            <br><br>
                            <em>（anagram 是对一个单词的字母进行重新排列，例如 "CTONU" 和 "TNUOC" 都是 "COUNT" 的 anagram）</em>
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>(1) "COUNT" 的 anagram 数量：</strong></p>

                            <p><strong>分析字母频率：</strong></p>
                            <ul>
                                <li>C: 1 个</li>
                                <li>O: 1 个</li>
                                <li>U: 1 个</li>
                                <li>N: 1 个</li>
                                <li>T: 1 个</li>
                                <li>总共：5 个不同字母</li>
                            </ul>

                            <p><strong>计算：</strong>所有字母都不同，直接全排列</p>
                            \[5! = 5 \times 4 \times 3 \times 2 \times 1 = 120\]

                            <p><strong>答案：120 种</strong></p>

                            <hr>

                            <p><strong>(2) "BERKELEY" 的 anagram 数量：</strong></p>

                            <p><strong>分析字母频率：</strong></p>
                            <ul>
                                <li>B: 1 个</li>
                                <li>E: 3 个  ← <strong>有重复</strong></li>
                                <li>R: 1 个</li>
                                <li>K: 1 个</li>
                                <li>L: 1 个</li>
                                <li>Y: 1 个</li>
                                <li>总共：8 个字母，其中 E 出现 3 次</li>
                            </ul>

                            <p><strong>使用多重集排列公式：</strong></p>
                            <p>由于有 3 个相同的 E，需要除以 \(3!\) 来去除重复计数：</p>
                            \[\frac{8!}{3!} = \frac{40,320}{6} = 6,720\]

                            <p><strong>答案：6,720 种</strong></p>

                            <p><strong>关键思想：</strong></p>
                            <ul>
                                <li>如果所有元素都不同，用 \(n!\)</li>
                                <li>如果有重复元素，需要除以每个重复元素的频率的阶乘</li>
                                <li>公式：\(\frac{n!}{n_1! \cdot n_2! \cdot \cdots \cdot n_k!}\)</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Problem: BAA Arrangements (midterm_sp25) -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_sp25.pdf - Q12.1</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>单词 "BAA" 有多少种不同的字母排列？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>分析：</strong>共 3 个字母，其中 A 重复 2 次。</p>

                            <p><strong>使用多重集排列公式：</strong></p>
                            \[\frac{3!}{2!} = \frac{6}{2} = 3\]

                            <p><strong>枚举验证：</strong></p>
                            <ul>
                                <li>BAA</li>
                                <li>ABA</li>
                                <li>AAB</li>
                            </ul>

                            <p><strong>答案：3 种</strong></p>
                        </div>
                    </div>

                    <!-- Problem: ADDED and AARDVARK (midterm_su25) -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_su25.pdf - Q12.3, Q12.4</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>求以下单词的字母排列（anagram）数量：
                            <br><br>
                            (a) "ADDED"<br>
                            (b) "AARDVARK"
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>(a) "ADDED" 的排列数：</strong></p>

                            <p><strong>字母统计：</strong></p>
                            <ul>
                                <li>A: 1 个</li>
                                <li>D: 3 个 ← <strong>有重复</strong></li>
                                <li>E: 1 个</li>
                                <li>总共：5 个字母</li>
                            </ul>

                            <p><strong>计算：</strong></p>
                            \[\frac{5!}{3!} = \frac{120}{6} = 20\]

                            <p><strong>答案：20 种</strong></p>

                            <hr>

                            <p><strong>(b) "AARDVARK" 的排列数：</strong></p>

                            <p><strong>字母统计：</strong></p>
                            <ul>
                                <li>A: 3 个 ← <strong>有重复</strong></li>
                                <li>R: 2 个 ← <strong>有重复</strong></li>
                                <li>D: 1 个</li>
                                <li>V: 1 个</li>
                                <li>K: 1 个</li>
                                <li>总共：8 个字母</li>
                            </ul>

                            <p><strong>计算：</strong>有多个重复字母</p>
                            \[\frac{8!}{3! \cdot 2!} = \frac{40,320}{6 \times 2} = \frac{40,320}{12} = 3,360\]

                            <p><strong>答案：3,360 种</strong></p>

                            <p><strong>技巧提示：</strong>当有多组重复元素时，分母是各组重复元素的阶乘之积。</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 8.3 组合 -->
            <div class="subsection" id="section8-3">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    8.3 组合 (Combinations)
                </h3>
                <div class="collapsible-content">
                    <div class="concept-box">
                        <h4>📚 核心概念</h4>

                        <p><strong>组合：</strong>从 \(n\) 个不同元素中取出 \(k\) 个元素，不考虑顺序，只关心选中哪些元素。</p>

                        <p><strong>组合数公式：</strong></p>
                        \[\binom{n}{k} = C(n, k) = \frac{n!}{k!(n-k)!} = \frac{P(n, k)}{k!}\]

                        <p><strong>重要性质：</strong></p>
                        <ul>
                            <li><strong>对称性：</strong>\(\binom{n}{k} = \binom{n}{n-k}\)</li>
                            <li><strong>帕斯卡恒等式：</strong>\(\binom{n}{k} = \binom{n-1}{k-1} + \binom{n-1}{k}\)</li>
                            <li><strong>二项式定理：</strong>\((x+y)^n = \sum_{k=0}^{n} \binom{n}{k} x^k y^{n-k}\)</li>
                            <li><strong>特殊值：</strong>\(\binom{n}{0} = \binom{n}{n} = 1\)</li>
                            <li><strong>组合和：</strong>\(\sum_{k=0}^{n} \binom{n}{k} = 2^n\)</li>
                        </ul>

                        <p><strong>多重组合（可重复选择）：</strong>从 \(n\) 种元素中选 \(k\) 个（可重复）：</p>
                        \[\binom{n+k-1}{k} = \binom{n+k-1}{n-1}\]
                    </div>

                    <div class="formula-box">
                        <h4>📐 重要公式</h4>
                        <div class="formula-item">
                            <strong>组合数：</strong>
                            \[\binom{n}{k} = \frac{n!}{k!(n-k)!}\]
                        </div>
                        <div class="formula-item">
                            <strong>二项式定理：</strong>
                            \[(x+y)^n = \sum_{k=0}^{n} \binom{n}{k} x^k y^{n-k}\]
                        </div>
                        <div class="formula-item">
                            <strong>范德蒙德恒等式 (Vandermonde's Identity)：</strong>
                            \[\binom{m+n}{r} = \sum_{k=0}^{r} \binom{m}{k} \binom{n}{r-k}\]
                        </div>
                        <div class="formula-item">
                            <strong>多重组合（重复组合）：</strong>
                            \[\binom{n+k-1}{k}\]
                        </div>
                    </div>

                    <div class="tips-box">
                        <h4>💡 解题技巧</h4>
                        <ul>
                            <li>排列 vs 组合：顺序重要用排列，顺序不重要用组合</li>
                            <li>使用对称性：\(\binom{n}{k} = \binom{n}{n-k}\)，选择较小的数计算</li>
                            <li>帕斯卡恒等式：可以递归计算组合数</li>
                            <li>二项式定理：展开 \((x+y)^n\) 或求和</li>
                            <li>多重组合：用 Stars and Bars 方法</li>
                        </ul>
                    </div>

                    <!-- Problem: Committee Selection -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">Example</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>从 12 个人中选 5 个人组成委员会，有多少种选法？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>这是组合问题：</strong>顺序不重要，只关心选中哪5个人</p>
                            \[\binom{12}{5} = \frac{12!}{5! \cdot 7!} = \frac{12 \times 11 \times 10 \times 9 \times 8}{5 \times 4 \times 3 \times 2 \times 1} = \frac{95,040}{120} = 792\]

                            <p><strong>答案：792 种</strong></p>
                        </div>
                    </div>

                    <!-- Problem: Binomial Theorem -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">Example</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>
                            <br><br>
                            (a) 展开 \((x+y)^4\)<br>
                            (b) 求 \((2+3)^4\) 中 \(2^2 \cdot 3^2\) 项的系数<br>
                            (c) 证明 \(\sum_{k=0}^{n} \binom{n}{k} = 2^n\)
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>(a) 展开 \((x+y)^4\)：</strong></p>
                            \[\begin{align}
                            (x+y)^4 &= \sum_{k=0}^{4} \binom{4}{k} x^k y^{4-k} \\
                            &= \binom{4}{0}y^4 + \binom{4}{1}xy^3 + \binom{4}{2}x^2y^2 + \binom{4}{3}x^3y + \binom{4}{4}x^4 \\
                            &= y^4 + 4xy^3 + 6x^2y^2 + 4x^3y + x^4
                            \end{align}\]

                            <p><strong>(b) 求 \(2^2 \cdot 3^2\) 项的系数：</strong></p>
                            <p>在展开式中，\(x^2y^2\) 项的系数是 \(\binom{4}{2} = 6\)</p>
                            <p>代入 \(x=2, y=3\)：系数仍为 6</p>
                            <p><strong>答案：6</strong></p>

                            <p><strong>(c) 证明组合和公式：</strong></p>
                            <p>在二项式定理中令 \(x = y = 1\)：</p>
                            \[\begin{align}
                            (1+1)^n &= \sum_{k=0}^{n} \binom{n}{k} 1^k \cdot 1^{n-k} \\
                            2^n &= \sum_{k=0}^{n} \binom{n}{k}
                            \end{align}\]

                            <p><strong>组合学解释：</strong>\(2^n\) 是 \(n\) 个元素集合的所有子集数量，\(\binom{n}{k}\) 是大小为 \(k\) 的子集数量，求和即得到所有子集。</p>
                        </div>
                    </div>

                    <!-- Problem: Poker Hand -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">Example</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>标准扑克牌 52 张（4 种花色，每种 13 张）。从中抽 5 张牌，问：
                            <br><br>
                            (a) 总共有多少种不同的牌型？<br>
                            (b) 有多少种"同花顺"（5 张同花色且连续）？<br>
                            (c) 有多少种"四条"（4 张同点数 + 1 张其他）？<br>
                            (d) 有多少种"葫芦"（3 张同点数 + 2 张同点数）？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>(a) 总牌型数：</strong></p>
                            \[\binom{52}{5} = \frac{52!}{5! \cdot 47!} = 2,598,960\]
                            <p><strong>答案：2,598,960 种</strong></p>

                            <p><strong>(b) 同花顺：</strong></p>
                            <ul>
                                <li>选择花色：4 种</li>
                                <li>选择起始点数：A-2-3-4-5, 2-3-4-5-6, ..., 10-J-Q-K-A，共 10 种（注意 A 可以在开头或结尾）</li>
                            </ul>
                            \[4 \times 10 = 40\]
                            <p><strong>答案：40 种</strong></p>

                            <p><strong>(c) 四条：</strong></p>
                            <ul>
                                <li>选择点数（四条）：13 种</li>
                                <li>该点数的 4 张牌都要：1 种</li>
                                <li>选择第 5 张牌的点数：12 种</li>
                                <li>选择第 5 张牌的花色：4 种</li>
                            </ul>
                            \[13 \times 1 \times 12 \times 4 = 624\]
                            <p><strong>答案：624 种</strong></p>

                            <p><strong>(d) 葫芦（Full House）：</strong></p>
                            <ul>
                                <li>选择三条的点数：13 种</li>
                                <li>从该点数的 4 张牌中选 3 张：\(\binom{4}{3} = 4\) 种</li>
                                <li>选择对子的点数：12 种（不能与三条相同）</li>
                                <li>从该点数的 4 张牌中选 2 张：\(\binom{4}{2} = 6\) 种</li>
                            </ul>
                            \[13 \times 4 \times 12 \times 6 = 3,744\]
                            <p><strong>答案：3,744 种</strong></p>
                        </div>
                    </div>

                    <!-- Problem: Vandermonde Identity -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">Example</span>
                                <span class="difficulty">⭐⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>用组合学方法证明范德蒙德恒等式：
                            \[\binom{m+n}{r} = \sum_{k=0}^{r} \binom{m}{k} \binom{n}{r-k}\]
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>组合学证明：</strong></p>

                            <p><strong>问题设定：</strong>有 \(m\) 个男生和 \(n\) 个女生，从中选 \(r\) 个人。</p>

                            <p><strong>左边：</strong>\(\binom{m+n}{r}\) 表示从 \(m+n\) 个人中直接选 \(r\) 个人。</p>

                            <p><strong>右边：</strong>按照选中的男生数量分类：</p>
                            <ul>
                                <li>选 \(k\) 个男生，\(r-k\) 个女生：\(\binom{m}{k} \binom{n}{r-k}\)</li>
                                <li>\(k\) 可以从 0 到 \(r\)（但不能超过 \(m\) 或使得 \(r-k > n\)）</li>
                                <li>对所有可能的 \(k\) 求和：\(\sum_{k=0}^{r} \binom{m}{k} \binom{n}{r-k}\)</li>
                            </ul>

                            <p><strong>结论：</strong>两种计数方式计算的是同一件事，因此相等。</p>

                            <p><strong>特例验证：</strong>令 \(m = n = r = 2\)：</p>
                            \[\begin{align}
                            \text{左边：} & \binom{4}{2} = 6 \\
                            \text{右边：} & \binom{2}{0}\binom{2}{2} + \binom{2}{1}\binom{2}{1} + \binom{2}{2}\binom{2}{0} \\
                            &= 1 \cdot 1 + 2 \cdot 2 + 1 \cdot 1 = 6 \quad ✓
                            \end{align}\]
                        </div>
                    </div>

                    <!-- Problem: CS70 The Musical (dis06b) -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis06b.pdf - Problem 2</span>
                                <span class="difficulty">⭐⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>CS70: The Musical - 组合恒等式的组合证明
                            <br><br>
                            使用组合论证（counting argument）证明以下恒等式：
                            <br><br>
                            (a) \(\binom{2n}{2} = 2\binom{n}{2} + n^2\)<br>
                            (b) \(\binom{n}{k} = \binom{n-1}{k-1} + \binom{n-1}{k}\)（帕斯卡恒等式）<br>
                            (c) \(\sum_{k=1}^{n} k\binom{n}{k} = n \cdot 2^{n-1}\)<br>
                            (d) \(\sum_{k=j}^{n} \binom{n}{k}\binom{k}{j} = 2^{n-j}\binom{n}{j}\)
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>(a) 证明 \(\binom{2n}{2} = 2\binom{n}{2} + n^2\)：</strong></p>

                            <p><strong>组合解释：</strong>有 \(2n\) 个人，其中前 \(n\) 个是 A 组，后 \(n\) 个是 B 组。从中选 2 个人有多少种方法？</p>

                            <ul>
                                <li><strong>左边：</strong>\(\binom{2n}{2}\) 直接从 \(2n\) 人中选 2 人</li>
                                <li><strong>右边：</strong>按照两人来自哪个组分类：
                                    <ul>
                                        <li>都来自 A 组：\(\binom{n}{2}\)</li>
                                        <li>都来自 B 组：\(\binom{n}{2}\)</li>
                                        <li>一个来自 A，一个来自 B：\(n \times n = n^2\)</li>
                                    </ul>
                                </li>
                            </ul>

                            \[\text{总数} = \binom{n}{2} + \binom{n}{2} + n^2 = 2\binom{n}{2} + n^2\]

                            <p><strong>(b) 证明帕斯卡恒等式 \(\binom{n}{k} = \binom{n-1}{k-1} + \binom{n-1}{k}\)：</strong></p>

                            <p><strong>组合解释：</strong>从 \(n\) 个人中选 \(k\) 个人。假设其中有一个特定的人（比如 Edward）。</p>

                            <ul>
                                <li><strong>左边：</strong>\(\binom{n}{k}\) 直接从 \(n\) 人中选 \(k\) 人</li>
                                <li><strong>右边：</strong>按照是否选中 Edward 分类：
                                    <ul>
                                        <li>选中 Edward：还需从剩余 \(n-1\) 人中选 \(k-1\) 人：\(\binom{n-1}{k-1}\)</li>
                                        <li>不选 Edward：从剩余 \(n-1\) 人中选 \(k\) 人：\(\binom{n-1}{k}\)</li>
                                    </ul>
                                </li>
                            </ul>

                            <p><strong>(c) 证明 \(\sum_{k=1}^{n} k\binom{n}{k} = n \cdot 2^{n-1}\)：</strong></p>

                            <p><strong>组合解释：</strong>从 \(n\) 个演员中选若干人（至少 1 人），并指定其中一人为主角，有多少种方法？</p>

                            <ul>
                                <li><strong>左边：</strong>先选 \(k\) 个人（\(\binom{n}{k}\) 种），再从这 \(k\) 人中选 1 人做主角（\(k\) 种）：
                                    \[\sum_{k=1}^{n} k\binom{n}{k}\]
                                </li>
                                <li><strong>右边：</strong>先选主角（\(n\) 种），剩余 \(n-1\) 人每人可选可不选（\(2^{n-1}\) 种）：
                                    \[n \cdot 2^{n-1}\]
                                </li>
                            </ul>

                            <p><strong>(d) 证明 \(\sum_{k=j}^{n} \binom{n}{k}\binom{k}{j} = 2^{n-j}\binom{n}{j}\)：</strong></p>

                            <p><strong>组合解释：</strong>从 \(n\) 个人中先选一个 \(j\) 人核心组，再从剩余人中选若干人加入扩展组。</p>

                            <ul>
                                <li><strong>左边：</strong>先选 \(k\) 个人（\(\binom{n}{k}\)），再从这 \(k\) 人中选 \(j\) 人做核心（\(\binom{k}{j}\)）：
                                    \[\sum_{k=j}^{n} \binom{n}{k}\binom{k}{j}\]
                                </li>
                                <li><strong>右边：</strong>先选 \(j\) 人核心组（\(\binom{n}{j}\)），剩余 \(n-j\) 人每人可选可不选（\(2^{n-j}\)）：
                                    \[2^{n-j}\binom{n}{j}\]
                                </li>
                            </ul>

                            <p><strong>关键思想：</strong>两种计数方式都在计算相同的对象集合，因此数量相等。这种证明方法叫做"双重计数"（double counting）或"组合证明"（combinatorial proof）。</p>
                        </div>
                    </div>

                    <!-- Problem: dis06a Problem 1(a) - Card Hands -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis06a.pdf - Problem 1(a)</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>从标准 52 张扑克牌中抽取 4 张牌，有多少种不同的手牌？（手牌中的牌的顺序不重要）
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>分析：</strong>这是一个组合问题，因为手牌中的牌的顺序不重要。</p>

                            <p><strong>公式：</strong>从 \(n\) 个不同元素中选 \(k\) 个（不考虑顺序）：</p>
                            \[\binom{n}{k} = \frac{n!}{k!(n-k)!}\]

                            <p><strong>计算：</strong></p>
                            \[\begin{align}
                            \binom{52}{4} &= \frac{52!}{4! \cdot 48!} \\
                            &= \frac{52 \times 51 \times 50 \times 49}{4 \times 3 \times 2 \times 1} \\
                            &= \frac{52 \times 51 \times 50 \times 49}{24} \\
                            &= \frac{6,497,400}{24} \\
                            &= 270,725
                            \end{align}\]

                            <p><strong>答案：270,725 种</strong></p>

                            <p><strong>提示：</strong>如果顺序重要（排列），答案将是 \(P(52, 4) = \frac{52!}{48!} = 52 \times 51 \times 50 \times 49 = 6,497,400\)。</p>
                        </div>
                    </div>

                    <!-- Problem: dis06a Problem 3(a) - Non-increasing Phone Number -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis06a.pdf - Problem 3(a)</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>The Count 想选择一个 7 位数的电话号码，要求数字从左到右非递增（non-increasing）。例如 9973220 是有效的，但 9876545 不是。有多少种选择？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>关键观察：</strong>非递增序列可以看作是从 10 个数字（0-9）中选择 7 个（允许重复），然后按降序排列。</p>

                            <p><strong>双射证明：</strong></p>
                            <ul>
                                <li>每个非递增序列唯一对应一个多重集（multiset）</li>
                                <li>例如，9973220 对应多重集 {9, 9, 7, 3, 2, 2, 0}</li>
                                <li>反之，每个多重集都可以按降序排列成一个非递增序列</li>
                            </ul>

                            <p><strong>问题转化：</strong>从 10 种数字中选择 7 个（允许重复）的方法数。</p>

                            <p><strong>使用 Stars and Bars 公式：</strong></p>
                            \[\binom{n + k - 1}{k} = \binom{10 + 7 - 1}{7} = \binom{16}{7}\]

                            <p><strong>计算：</strong></p>
                            \[\begin{align}
                            \binom{16}{7} &= \binom{16}{9} \quad (\text{对称性}) \\
                            &= \frac{16!}{7! \cdot 9!} \\
                            &= \frac{16 \times 15 \times 14 \times 13 \times 12 \times 11 \times 10}{7 \times 6 \times 5 \times 4 \times 3 \times 2 \times 1} \\
                            &= 11,440
                            \end{align}\]

                            <p><strong>答案：11,440 种</strong></p>
                        </div>
                    </div>

                    <!-- Problem: dis06a Problem 3(b) - Strictly Decreasing Phone Number -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis06a.pdf - Problem 3(b)</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>现在要求数字从左到右严格递减（strictly decreasing）。例如 9983220 不再有效，但 9753210 有效。有多少种选择？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>关键观察：</strong>严格递减意味着所有数字都不同。</p>

                            <p><strong>问题转化：</strong>从 10 个不同的数字（0-9）中选择 7 个（不允许重复），然后按降序排列。</p>

                            <p><strong>双射证明：</strong></p>
                            <ul>
                                <li>每个 7 位严格递减序列唯一对应一个 7 元素子集</li>
                                <li>例如，9753210 对应集合 {9, 7, 5, 3, 2, 1, 0}</li>
                                <li>反之，每个 7 元素子集都可以按降序排列成一个严格递减序列</li>
                            </ul>

                            <p><strong>计算：</strong>从 10 个数字中选 7 个的组合数：</p>
                            \[\begin{align}
                            \binom{10}{7} &= \binom{10}{3} \quad (\text{对称性}) \\
                            &= \frac{10 \times 9 \times 8}{3 \times 2 \times 1} \\
                            &= \frac{720}{6} \\
                            &= 120
                            \end{align}\]

                            <p><strong>答案：120 种</strong></p>

                            <p><strong>比较：</strong></p>
                            <ul>
                                <li>非递增（允许重复）：11,440 种</li>
                                <li>严格递减（不允许重复）：120 种</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Problem: Rummy Hands (midterm_su25) -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_su25.pdf - Q12.2</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>从标准 52 张扑克牌中发 7 张牌作为 Rummy 手牌。有多少种不同的手牌？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>问题分析：</strong>从 52 张牌中选 7 张，顺序不重要。</p>

                            <p><strong>这是组合问题：</strong></p>
                            \[\binom{52}{7} = \frac{52!}{7! \cdot 45!} = \frac{52 \times 51 \times 50 \times 49 \times 48 \times 47 \times 46}{7 \times 6 \times 5 \times 4 \times 3 \times 2 \times 1}\]

                            <p><strong>计算：</strong></p>
                            \[\binom{52}{7} = 133,784,560\]

                            <p><strong>答案：133,784,560 种</strong></p>

                            <p><strong>说明：</strong>这个数字远大于扑克牌的 5 张牌组合数 \(\binom{52}{5} = 2,598,960\)。</p>
                        </div>
                    </div>

                    <!-- Problem: Grid Paths (midterm_su25) -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">midterm_su25.pdf - Q12.1</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>在 7×7 的网格上，从左下角走到右上角，每步只能向右或向上移动一格。有多少种不同的路径？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>问题分析：</strong></p>
                            <ul>
                                <li>从左下角 (0,0) 到右上角 (7,7)</li>
                                <li>需要向右走 7 步（R），向上走 7 步（U）</li>
                                <li>总共 14 步</li>
                            </ul>

                            <p><strong>关键洞察：</strong>每条路径可以表示为 7 个 R 和 7 个 U 的排列。</p>

                            <p><strong>问题转化：</strong>从 14 个位置中选择 7 个位置放 R（剩余位置自动是 U）。</p>

                            <p><strong>计算：</strong></p>
                            \[\binom{14}{7} = \frac{14!}{7! \cdot 7!} = \frac{14 \times 13 \times 12 \times 11 \times 10 \times 9 \times 8}{7 \times 6 \times 5 \times 4 \times 3 \times 2 \times 1}\]

                            \[\binom{14}{7} = 3,432\]

                            <p><strong>答案：3,432 种路径</strong></p>

                            <p><strong>一般公式：</strong>对于 \(m \times n\) 网格，路径数为 \(\binom{m+n}{m} = \binom{m+n}{n}\)。</p>

                            <p><strong>例子路径：</strong>RRRRRRRRUUUUUUU（先全部向右，再全部向上）是其中一种。</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 8.4 Stars and Bars -->
            <div class="subsection" id="section8-4">
                <h3 class="subsection-title">
                    <button class="toggle-btn" onclick="toggleSection(this)">▶</button>
                    8.4 Stars and Bars (插板法)
                </h3>
                <div class="collapsible-content">
                    <div class="concept-box">
                        <h4>📚 核心概念</h4>

                        <p><strong>Stars and Bars 方法：</strong>用于解决将相同物品分配到不同容器的问题。</p>

                        <p><strong>基本问题：</strong>将 \(n\) 个相同的球放入 \(k\) 个不同的盒子，每个盒子可以为空，有多少种方法？</p>

                        <p><strong>可视化：</strong>用 \(n\) 个星号 ★ 表示球，用 \(k-1\) 个竖线 | 表示分隔符（将星号分成 \(k\) 组）。</p>

                        <p><strong>例子：</strong>5 个球放入 3 个盒子：★★|★|★★ 表示第一个盒子 2 个，第二个盒子 1 个，第三个盒子 2 个。</p>

                        <p><strong>公式推导：</strong></p>
                        <ul>
                            <li>总共有 \(n\) 个星号和 \(k-1\) 个竖线，共 \(n+k-1\) 个位置</li>
                            <li>从中选择 \(k-1\) 个位置放竖线（或选择 \(n\) 个位置放星号）</li>
                            <li>答案：\(\binom{n+k-1}{k-1} = \binom{n+k-1}{n}\)</li>
                        </ul>

                        <p><strong>变体问题：</strong></p>
                        <ul>
                            <li><strong>每个盒子至少一个球：</strong>先给每个盒子放 1 个球，剩余 \(n-k\) 个球任意分配：\(\binom{n-1}{k-1}\)</li>
                            <li><strong>限制每个盒子最多 \(m\) 个球：</strong>使用容斥原理</li>
                        </ul>
                    </div>

                    <div class="formula-box">
                        <h4>📐 重要公式</h4>
                        <div class="formula-item">
                            <strong>基本 Stars and Bars：</strong>
                            <p>\(n\) 个相同物品放入 \(k\) 个不同盒子（可空）：</p>
                            \[\binom{n+k-1}{k-1} = \binom{n+k-1}{n}\]
                        </div>
                        <div class="formula-item">
                            <strong>每个盒子至少一个：</strong>
                            <p>\(n\) 个相同物品放入 \(k\) 个不同盒子（非空）：</p>
                            \[\binom{n-1}{k-1}\]
                        </div>
                        <div class="formula-item">
                            <strong>多重组合：</strong>
                            <p>从 \(k\) 种元素中选 \(n\) 个（可重复）：</p>
                            \[\binom{n+k-1}{n}\]
                        </div>
                    </div>

                    <div class="tips-box">
                        <h4>💡 解题技巧</h4>
                        <ul>
                            <li>识别问题类型：相同物品 → 不同容器，考虑 Stars and Bars</li>
                            <li>画图理解：用星号和竖线画出具体例子</li>
                            <li>转换问题：将问题转换为"选择位置"的问题</li>
                            <li>每个至少一个：先分配必需的，再分配剩余的</li>
                            <li>多重组合：从 \(n\) 种元素选 \(k\) 个（可重复）= \(k\) 个相同球放入 \(n\) 个盒子</li>
                        </ul>
                    </div>

                    <!-- Problem: Distributing Candies -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">Example</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>将 10 个相同的糖果分给 4 个小孩，有多少种分法？（小孩可以不得到糖果）
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>这是 Stars and Bars 问题：</strong>10 个相同物品，4 个不同盒子，可空</p>

                            <p><strong>可视化：</strong>10 个星号，3 个竖线（分成 4 组）</p>
                            <p>例如：★★★|★|★★★★|★★ 表示 (3, 1, 4, 2)</p>

                            <p><strong>计算：</strong></p>
                            \[\binom{10+4-1}{4-1} = \binom{13}{3} = \frac{13 \times 12 \times 11}{3 \times 2 \times 1} = \frac{1,716}{6} = 286\]

                            <p><strong>答案：286 种</strong></p>
                        </div>
                    </div>

                    <!-- Problem: Each Child Gets at Least One -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">Example</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>将 10 个相同的糖果分给 4 个小孩，每个小孩至少得到 1 个糖果，有多少种分法？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>方法：</strong>先给每个小孩 1 个糖果，剩余 \(10 - 4 = 6\) 个糖果任意分配</p>

                            <p><strong>问题转化为：</strong>6 个相同糖果分给 4 个小孩（可空）</p>

                            <p><strong>计算：</strong></p>
                            \[\binom{6+4-1}{4-1} = \binom{9}{3} = \frac{9 \times 8 \times 7}{3 \times 2 \times 1} = \frac{504}{6} = 84\]

                            <p><strong>或使用公式：</strong>\(\binom{n-1}{k-1} = \binom{10-1}{4-1} = \binom{9}{3} = 84\)</p>

                            <p><strong>答案：84 种</strong></p>
                        </div>
                    </div>

                    <!-- Problem: Integer Solutions -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">Example</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>
                            <br><br>
                            (a) 方程 \(x_1 + x_2 + x_3 + x_4 = 20\) 有多少组非负整数解？<br>
                            (b) 有多少组正整数解？<br>
                            (c) 如果要求 \(x_1 \geq 2, x_2 \geq 1, x_3 \geq 0, x_4 \geq 0\)，有多少组解？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>(a) 非负整数解：</strong></p>
                            <p>等价于将 20 个相同物品放入 4 个不同盒子（可空）：</p>
                            \[\binom{20+4-1}{4-1} = \binom{23}{3} = \frac{23 \times 22 \times 21}{6} = 1,771\]
                            <p><strong>答案：1,771 组</strong></p>

                            <p><strong>(b) 正整数解：</strong></p>
                            <p>每个变量至少为 1，等价于将 20 个物品放入 4 个盒子，每个至少 1 个：</p>
                            \[\binom{20-1}{4-1} = \binom{19}{3} = \frac{19 \times 18 \times 17}{6} = 969\]
                            <p><strong>答案：969 组</strong></p>

                            <p><strong>(c) 带约束条件的解：</strong></p>
                            <p>要求：\(x_1 \geq 2, x_2 \geq 1, x_3 \geq 0, x_4 \geq 0\)</p>
                            <p>转换：令 \(y_1 = x_1 - 2, y_2 = x_2 - 1, y_3 = x_3, y_4 = x_4\)</p>
                            <p>则 \(y_i \geq 0\)，且：</p>
                            \[(y_1 + 2) + (y_2 + 1) + y_3 + y_4 = 20\]
                            \[y_1 + y_2 + y_3 + y_4 = 17\]
                            <p>这是非负整数解问题：</p>
                            \[\binom{17+4-1}{4-1} = \binom{20}{3} = \frac{20 \times 19 \times 18}{6} = 1,140\]
                            <p><strong>答案：1,140 组</strong></p>
                        </div>
                    </div>

                    <!-- Problem: Multiset Combinations -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">Example</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>从集合 \(\{a, b, c, d\}\) 中选 5 个元素（可重复），有多少种选法？例如：\(\{a, a, b, c, d\}\) 是一种选法。
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>这是多重组合问题：</strong>从 4 种元素中选 5 个（可重复）</p>

                            <p><strong>转换为 Stars and Bars：</strong></p>
                            <ul>
                                <li>设选 \(x_a\) 个 a，\(x_b\) 个 b，\(x_c\) 个 c，\(x_d\) 个 d</li>
                                <li>满足：\(x_a + x_b + x_c + x_d = 5\)，且 \(x_i \geq 0\)</li>
                                <li>这等价于 5 个相同球放入 4 个不同盒子（可空）</li>
                            </ul>

                            <p><strong>计算：</strong></p>
                            \[\binom{5+4-1}{4-1} = \binom{8}{3} = \frac{8 \times 7 \times 6}{3 \times 2 \times 1} = 56\]

                            <p><strong>答案：56 种</strong></p>

                            <p><strong>验证小例子：</strong>从 \(\{a, b\}\) 中选 2 个（可重复）：</p>
                            <ul>
                                <li>\(\{a, a\}\), \(\{a, b\}\), \(\{b, b\}\)，共 3 种</li>
                                <li>公式：\(\binom{2+2-1}{2-1} = \binom{3}{1} = 3\) ✓</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Problem: With Upper Bounds -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">Example</span>
                                <span class="difficulty">⭐⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>方程 \(x_1 + x_2 + x_3 = 10\) 的非负整数解中，满足 \(x_1 \leq 3\) 的有多少组？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>方法 1：直接计数（分类讨论）</strong></p>
                            <p>按 \(x_1\) 的值分类：</p>
                            <ul>
                                <li>\(x_1 = 0\)：\(x_2 + x_3 = 10\)，有 \(\binom{10+2-1}{2-1} = \binom{11}{1} = 11\) 组</li>
                                <li>\(x_1 = 1\)：\(x_2 + x_3 = 9\)，有 \(\binom{10}{1} = 10\) 组</li>
                                <li>\(x_1 = 2\)：\(x_2 + x_3 = 8\)，有 \(\binom{9}{1} = 9\) 组</li>
                                <li>\(x_1 = 3\)：\(x_2 + x_3 = 7\)，有 \(\binom{8}{1} = 8\) 组</li>
                            </ul>
                            \[\text{总数} = 11 + 10 + 9 + 8 = 38\]

                            <p><strong>方法 2：补集计数</strong></p>
                            <p>总的非负整数解：\(\binom{10+3-1}{3-1} = \binom{12}{2} = 66\)</p>
                            <p>不满足 \(x_1 \leq 3\) 的解（即 \(x_1 \geq 4\)）：</p>
                            <p>令 \(y_1 = x_1 - 4 \geq 0\)，则 \(y_1 + x_2 + x_3 = 6\)</p>
                            <p>非负整数解：\(\binom{6+3-1}{3-1} = \binom{8}{2} = 28\)</p>
                            \[\text{满足条件的解} = 66 - 28 = 38\]

                            <p><strong>答案：38 组</strong></p>
                        </div>
                    </div>

                    <!-- Problem: dis06a Problem 2(a) - Integer Solutions (non-negative) -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis06a.pdf - Problem 2(a)</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>方程 \(y_0 + y_1 + \cdots + y_k = n\) 有多少组非负整数解？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>分析：</strong>这是经典的 Stars and Bars 问题。</p>

                            <p><strong>问题等价于：</strong>将 \(n\) 个相同的球（stars）分配到 \(k+1\) 个不同的盒子（变量 \(y_0, y_1, \ldots, y_k\)），每个盒子可以为空。</p>

                            <p><strong>使用 Stars and Bars 公式：</strong></p>
                            <ul>
                                <li>\(n\) 个星号（表示总和为 \(n\)）</li>
                                <li>\(k\) 个竖线（将星号分成 \(k+1\) 组）</li>
                                <li>总共 \(n + k\) 个位置，选择其中 \(k\) 个位置放竖线</li>
                            </ul>

                            <p><strong>答案：</strong></p>
                            \[\binom{n+k}{k} = \binom{n+k}{n}\]

                            <p><strong>解释：</strong>从 \(n+k\) 个位置中选择 \(k\) 个位置放竖线，等价于选择 \(n\) 个位置放星号。</p>
                        </div>
                    </div>

                    <!-- Problem: dis06a Problem 2(b) - Integer Solutions (positive) -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis06a.pdf - Problem 2(b)</span>
                                <span class="difficulty">⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>方程 \(y_0 + y_1 + \cdots + y_k = n\) 有多少组正整数解？
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>分析：</strong>每个变量 \(y_i\) 都必须 \(\geq 1\)。</p>

                            <p><strong>方法 1：变量替换</strong></p>
                            <p>令 \(z_i = y_i - 1 \geq 0\)，则：</p>
                            \[\begin{align}
                            (z_0 + 1) + (z_1 + 1) + \cdots + (z_k + 1) &= n \\
                            z_0 + z_1 + \cdots + z_k &= n - (k+1)
                            \end{align}\]
                            <p>现在变成了非负整数解问题。</p>

                            <p><strong>方法 2：直观理解</strong></p>
                            <p>先给每个变量分配 1，剩余 \(n - (k+1)\) 个单位任意分配到 \(k+1\) 个变量。</p>

                            <p><strong>答案：</strong></p>
                            \[\binom{n - (k+1) + k}{k} = \binom{n-1}{k}\]

                            <p><strong>公式推导：</strong></p>
                            \[\binom{(n - k - 1) + k}{k} = \binom{n-1}{k}\]

                            <p><strong>注意：</strong>这个公式要求 \(n \geq k+1\)（否则无解）。</p>
                        </div>
                    </div>

                    <!-- Problem: dis06a Problem 2(c-e) - Berkeley Bowl Fruits -->
                    <div class="problem-card">
                        <div class="problem-header">
                            <div class="problem-meta">
                                <span class="source-tag">dis06a.pdf - Problem 2(c-e)</span>
                                <span class="difficulty">⭐⭐⭐</span>
                            </div>
                        </div>
                        <div class="problem-content">
                            <strong>题目：</strong>你去 Berkeley Bowl 买 \(k\) 个水果。计算以下情况的方法数：
                            <br><br>
                            (c) 市场上有桃子和苹果（2 种水果）<br>
                            (d) 市场上有桃子、苹果、橙子和梨（4 种水果）<br>
                            (e) 市场上有 \(n\) 种水果，且你想至少买 2 种不同类型的水果
                        </div>
                        <div class="answer-toggle">
                            <button class="toggle-answer-btn" onclick="toggleAnswer(this)">显示答案</button>
                        </div>
                        <div class="answer-box">
                            <strong>解答：</strong>

                            <p><strong>(c) 2 种水果（桃子和苹果）：</strong></p>
                            <p>设买 \(x_1\) 个桃子，\(x_2\) 个苹果，满足 \(x_1 + x_2 = k\)，其中 \(x_i \geq 0\)。</p>
                            <p>使用 Stars and Bars：</p>
                            \[\binom{k + 2 - 1}{2 - 1} = \binom{k+1}{1} = k+1\]
                            <p><strong>答案：\(k+1\) 种</strong></p>

                            <p><strong>(d) 4 种水果（桃子、苹果、橙子、梨）：</strong></p>
                            <p>设买 \(x_1, x_2, x_3, x_4\) 个四种水果，满足 \(x_1 + x_2 + x_3 + x_4 = k\)，其中 \(x_i \geq 0\)。</p>
                            <p>使用 Stars and Bars：</p>
                            \[\binom{k + 4 - 1}{4 - 1} = \binom{k+3}{3}\]
                            <p><strong>答案：\(\binom{k+3}{3}\) 种</strong></p>

                            <p><strong>(e) \(n\) 种水果，至少 2 种不同类型：</strong></p>
                            <p><strong>方法：补集计数</strong></p>
                            <ul>
                                <li><strong>总方法数：</strong>\(\binom{k+n-1}{n-1}\)（没有限制）</li>
                                <li><strong>只买 1 种水果的方法数：</strong>选择哪种水果买 \(k\) 个，有 \(n\) 种选择</li>
                            </ul>

                            <p><strong>答案：</strong></p>
                            \[\binom{k+n-1}{n-1} - n\]

                            <p><strong>验证 (c) 的情况：</strong>\(n = 2, k = k\)</p>
                            \[\binom{k+2-1}{2-1} - 2 = (k+1) - 2 = k - 1\]
                            <p>这表示至少买 2 种水果时，排除了"只买桃子"和"只买苹果"这两种情况 ✓</p>
                        </div>
                    </div>
                </div>
            </div>

        </section>

    </main>

    <!-- Back to Top Button -->
    <button class="back-to-top" id="backToTop" onclick="scrollToTop()">↑</button>

    <script>
        // Theme Toggle
        const themeToggle = document.getElementById('themeToggle');
        const body = document.body;

        themeToggle.addEventListener('click', () => {
            if (body.getAttribute('data-theme') === 'dark') {
                body.removeAttribute('data-theme');
                themeToggle.textContent = '🌙 深色模式';
                localStorage.setItem('theme', 'light');
            } else {
                body.setAttribute('data-theme', 'dark');
                themeToggle.textContent = '☀️ 浅色模式';
                localStorage.setItem('theme', 'dark');
            }
        });

        // Load saved theme
        if (localStorage.getItem('theme') === 'dark') {
            body.setAttribute('data-theme', 'dark');
            themeToggle.textContent = '☀️ 浅色模式';
        }

        // Sidebar Toggle
        const sidebarToggle = document.getElementById('sidebarToggle');
        const sidebar = document.getElementById('sidebar');

        sidebarToggle.addEventListener('click', () => {
            sidebar.classList.toggle('show');
        });

        // Scroll to Section
        function scrollToSection(id) {
            const element = document.getElementById(id);
            if (element) {
                element.scrollIntoView({ behavior: 'smooth', block: 'start' });
                // Close sidebar on mobile
                if (window.innerWidth <= 768) {
                    sidebar.classList.remove('show');
                }
            }
        }

        // Toggle Collapsible Section
        function toggleSection(button) {
            button.classList.toggle('open');
            const content = button.parentElement.nextElementSibling;
            content.classList.toggle('open');
        }

        // Toggle Answer
        function toggleAnswer(button) {
            const answerBox = button.parentElement.nextElementSibling;
            answerBox.classList.toggle('show');
            button.textContent = answerBox.classList.contains('show') ? '隐藏答案' : '显示答案';
        }

        // Back to Top
        const backToTop = document.getElementById('backToTop');

        window.addEventListener('scroll', () => {
            if (window.pageYOffset > 300) {
                backToTop.classList.add('show');
            } else {
                backToTop.classList.remove('show');
            }
        });

        function scrollToTop() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // Search Functionality
        const searchBox = document.getElementById('searchBox');

        searchBox.addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase();
            const sections = document.querySelectorAll('.subsection');

            sections.forEach(section => {
                const text = section.textContent.toLowerCase();
                if (text.includes(searchTerm) || searchTerm === '') {
                    section.style.display = 'block';
                } else {
                    section.style.display = 'none';
                }
            });
        });

        // Auto-open first section
        document.addEventListener('DOMContentLoaded', () => {
            const firstToggle = document.querySelector('.toggle-btn');
            if (firstToggle) {
                toggleSection(firstToggle);
            }
        });
    </script>

    <!-- Google Translate element and language toggle script -->
    <div id="google_translate_element"></div>
    <script>
      function googleTranslateElementInit() {
        new google.translate.TranslateElement({
          pageLanguage: 'zh-CN',
          includedLanguages: 'en,zh-CN',
          autoDisplay: false
        }, 'google_translate_element');
      }

      function setLang(lang) {
        var tries = 0;
        (function apply(){
          var combo = document.querySelector('.goog-te-combo');
          if (!combo) { if (tries++ < 50) return setTimeout(apply, 200); else return; }
          if (combo.value !== lang) combo.value = lang;
          combo.dispatchEvent(new Event('change'));
          try { localStorage.setItem('preferred_lang', lang); } catch(e) {}
        })();
      }

      document.addEventListener('click', function(e){
        var btn = e.target.closest('#langToggle [data-lang]');
        if (btn) setLang(btn.getAttribute('data-lang'));
      });

      window.addEventListener('load', function(){
        try {
          var saved = localStorage.getItem('preferred_lang');
          if (saved && saved !== 'zh-CN') setLang(saved);
        } catch(e) {}
      });
    </script>
    <script src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
</body>
</html>